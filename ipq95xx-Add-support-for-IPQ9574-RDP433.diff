diff --git a/target/linux/ipq95xx/Makefile b/target/linux/ipq95xx/Makefile
new file mode 100644
index 0000000000..e509f4eddd
--- /dev/null
+++ b/target/linux/ipq95xx/Makefile
@@ -0,0 +1,20 @@
+include $(TOPDIR)/rules.mk
+
+ARCH:=aarch64
+BOARD:=ipq95xx
+BOARDNAME:=Qualcomm Technologies, Inc. IPQ95XX
+FEATURES:=squashfs fpu ramdisk nand pcie
+CPU_TYPE:=cortex-a73
+CPU_SUBTYPE:=neon-vfpv4
+SUBTARGETS:=generic
+
+
+KERNELNAME:=Image dtbs
+KERNEL_PATCHVER:=6.1
+
+include $(INCLUDE_DIR)/target.mk
+
+DEFAULT_PACKAGES += \
+	e2fsprogs uboot-envtools kmod-leds-gpio kmod-gpio-button-hotplug kmod-button-hotplug
+
+$(eval $(call BuildTarget))
diff --git a/target/linux/ipq95xx/base-files/etc/inittab b/target/linux/ipq95xx/base-files/etc/inittab
new file mode 100644
index 0000000000..f0f8c76746
--- /dev/null
+++ b/target/linux/ipq95xx/base-files/etc/inittab
@@ -0,0 +1,18 @@
+# Copyright (c) 2013, 2020, The Linux Foundation. All rights reserved.
+# Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+::sysinit:/etc/init.d/rcS S boot
+::shutdown:/etc/init.d/rcS K shutdown
+ttyMSM0::askfirst:/usr/libexec/login.sh
diff --git a/target/linux/ipq95xx/config-6.1 b/target/linux/ipq95xx/config-6.1
new file mode 100644
index 0000000000..44176e4666
--- /dev/null
+++ b/target/linux/ipq95xx/config-6.1
@@ -0,0 +1,1206 @@
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_IRQ_FASTEOI_HIERARCHY_HANDLERS=y
+CONFIG_GENERIC_IRQ_IPI=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_MSI_IOMMU is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_HAVE_POSIX_CPU_TIMERS_TASK_WORK=y
+CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y
+CONFIG_CONTEXT_TRACKING=y
+CONFIG_CONTEXT_TRACKING_IDLE=y
+
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+# CONFIG_ARCH_BITMAIN is not set
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_ARCH_FORCE_MAX_ORDER=11
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_ARCH_IPQ40XX is not set
+# CONFIG_ARCH_IPQ5332 is not set
+# CONFIG_ARCH_IPQ6018 is not set
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+# CONFIG_ARCH_MDM9615 is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_ARCH_MILBEAUT is not set
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
+# CONFIG_ARCH_MSM8909 is not set
+# CONFIG_ARCH_MSM8916 is not set
+# CONFIG_ARCH_MSM8960 is not set
+# CONFIG_ARCH_MSM8974 is not set
+# CONFIG_ARCH_MSM8X60 is not set
+CONFIG_ARCH_MULTIPLATFORM=y
+CONFIG_ARCH_MULTI_V6_V7=y
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+# CONFIG_ARCH_NXP is not set
+CONFIG_ARCH_QCOM=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_STACKWALK=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANTS_NO_INSTR=y
+CONFIG_ARCH_WANTS_THP_SWAP=y
+CONFIG_ARM64=y
+CONFIG_ARM64_4K_PAGES=y
+CONFIG_ARM64_EPAN=y
+# CONFIG_ARM_QCOM_CPUFREQ_HW is not set
+# CONFIG_ARM_ARCH_TIMER_EVTSTREAM is not set
+# CONFIG_ARM64_CNP is not set
+# CONFIG_ARM64_ERRATUM_1742098 is not set
+# CONFIG_ARM64_ERRATUM_2051678 is not set
+# CONFIG_ARM64_ERRATUM_2054223 is not set
+# CONFIG_ARM64_ERRATUM_2067961 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_2441007 is not set
+# CONFIG_ARM64_ERRATUM_2441009 is not set
+# CONFIG_ARM64_ERRATUM_2658417 is not set
+# CONFIG_ARM64_PMEM is not set
+# CONFIG_ARM64_PSEUDO_NMI is not set
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_ARM64_TAGGED_ADDR_ABI=y
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_ARM_QCOM_CPUFREQ_NVMEM=y
+# CONFIG_ARM_QCOM_SPM_CPUIDLE is not set
+# CONFIG_RELOCATABLE is not set
+# CONFIG_RANDOMIZE_BASE is not set
+# CONFIG_RANDOMIZE_MODULE_REGION_FULL is not set
+# CONFIG_RANDOMIZE_KSTACK_OFFSET is not set
+CONFIG_ARCH_NR_GPIO=0
+
+CONFIG_CMDLINE=""
+# CONFIG_EFI is not set
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_USERSPACE_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+# CONFIG_ARM_HIGHBANK_CPUIDLE is not set
+CONFIG_ARM_PSCI=y
+CONFIG_ARM_PSCI_FW=y
+# CONFIG_ARM_SMMU is not set
+# CONFIG_ARM_SMMU_V3 is not set
+# CONFIG_QCOM_IOMMU is not set
+# CONFIG_VIRTIO_IOMMU is not set
+CONFIG_ATA=y
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_INLINE_ENCRYPTION=y
+CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK=y
+# CONFIG_VIRTIO_BLK is not set
+CONFIG_BMP280=y
+CONFIG_BMP280_I2C=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_BOUNCE=y
+# CONFIG_BPF_KPROBE_OVERRIDE is not set
+# CONFIG_BPFILTER is not set
+CONFIG_BRIDGE_VLAN_FILTERING=y
+# CONFIG_BT_HCIBTUSB_MTK is not set
+# CONFIG_BT_MTKSDIO is not set
+CONFIG_BUILD_BIN2C=y
+# CONFIG_BUS_TOPOLOGY_ADHOC is not set
+# CONFIG_CACHE_L2X0 is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+CONFIG_CFG80211_HEADERS=y
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_CHARGER_QCOM_SMBB is not set
+# CONFIG_CHARGER_UCS1002 is not set
+CONFIG_CLEANCACHE=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+CONFIG_CLKSRC_QCOM=y
+CONFIG_CLONE_BACKWARDS=y
+# CONFIG_CMA is not set
+# CONFIG_CMA_ALIGNMENT is not set
+# CONFIG_CMA_AREAS is not set
+# CONFIG_CMA_DEBUG is not set
+# CONFIG_CMA_DEBUGFS is not set
+# CONFIG_CMA_SIZE_MBYTES is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+# CONFIG_CMA_SIZE_SEL_MBYTES is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+CONFIG_CNSS2=y
+CONFIG_CNSS2_QCA9574_SUPPORT=y
+# CONFIG_CNSS2_CALIBRATION_SUPPORT is not set
+# CONFIG_CNSS2_DEBUG is not set
+CONFIG_CNSS2_GENL=y
+# CONFIG_CNSS2_PCI_DRIVER is not set
+# CONFIG_CNSS2_PM is not set
+# CONFIG_CNSS2_RAMDUMP is not set
+# CONFIG_CNSS2_SMMU is not set
+CONFIG_CNSS_QCN9000=y
+# CONFIG_SURFACE_PLATFORMS is not set
+CONFIG_COMMON_CLK=y
+CONFIG_COMMON_CLK_QCOM=y
+# CONFIG_COMMON_CLK_XGENE is not set
+# CONFIG_COMMON_CLK_SI5341 is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_COREDUMP=y
+CONFIG_CORESIGHT=y
+# CONFIG_CORESIGHT_BYTE_CNTR is not set
+# CONFIG_CORESIGHT_CATU is not set
+# CONFIG_CORESIGHT_CPU_DEBUG is not set
+CONFIG_CORESIGHT_CSR=y
+CONFIG_CORESIGHT_CTI=y
+# CONFIG_CORESIGHT_CTI_INTEGRATION_REGS is not set
+# CONFIG_CORESIGHT_TRBE is not set
+# CONFIG_CORESIGHT_CTI_SAVE_DISABLE is not set
+# CONFIG_CORESIGHT_DUMMY is not set
+CONFIG_CORESIGHT_HWEVENT=y
+CONFIG_CORESIGHT_LINKS_AND_SINKS=y
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
+# CONFIG_CORESIGHT_REMOTE_ETM is not set
+# CONFIG_CORESIGHT_SINK_ETBV10 is not set
+# CONFIG_CORESIGHT_SINK_TPIU is not set
+# CONFIG_CORESIGHT_SOURCE_ETM3X is not set
+CONFIG_CORESIGHT_SOURCE_ETM4X=y
+CONFIG_CORESIGHT_STM=y
+CONFIG_CORESIGHT_TPDA=y
+CONFIG_CORESIGHT_TPDM=y
+# CONFIG_CORESIGHT_TPDM_DEFAULT_ENABLE is not set
+# CONFIG_COUNTER is not set
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPUFREQ_DT_PLATDEV=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_SCHED_CLUSTER is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_HAS_ASID=y
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_ICACHE_MISMATCH_WORKAROUND is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_CPU_IDLE_GOV_TEO is not set
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_PM=y
+CONFIG_CPU_RMAP=y
+# CONFIG_CPU_SW_DOMAIN_PAN is not set
+# CONFIG_CPU_THERMAL is not set
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_V7=y
+CONFIG_CRC16=y
+# CONFIG_CRC32_SARWATE is not set
+CONFIG_CRC32_SLICEBY8=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CRYPTO_ADIANTUM is not set
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_DISABLE_AES192_TEST is not set
+CONFIG_CRYPTO_AES_586=y
+# CONFIG_CRYPTO_ALL_CASES is not set
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+# CONFIG_CRYPTO_DEV_HISI_ZIP is not set
+# CONFIG_CRYPTO_DEV_OTA_CRYPTO is not set
+CONFIG_CRYPTO_DEV_QCOM_ICE=y
+# CONFIG_CRYPTO_DEV_QCOM_MSM_QCE is not set
+# CONFIG_CRYPTO_DEV_QCOM_RNG is not set
+CONFIG_CRYPTO_DISABLE_AHASH_LARGE_KEY_TEST=y
+CONFIG_CRYPTO_DISABLE_AHASH_TYPE1_TESTS=y
+CONFIG_CRYPTO_DISABLE_AHASH_TYPE2_TESTS=y
+CONFIG_CRYPTO_DISABLE_AHASH_TYPE3_TESTS=y
+CONFIG_CRYPTO_DISABLE_AUTH_SPLIT_TESTS=y
+CONFIG_CRYPTO_DISABLE_HW_UNSUPPORTED_TESTS=y
+CONFIG_CRYPTO_DISABLE_OUTOFPLACE_TESTS=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_ECHAINIV=y
+# CONFIG_CRYPTO_ECRDSA is not set
+# CONFIG_CRYPTO_ESSIV is not set
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_LIB_UTILS=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_MANAGER_EXTRA_TESTS is not set
+CONFIG_CRYPTO_MD5_PPC=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_NO_AES_XTS_ZERO_KEY_SUPPORT=y
+CONFIG_CRYPTO_NO_AES_CTR_UNEVEN_DATA_LEN_SUPPORT=y
+# CONFIG_CRYPTO_NO_ZERO_LEN_HASH is not set
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_OFB=y
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_POLYVAL_ARM64_CE is not set
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA1_PPC=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+# CONFIG_CRYPTO_SM3_NEON is not set
+# CONFIG_CRYPTO_SM4_ARM64_CE_BLK is not set
+# CONFIG_CRYPTO_SM4_ARM64_NEON_BLK is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_XTS=y
+# CONFIG_CRYPTO_XXHASH is not set
+CONFIG_CRYPTO_XZ=y
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_EFI is not set
+CONFIG_DEBUG_GPIO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+CONFIG_DEBUG_KMEMLEAK_AUTO_SCAN=y
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_MISC is not set
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_UART_8250 is not set
+# CONFIG_DEBUG_USER is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEVMEM=y
+# CONFIG_DIAGFWD_BRIDGE_CODE is not set
+# CONFIG_DIAG_MHI is not set
+CONFIG_DIAG_OVER_QRTR=y
+# CONFIG_DIAG_OVER_USB is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMA_CMA is not set
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+# CONFIG_DMA_SOUND is not set
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+# CONFIG_DMI is not set
+# CONFIG_DMIID is not set
+# CONFIG_DMI_SYSFS is not set
+# CONFIG_DM_INIT is not set
+# CONFIG_DP83640_PHY is not set
+# CONFIG_DPS310 is not set
+CONFIG_DTC=y
+CONFIG_DT_IDLE_STATES=y
+# CONFIG_DWMAC_GENERIC is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EXT4_FS=y
+CONFIG_FIXED_PHY=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_FWNODE_MDIO=y
+CONFIG_FW_LOADER_PAGED_BUF=y
+# CONFIG_FW_CACHE is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+# CONFIG_GENERIC_CPUFREQ_KRAIT is not set
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_GENERIC_IO=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_PINCONF=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+# CONFIG_GEN_RTC is not set
+# CONFIG_GLACIER is not set
+# CONFIG_GLINK_DEBUG_FS is not set
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_GPIO_AMD_FCH is not set
+# CONFIG_GPIO_CADENCE is not set
+CONFIG_GPIO_DEVRES=y
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_LATCH is not set
+# CONFIG_GPIO_NXP_74HC153 is not set
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+CONFIG_GPIO_SYSFS=y
+# CONFIG_GPIO_USB_DETECT is not set
+# CONFIG_GSI is not set
+# CONFIG_HABANA_AI is not set
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_HAVE_SMP=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+# CONFIG_HIST_TRIGGERS is not set
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_MSM_LEGACY=y
+CONFIG_HW_RANDOM_CN10K=y
+CONFIG_HZ_FIXED=0
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_HELPER_AUTO=y
+# CONFIG_I2C_NVIDIA_GPU is not set
+# CONFIG_I2C_QCOM_CCI is not set
+CONFIG_I2C_QUP=y
+# CONFIG_I3C is not set
+# CONFIG_IGC is not set
+CONFIG_IIO=y
+# CONFIG_IIO_BUFFER is not set
+# CONFIG_IIO_TRIGGER is not set
+# CONFIG_ADMV8818 is not set
+# CONFIG_ADMV1014 is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_IKHEADERS is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+# CONFIG_BOOT_CONFIG is not set
+# CONFIG_INITRAMFS_PRESERVE_MTIME is not set
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# CONFIG_INPUT_GPIO_VIBRA is not set
+# CONFIG_INPUT_MSM_VIBRATOR is not set
+# CONFIG_INPUT_PM8941_PWRKEY is not set
+# CONFIG_INPUT_PM8XXX_VIBRATOR is not set
+# CONFIG_INTERCONNECT is not set
+CONFIG_IOMMU_HELPER=y
+# CONFIG_IOMMU_DEBUGFS is not set
+# CONFIG_IOMMU_DEFAULT_DMA_STRICT is not set
+# CONFIG_IOMMU_DEFAULT_DMA_LAZY is not set
+# CONFIG_IOMMU_DEFAULT_PASSTHROUGH is not set
+# CONFIG_IOMMU_IO_PGTABLE_LPAE is not set
+# CONFIG_IOMMU_IO_PGTABLE_ARMV7S is not set
+# CONFIG_IOMMU_IO_PGTABLE_DART is not set
+# CONFIG_OF_IOMMU is not set
+# CONFIG_IOMMU_DMA is not set
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_APQ_GCC_8084 is not set
+# CONFIG_APQ_MMCC_8084 is not set
+# CONFIG_IPQ_APSS_PLL is not set
+CONFIG_IPQ_APSS_6018=y
+CONFIG_IPQ_DEBUG=y
+# CONFIG_IPQ_GCC_4019 is not set
+# CONFIG_IPQ_GCC_5018 is not set
+# CONFIG_IPQ_GCC_5332 is not set
+# CONFIG_IPQ_GCC_6018 is not set
+# CONFIG_IPQ_GCC_806X is not set
+# CONFIG_IPQ_GCC_8074 is not set
+# CONFIG_IPQ_GCC_DEVSOC is not set
+CONFIG_IPQ_GCC_9574=y
+CONFIG_IPQ_NSSCC_9574=y
+# CONFIG_IPQ_LCC_806X is not set
+CONFIG_IPQ_REG_UPDATE=y
+# CONFIG_IPQ_REMOTEPROC_ADSP is not set
+CONFIG_IPQ_SUBSYSTEM_DUMP=y
+CONFIG_IPQ_SUBSYSTEM_RAMDUMP=y
+# CONFIG_IPQ_SUBSYSTEM_RESTART is not set
+# CONFIG_IPQ_SUBSYSTEM_RESTART_TEST is not set
+CONFIG_IPQ_TCSR=y
+CONFIG_IRQCHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_IRQ_FASTEOI_HIERARCHY_HANDLERS=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_IRQ_WORK=y
+CONFIG_JBD2=y
+# CONFIG_KCOV is not set
+CONFIG_KEYS=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+CONFIG_KPSS_XCC=y
+# CONFIG_KPROBE_EVENTS_ON_NOTRACE is not set
+# CONFIG_KRAITCC is not set
+# CONFIG_KRAIT_CLOCKS is not set
+# CONFIG_KRAIT_L2_ACCESSORS is not set
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_LEDS_IPQ=y
+# CONFIG_LEDS_LM3532 is not set
+# CONFIG_LEDS_PCA9956B is not set
+CONFIG_LEDS_TLC591XX=y
+# CONFIG_LEDS_TRIGGER_AUDIO is not set
+# CONFIG_LEDS_TRIGGER_PATTERN is not set
+# CONFIG_LEDS_PWM_MULTICOLOR is not set
+CONFIG_LIBFDT=y
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_LOCK_EVENT_COUNTS is not set
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+# CONFIG_LTC1660 is not set
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_MAILBOX=y
+# CONFIG_MAILBOX_TEST is not set
+# CONFIG_MAP_E_SUPPORT is not set
+# CONFIG_MAX31856 is not set
+# CONFIG_MAX44009 is not set
+# CONFIG_MAX5432 is not set
+# CONFIG_MB1232 is not set
+# CONFIG_MCP3911 is not set
+# CONFIG_MCP41010 is not set
+CONFIG_MDIO=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_BOARDINFO=y
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+CONFIG_MDIO_GPIO=y
+CONFIG_MDIO_QCA=y
+# CONFIG_MDM_GCC_9615 is not set
+# CONFIG_MDM_LCC_9615 is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_MAX77650 is not set
+CONFIG_MFD_QCOM_RPM=y
+# CONFIG_MFD_SPMI_PMIC is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TQMX86 is not set
+CONFIG_MHI_BUS=y
+CONFIG_MHI_BUS_DEBUG=y
+# CONFIG_MHI_BUS_RESERVED_DMA_POOL is not set
+CONFIG_MHI_NETDEV=y
+CONFIG_MHI_QTI=y
+# CONFIG_MHI_SATELLITE is not set
+CONFIG_MHI_UCI=y
+CONFIG_MHI_WWAN_CTRL=y
+CONFIG_MHI_BUS_PCI_GENERIC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_MIGRATION=y
+CONFIG_MMC=y
+CONFIG_MMC_ARMMMCI=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_CRYPTO=y
+CONFIG_MMC_QCOM_DML=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_MMC_SDHCI_MSM_ICE=y
+# CONFIG_MMC_SDHCI_OF_ARASAN is not set
+# CONFIG_MMC_SDHCI_OF_ASPEED is not set
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_STM32_SDMMC is not set
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_MODULES_USE_ELF_REL=y
+# CONFIG_MSM_GCC_8660 is not set
+# CONFIG_MSM_GCC_8909 is not set
+# CONFIG_MSM_GCC_8916 is not set
+# CONFIG_MSM_GCC_8939 is not set
+# CONFIG_MSM_GCC_8960 is not set
+# CONFIG_MSM_GCC_8974 is not set
+# CONFIG_MSM_GCC_8976 is not set
+# CONFIG_MSM_GCC_8994 is not set
+# CONFIG_MSM_GCC_8996 is not set
+# CONFIG_MSM_GCC_8998 is not set
+# CONFIG_MSM_GPUCC_8998 is not set
+# CONFIG_MSM_IOMMU is not set
+# CONFIG_MSM_LCC_8960 is not set
+# CONFIG_MSM_MHI is not set
+# CONFIG_MSM_MHI_DEBUG is not set
+# CONFIG_MSM_MHI_DEV is not set
+# CONFIG_MSM_MHI_UCI is not set
+# CONFIG_MSM_MMCC_8960 is not set
+# CONFIG_MSM_MMCC_8974 is not set
+# CONFIG_MSM_MMCC_8996 is not set
+# CONFIG_MSM_QMI_INTERFACE is not set
+# CONFIG_MSM_RPM_GLINK is not set
+CONFIG_MSM_RPM_LOG=y
+CONFIG_MSM_RPM_RPMSG=y
+# CONFIG_MSM_RPM_SMD is not set
+# CONFIG_MSM_SECURE_BUFFER is not set
+# CONFIG_MSM_SMEM is not set
+# CONFIG_MSM_TEST_QMI_CLIENT is not set
+# CONFIG_MSM_MMCC_8998 is not set
+# CONFIG_QCM_GCC_2290 is not set
+# CONFIG_QCM_DISPCC_2290 is not set
+# CONFIG_MTD_SPLIT_BCM_WFI_FW is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_HYPERBUS is not set
+CONFIG_MTD_M25P80=y
+# CONFIG_MTD_NAND_ECC_SW_BCH is not set
+# CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC is not set
+CONFIG_MTD_NAND_QCOM=y
+# CONFIG_MTD_NAND_QCOM_SERIAL is not set
+# CONFIG_MTD_QCOMSMEM_PARTS is not set
+CONFIG_MTD_RAW_NAND=y
+# CONFIG_MTD_ROUTERBOOT_PARTS is not set
+CONFIG_MTD_SPINAND_GIGADEVICE=y
+CONFIG_MTD_SPINAND_MT29F=y
+CONFIG_MTD_SPINAND_ONDIEECC=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPLIT_ELF_FW is not set
+CONFIG_MTD_SPLIT_FIRMWARE=y
+CONFIG_MTD_SPLIT_FIT_FW=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_BEB_LIMIT=20
+CONFIG_MTD_UBI_BLOCK=y
+# CONFIG_MTD_UBI_FASTMAP is not set
+CONFIG_MTD_UBI_GLUEBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MULTI_IRQ_HANDLER=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEON=y
+CONFIG_NET=y
+# CONFIG_VIRTIO_NET is not set
+# CONFIG_NET_DSA_MV88E6063 is not set
+CONFIG_NET_FLOW_LIMIT=y
+CONFIG_NET_L3_MASTER_DEV=y
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NET_SCH_TAPRIO is not set
+CONFIG_NET_SWITCHDEV=y
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NF_CONNTRACK_DSCPREMARK_EXT is not set
+# CONFIG_NF_IPV6_DUMMY_HEADER is not set
+# CONFIG_NI_XGE_MANAGEMENT_ENET is not set
+# CONFIG_NOA1305 is not set
+CONFIG_NO_BOOTMEM=y
+CONFIG_NO_HZ=y
+CONFIG_NO_HZ_COMMON=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NR_CPUS=4
+# CONFIG_NULL_TTY is not set
+# CONFIG_NUMA is not set
+CONFIG_NUM_ALT_PARTITION=16
+CONFIG_NVME_HWMON=y
+CONFIG_NVMEM=y
+# CONFIG_NVMEM_SYSFS is not set
+CONFIG_NVMEM_QCOM_QFPROM=y
+# CONFIG_NVMEM_RMEM is not set
+# CONFIG_NVMEM_U_BOOT_ENV is not set
+# CONFIG_OCTEONTX2_AF is not set
+# CONFIG_OCTEON_EP is not set
+CONFIG_OF=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_ADDRESS_PCI=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+CONFIG_OF_NET=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_SLIMBUS is not set
+CONFIG_OLD_SIGACTION=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_PADATA=y
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PAGE_TABLE_CHECK is not set
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_PCI=y
+# CONFIG_PCIEAER is not set
+# CONFIG_PCIE_AL is not set
+# CONFIG_PCIE_CADENCE_EP is not set
+CONFIG_PCIE_DW=y
+# CONFIG_PCIE_DW_PLAT is not set
+# CONFIG_PCIE_PME is not set
+CONFIG_PCIE_QCOM=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_PCS_XPCS=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_PHYLIB=y
+CONFIG_PHYLINK=y
+CONFIG_PHY_IPQ_UNIPHY_PCIE=y
+CONFIG_PHYS_OFFSET=0x40000000
+# CONFIG_PHY_QCOM_APQ8064_SATA is not set
+# CONFIG_PHY_QCOM_EDP is not set
+# CONFIG_PHY_QCOM_IPQ4019_USB is not set
+# CONFIG_PHY_QCOM_IPQ806X_SATA is not set
+# CONFIG_PHY_QCOM_IPQ806X_USB is not set
+# CONFIG_PHY_QCOM_PCIE2 is not set
+CONFIG_PHY_QCOM_QMP=y
+# CONFIG_PHY_QCOM_QUSB2 is not set
+# CONFIG_PHY_QCOM_UFS is not set
+# CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2 is not set
+# CONFIG_PHY_QCOM_USB_HS_28NM is not set
+# CONFIG_PHY_QCOM_USB_SS is not set
+CONFIG_PINCTRL=y
+# CONFIG_PINCTRL_APQ8064 is not set
+# CONFIG_PINCTRL_APQ8084 is not set
+# CONFIG_PINCTRL_DEVSOC is not set
+# CONFIG_PINCTRL_IPQ4019 is not set
+# CONFIG_PINCTRL_IPQ5018 is not set
+# CONFIG_PINCTRL_IPQ5332 is not set
+# CONFIG_PINCTRL_IPQ6018 is not set
+# CONFIG_PINCTRL_IPQ8064 is not set
+# CONFIG_PINCTRL_IPQ8074 is not set
+CONFIG_PINCTRL_IPQ9574=y
+# CONFIG_PINCTRL_MDM9615 is not set
+CONFIG_PINCTRL_MSM=y
+# CONFIG_PINCTRL_MSM8226 is not set
+# CONFIG_PINCTRL_MSM8660 is not set
+# CONFIG_PINCTRL_MSM8909 is not set
+# CONFIG_PINCTRL_MSM8916 is not set
+# CONFIG_PINCTRL_MSM8960 is not set
+# CONFIG_PINCTRL_MSM8976 is not set
+# CONFIG_PINCTRL_MSM8994 is not set
+# CONFIG_PINCTRL_MSM8996 is not set
+# CONFIG_PINCTRL_MSM8998 is not set
+# CONFIG_PINCTRL_QCOM_SPMI_PMIC is not set
+# CONFIG_PINCTRL_QCOM_SSBI_PMIC is not set
+# CONFIG_PINCTRL_QCM2290 is not set
+# CONFIG_PINCTRL_QCS404 is not set
+# CONFIG_PINCTRL_SC7180 is not set
+# CONFIG_PINCTRL_SC8280XP is not set
+# CONFIG_PINCTRL_SDM660 is not set
+# CONFIG_PINCTRL_SDM845 is not set
+# CONFIG_PINCTRL_SDX65 is not set
+# CONFIG_PINCTRL_SM8150 is not set
+# CONFIG_PINCTRL_SM6350 is not set
+# CONFIG_PINCTRL_SM6375 is not set
+# CONFIG_PINCTRL_SM8250 is not set
+# CONFIG_PINCTRL_SM8450 is not set
+# CONFIG_PINCTRL_STMFX is not set
+# CONFIG_PKCS7_TEST_KEY is not set
+# CONFIG_PKCS7_MESSAGE_PARSER is not set
+# CONFIG_PKCS8_PRIVATE_KEY_PARSER is not set
+# CONFIG_PL330_DMA is not set
+CONFIG_PM=y
+# CONFIG_PM8916_WATCHDOG is not set
+CONFIG_PM_CLK=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_GENERIC_DOMAINS=y
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_MSM=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_PPS=y
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+# CONFIG_PREEMPT_DYNAMIC is not set
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_RCU=y
+# CONFIG_COMPAT_ALIGNMENT_FIXUPS is not set
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_PRINTK_TIME=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_STRIPPED is not set
+# CONFIG_PSI is not set
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_PUBLIC_KEY_ALGO_RSA=y
+# CONFIG_PVPANIC is not set
+CONFIG_PWM=y
+CONFIG_PWM_IPQ=y
+# CONFIG_PWM_PCA9685 is not set
+CONFIG_PWM_SYSFS=y
+# CONFIG_PWM_CLK is not set
+# CONFIG_PWM_XILINX is not set
+# CONFIG_PWRSEQ_EMMC is not set
+CONFIG_PWRSEQ_IPQ=y
+# CONFIG_PWRSEQ_SIMPLE is not set
+CONFIG_QCA_MINIDUMP=y
+# CONFIG_QCA_MINIDUMP_DEBUG is not set
+# CONFIG_QCOM_A53PLL is not set
+CONFIG_QCOM_ADM=y
+# CONFIG_QCOM_AOSS_QMP is not set
+CONFIG_QCOM_APCS_IPC=y
+CONFIG_QCOM_APM=y
+# CONFIG_QCOM_MPM is not set
+# CONFIG_QCOM_IPCC is not set
+# CONFIG_QCOM_APR is not set
+CONFIG_QCOM_BAM_DMA=y
+CONFIG_QCOM_CACHE_DUMP=y
+CONFIG_QCOM_CACHE_DUMP_ON_PANIC=y
+# CONFIG_QCOM_CPR is not set
+# CONFIG_QCOM_OCMEM is not set
+# CONFIG_QCOM_SPM is not set
+# CONFIG_QCOM_STATS is not set
+# CONFIG_QCOM_WCNSS_CTRL is not set
+# CONFIG_QCOM_ICC_BWMON is not set
+# CONFIG_QCOM_CLK_APCS_MSM8916 is not set
+# CONFIG_QCOM_CLK_APCC_MSM8996 is not set
+# CONFIG_QCOM_CLK_APCS_SDX55 is not set
+# CONFIG_QCOM_CLK_RPM is not set
+# CONFIG_QCOM_CLK_SMD_RPM is not set
+# CONFIG_QCOM_COINCELL is not set
+# CONFIG_QCOM_COMMAND_DB is not set
+CONFIG_QCOM_DLOAD_MODE=y
+CONFIG_QCOM_DLOAD_MODE_APPSBL=y
+# CONFIG_QCOM_EBI2 is not set
+# CONFIG_QCOM_FASTRPC is not set
+CONFIG_QCOM_GDSC=y
+# CONFIG_QCOM_GENI_SE is not set
+CONFIG_QCOM_GLINK_SSR=y
+# CONFIG_QCOM_GSBI is not set
+# CONFIG_QCOM_HFPLL is not set
+# CONFIG_QCOM_LLCC is not set
+# CONFIG_QCOM_NON_SECURE_PIL is not set
+CONFIG_QCOM_Q6V5_MPD=y
+# CONFIG_QCOM_PDC is not set
+# CONFIG_QCOM_PM is not set
+# CONFIG_QCOM_Q6V5_ADSP is not set
+# CONFIG_QCOM_Q6V5_MSS is not set
+# CONFIG_QCOM_Q6V5_PAS is not set
+# CONFIG_QCOM_Q6V5_WCSS is not set
+CONFIG_QCOM_QFPROM=y
+CONFIG_QCOM_QMI_HELPERS=y
+CONFIG_QCOM_RESTART_REASON=y
+# CONFIG_QCOM_RMTFS_MEM is not set
+# CONFIG_QCOM_RPMH is not set
+# CONFIG_QCOM_RPMPD is not set
+CONFIG_QCOM_RPM_CLK=y
+# CONFIG_QCOM_RTB is not set
+CONFIG_QCOM_SCM=y
+CONFIG_QCOM_SCM_32=y
+CONFIG_QCOM_SCM_DOWNLOAD_MODE_DEFAULT=y
+# CONFIG_QCOM_SMD is not set
+CONFIG_QCOM_SMD_RPM=y
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMEM_STATE=y
+CONFIG_QCOM_SMP2P=y
+# CONFIG_QCOM_SMSM is not set
+CONFIG_QCOM_SOC_NETSTANDBY=y
+CONFIG_QCOM_SOCINFO=y
+# CONFIG_QCOM_SPMI_ADC5 is not set
+# CONFIG_QCOM_SPMI_TEMP_ALARM is not set
+# CONFIG_QCOM_SPMI_VADC is not set
+CONFIG_QCOM_SYSMON=y
+CONFIG_QCOM_TSENS=y
+CONFIG_QCOM_WDT=y
+CONFIG_QCOM_DCC_V2=y
+# CONFIG_QCS_GCC_404 is not set
+# CONFIG_QCS_Q6SSTOP_404 is not set
+# CONFIG_QCS_TURING_404 is not set
+# CONFIG_HP_WATCHDOG is not set
+CONFIG_RAS=y
+CONFIG_RATIONAL=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_EXPERT is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_REED_SOLOMON_TEST is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_ALLOW_WRITE_DEBUGFS=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_CPR3=y
+CONFIG_REGULATOR_CPR3_NPU=y
+CONFIG_REGULATOR_CPR4_APSS=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
+# CONFIG_REGULATOR_IPQ40XX is not set
+# CONFIG_REGULATOR_QCOM_RPM is not set
+CONFIG_REGULATOR_QCOM_SMD_RPM=y
+# CONFIG_REGULATOR_QCOM_SPMI is not set
+CONFIG_REGULATOR_QTI_GPIO=y
+CONFIG_REGULATOR_RPM_GLINK=y
+# CONFIG_REGULATOR_RPM_SMD is not set
+# CONFIG_REGULATOR_VQMMC_IPQ4019 is not set
+CONFIG_RELAY=y
+CONFIG_REMOTEPROC=y
+# CONFIG_REMOTEPROC_CDEV is not set
+# CONFIG_RESET_ATTACK_MITIGATION is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_QCOM_AOSS is not set
+# CONFIG_RESET_QCOM_PDC is not set
+# CONFIG_QCOM_WCNSS_PIL is not set
+CONFIG_QRTR=y
+CONFIG_QRTR_MHI=y
+CONFIG_QRTR_SMD=y
+CONFIG_RFS_ACCEL=y
+# CONFIG_RODATA_FULL_DEFAULT_ENABLED is not set
+CONFIG_RPMSG=y
+CONFIG_RPMSG_CHAR=y
+# CONFIG_RPMSG_CTRL is not set
+# CONFIG_RPMSG_NS is not set
+CONFIG_RPMSG_QCOM_GLINK_RPM=y
+CONFIG_RPMSG_QCOM_GLINK_SMEM=y
+CONFIG_RPMSG_QCOM_SMD=y
+# CONFIG_RPMSG_TTY is not set
+# CONFIG_RPMSG_VIRTIO is not set
+CONFIG_RPS=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_PM8XXX is not set
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_SAMPLES=y
+# CONFIG_SAMPLE_AUXDISPLAY is not set
+# CONFIG_SAMPLE_CONFIGFS is not set
+# CONFIG_SAMPLE_HW_BREAKPOINT is not set
+# CONFIG_SAMPLE_KFIFO is not set
+# CONFIG_SAMPLE_KOBJECT is not set
+# CONFIG_SAMPLE_KPROBES is not set
+# CONFIG_SAMPLE_KRETPROBES is not set
+# CONFIG_SAMPLE_WATCHDOG is not set
+# CONFIG_SAMPLE_CORESIGHT_SYSCFG is not set
+CONFIG_SAMPLE_QMI_CLIENT=m
+# CONFIG_SAMPLE_RPMSG_CLIENT is not set
+# CONFIG_SAMPLE_TRACE_ARRAY is not set
+# CONFIG_SAMPLE_TRACE_CUSTOM_EVENTS is not set
+CONFIG_SAMPLE_TRACE_EVENTS=y
+# CONFIG_SAMPLE_TRACE_PRINTK is not set
+# CONFIG_SAMPLE_VFIO_MDEV_MDPY_FB is not set
+# CONFIG_SATA_AHCI is not set
+CONFIG_SCHED_HRTICK=y
+# CONFIG_SCHED_INFO is not set
+# CONFIG_SC_DISPCC_7180 is not set
+# CONFIG_SC_MSS_7180 is not set
+# CONFIG_SC_VIDEOCC_7180 is not set
+# CONFIG_SC_CAMCC_7280 is not set
+# CONFIG_SC_DISPCC_7280 is not set
+# CONFIG_SC_GCC_7180 is not set
+# CONFIG_SC_GCC_8280XP is not set
+# CONFIG_SC_GPUCC_7180 is not set
+# CONFIG_SC_LPASSCC_7280 is not set
+# CONFIG_SC_LPASS_CORECC_7180 is not set
+# CONFIG_SC_LPASS_CORECC_7280 is not set
+CONFIG_UACCE=y
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_MYRS is not set
+CONFIG_SCSI_SCAN_ASYNC=y
+# CONFIG_SDM_CAMCC_845 is not set
+# CONFIG_SDM_DISPCC_845 is not set
+# CONFIG_SDM_GCC_660 is not set
+# CONFIG_SDM_GCC_845 is not set
+# CONFIG_SDM_GPUCC_845 is not set
+# CONFIG_SDM_LPASSCC_845 is not set
+# CONFIG_SDM_VIDEOCC_845 is not set
+# CONFIG_SDX_GCC_65 is not set
+# CONFIG_SEEMP_CORE is not set
+# CONFIG_SENSIRION_SGP30 is not set
+# CONFIG_SENSORS_DRIVETEMP is not set
+# CONFIG_SENSORS_OCC_P8_I2C is not set
+# CONFIG_SENSORS_RM3100_I2C is not set
+# CONFIG_SENSORS_RM3100_SPI is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+# CONFIG_SERIAL_8250_DMA is not set
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+CONFIG_SERIAL_MSM=y
+CONFIG_SERIAL_MSM_CONSOLE=y
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SHADOW_CALL_STACK is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+CONFIG_SKB_RECYCLER=y
+CONFIG_SKB_RECYCLER_MULTI_CPU=y
+# CONFIG_SKB_RECYCLER_PREALLOC is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_SLIMBUS_MSM_CTRL is not set
+# CONFIG_SLIMBUS_MSM_NGD is not set
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+# CONFIG_SM_CAMCC_8450 is not set
+# CONFIG_SM_GCC_8150 is not set
+# CONFIG_SM_GCC_8250 is not set
+# CONFIG_SM_GCC_8450 is not set
+# CONFIG_SM_GPUCC_6350 is not set
+# CONFIG_SM_GPUCC_8150 is not set
+# CONFIG_SM_GPUCC_8250 is not set
+# CONFIG_SM_GPUCC_8350 is not set
+# CONFIG_SM_VIDEOCC_8150 is not set
+# CONFIG_SM_VIDEOCC_8250 is not set
+CONFIG_SOUND=y
+# CONFIG_SND_SOC_APQ8016_SBC is not set
+# CONFIG_SND_SOC_SC7180 is not set
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_IPQ=y
+CONFIG_SND_SOC_IPQ9574_LPASS_PCM_RAW=y
+CONFIG_SND_SOC_IPQ_LPASS=y
+CONFIG_SND_SOC_QCOM=y
+CONFIG_SOCK_RX_QUEUE_MAPPING=y
+CONFIG_SOFTIRQ_ON_OWN_STACK=y
+CONFIG_SPARSEMEM=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+# CONFIG_SPI_MTK_QUADSPI is not set
+# CONFIG_SPI_QCOM_QSPI is not set
+CONFIG_SPI_QUP=y
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_VSC7385 is not set
+# CONFIG_SPMI is not set
+# CONFIG_SPMI_MSM_PMIC_ARB is not set
+# CONFIG_SPMI_PMIC_CLKDIV is not set
+CONFIG_SPS=y
+# CONFIG_SPS30 is not set
+# CONFIG_SPS_SUPPORT_BAMDMA is not set
+CONFIG_SPS_SUPPORT_NDP_BAM=y
+CONFIG_SRCU=y
+# CONFIG_SRD_TRACE is not set
+# CONFIG_STAGING is not set
+# CONFIG_STM_PROTO_BASIC is not set
+# CONFIG_STM_PROTO_SYS_T is not set
+# CONFIG_STM_SOURCE_FTRACE is not set
+# CONFIG_STM_SOURCE_HEARTBEAT is not set
+# CONFIG_STOPWATCH is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+CONFIG_SUSPEND=y
+# CONFIG_SWAP is not set
+CONFIG_SWCONFIG=y
+CONFIG_SWIOTLB=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_SW_SYNC is not set
+# CONFIG_SYNC is not set
+CONFIG_INET_TABLE_PERTURB_ORDER=16
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_TEST_BLACKHOLE_DEV is not set
+# CONFIG_TEST_DYNAMIC_DEBUG is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_TEST_STACKINIT is not set
+# CONFIG_TEST_STRSCPY is not set
+# CONFIG_TEST_VMALLOC is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_MAPLE_TREE is not set
+# CONFIG_NVME_MULTIPATH is not set
+# CONFIG_ARM_MHU_V2 is not set
+# CONFIG_HISI_PCIE_PMU is not set
+# CONFIG_HNS3_PMU is not set
+# CONFIG_HISI_PTT is not set
+# CONFIG_ETM4X_IMPDEF_FEATURE is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+# CONFIG_THUMB2_KERNEL is not set
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+# CONFIG_TI_ADS124S08 is not set
+# CONFIG_TI_ADS8344 is not set
+# CONFIG_TI_CPSW_PHY_SEL is not set
+# CONFIG_TI_DAC7311 is not set
+# CONFIG_TI_DAC7612 is not set
+CONFIG_TRACING_EVENTS_GPIO=y
+# CONFIG_TRUSTED_FOUNDATIONS is not set
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_XATTR=y
+CONFIG_UBIFS_FS_XZ=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_ZSTD is not set
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_UNICODE is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+# CONFIG_UNMAP_KERNEL_AT_EL0 is not set
+CONFIG_UNWINDER_ARM=y
+# CONFIG_UNWINDER_FRAME_POINTER is not set
+# CONFIG_USB_BAM is not set
+CONFIG_USB_CONFIGFS=y
+# CONFIG_USB_CONFIGFS_ACM is not set
+# CONFIG_USB_CONFIGFS_ECM is not set
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+# CONFIG_USB_CONFIGFS_EEM is not set
+# CONFIG_USB_CONFIGFS_F_DIAG is not set
+# CONFIG_USB_CONFIGFS_F_FS is not set
+# CONFIG_USB_CONFIGFS_F_HID is not set
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+# CONFIG_USB_CONFIGFS_F_MIDI is not set
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+# CONFIG_USB_CONFIGFS_F_QDSS is not set
+# CONFIG_USB_CONFIGFS_F_UAC1 is not set
+# CONFIG_USB_CONFIGFS_F_UAC1_LEGACY is not set
+# CONFIG_USB_CONFIGFS_F_UAC2 is not set
+# CONFIG_USB_CONFIGFS_MASS_STORAGE is not set
+# CONFIG_USB_CONFIGFS_NCM is not set
+# CONFIG_USB_CONFIGFS_OBEX is not set
+# CONFIG_USB_CONFIGFS_RNDIS is not set
+# CONFIG_USB_CONFIGFS_SERIAL is not set
+# CONFIG_USB_CONN_GPIO is not set
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+# CONFIG_USB_EHCI_FSL is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_USB_NET_AQC111 is not set
+# CONFIG_USB_OHCI_LITTLE_ENDIAN is not set
+# CONFIG_USB_QCA_M31_PHY is not set
+# CONFIG_USB_QCOM_8X16_PHY is not set
+# CONFIG_USB_QCOM_QMP_PHY is not set
+# CONFIG_USB_QCOM_QUSB_PHY is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USE_OF=y
+# CONFIG_U_SERIAL_CONSOLE is not set
+# CONFIG_VALIDATE_FS_PARSER is not set
+# CONFIG_VCNL4035 is not set
+CONFIG_VDSO=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_VFIO is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+# CONFIG_VMWARE_VMCI is not set
+CONFIG_WATCHDOG_CORE=y
+CONFIG_WATCHDOG_OPEN_TIMEOUT=0
+# CONFIG_WL_TI is not set
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_WWAN=y
+# CONFIG_WWAN_DEBUGFS is not set
+CONFIG_X509_CERTIFICATE_PARSER=y
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_XILINX_XADC is not set
+CONFIG_XPS=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZONE_DMA32=y
+CONFIG_ZSTD_COMMON=y
+CONFIG_ZSTD_COMPRESS=y
+CONFIG_ZSTD_DECOMPRESS=y
+CONFIG_AQUANTIA_PHY=y
+CONFIG_AT803X_PHY=y
+CONFIG_MDIO_IPQ4019=y
+CONFIG_QTI_TZ_LOG=y
+CONFIG_QTI_LICENSE_MANAGER=y
+# CONFIG_VIRT_WIFI is not set
+# CONFIG_FIPS_SIGNATURE_SELFTEST is not set
+# CONFIG_QTI_APSS_ACC is not set
+# CONFIG_DEBUG_MEM_USAGE is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_ARM64_MODULE_PLTS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_SYMBOLIC_ERRNAME is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+# CONFIG_LEDS_CLASS_MULTICOLOR is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+# CONFIG_RANDOM_TRUST_CPU is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+# CONFIG_AIO is not set
+# CONFIG_ARM64_TAGGED_ADDR_ABI is not set
+# CONFIG_BLK_DEV_THROTTLING is not set
+# CONFIG_BPF_JIT is not set
+# CONFIG_BPF_UNPRIV_DEFAULT_OFF is not set
+# CONFIG_CGROUP_BPF is not set
+# CONFIG_CGROUP_RDMA is not set
+# CONFIG_CRC8 is not set
+# CONFIG_DAX is not set
+# CONFIG_EXT4_USE_FOR_EXT2 is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_IO_URING is not set
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_RAS is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_SND_PROC_FS is not set
+# CONFIG_OPTIMIZE_INLINING is not set
diff --git a/target/linux/ipq95xx/generic/config-default b/target/linux/ipq95xx/generic/config-default
new file mode 100644
index 0000000000..a81cec0635
--- /dev/null
+++ b/target/linux/ipq95xx/generic/config-default
@@ -0,0 +1,70 @@
+# CONFIG_32BIT is not set
+CONFIG_64BIT=y
+# CONFIG_ACPI is not set
+# CONFIG_ARCH_BCM_IPROC is not set
+# CONFIG_ARCH_EXYNOS7 is not set
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+# CONFIG_ARCH_LAYERSCAPE is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+# CONFIG_ARCH_SEATTLE is not set
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+# CONFIG_ARCH_SPRD is not set
+# CONFIG_ARCH_STRATIX10 is not set
+# CONFIG_ARCH_THUNDER is not set
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+# CONFIG_ARCH_XGENE is not set
+# CONFIG_ARCH_ZYNQMP is not set
+CONFIG_ARM64=y
+# CONFIG_ARM64_16K_PAGES is not set
+CONFIG_ARM64_4K_PAGES=y
+# CONFIG_ARM64_64K_PAGES is not set
+# CONFIG_ARM64_CRYPTO is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_843419 is not set
+# CONFIG_ARM64_ERRATUM_845719 is not set
+CONFIG_ARM64_HW_AFDBM=y
+# CONFIG_ARM64_LSE_ATOMICS is not set
+CONFIG_ARM64_PAN=y
+# CONFIG_ARM64_PTDUMP is not set
+# CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET is not set
+CONFIG_ARM64_VA_BITS=39
+CONFIG_ARM64_VA_BITS_39=y
+# CONFIG_ARM64_VA_BITS_48 is not set
+# CONFIG_ARMV8_DEPRECATED is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_COMMON_CLK_VERSATILE is not set
+CONFIG_COMMON_CLK_XGENE=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_BINFMT_ELF=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_DEBUG_ALIGN_RODATA is not set
+CONFIG_FRAME_WARN=2048
+# CONFIG_GPIO_XGENE is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_I2C_CADENCE is not set
+# CONFIG_KASAN is not set
+# CONFIG_KVM is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_PCI_HISI is not set
+CONFIG_PHYS_ADDR_T_64BIT=y
+# CONFIG_PHY_XGENE is not set
+# CONFIG_POWER_RESET_XGENE is not set
+CONFIG_QCOM_SCM_64=y
+# CONFIG_RTC_DRV_EFI is not set
+CONFIG_SPARSEMEM=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_VIRTUALIZATION=y
diff --git a/target/linux/ipq95xx/generic/target.mk b/target/linux/ipq95xx/generic/target.mk
new file mode 100644
index 0000000000..9de98feff4
--- /dev/null
+++ b/target/linux/ipq95xx/generic/target.mk
@@ -0,0 +1,8 @@
+
+SUBTARGET:=generic
+BOARDNAME:=QTI IPQ95xx(64bit) based boards
+CPU_TYPE:=cortex-a73
+
+define Target/Description
+	Build images for IPQ95xx 64 bit system.
+endef
diff --git a/target/linux/ipq95xx/image/Makefile b/target/linux/ipq95xx/image/Makefile
new file mode 100644
index 0000000000..3989e31139
--- /dev/null
+++ b/target/linux/ipq95xx/image/Makefile
@@ -0,0 +1,35 @@
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/image.mk
+
+define Device/Default
+	PROFILES := Default
+	DTS_DIR := $(LINUX_DIR)/arch/$(LINUX_KARCH)/boot/dts/$(if $(CONFIG_TARGET_ipq95xx_generic),qcom)
+	KERNEL_DEPENDS = $$(wildcard $(DTS_DIR)/$$(DEVICE_DTS).dts)
+	KERNEL_LOADADDR := 0x40000000
+	DEVICE_DTS = $$(SOC)-$(lastword $(subst _, ,$(1)))
+	DEVICE_DTS_CONFIG := config-1
+	IMAGES := sysupgrade.bin
+	IMAGE/sysupgrade.bin = sysupgrade-tar | append-metadata
+	IMAGE/sysupgrade.bin/squashfs :=
+endef
+
+define Device/FitImage
+	KERNEL_SUFFIX := -fit-uImage.itb
+	KERNEL = kernel-bin | gzip | fit gzip $$(DTS_DIR)/$$(DEVICE_DTS).dtb
+	KERNEL_NAME := Image
+endef
+
+define Device/FitImageLzma
+	KERNEL_SUFFIX := -fit-uImage.itb
+	KERNEL = kernel-bin | lzma | fit lzma $$(DTS_DIR)/$$(DEVICE_DTS).dtb
+	KERNEL_NAME := Image
+endef
+
+include generic.mk
+
+define Image/Build
+	$(call Image/Build/$(1),$(1))
+	dd if=$(KDIR)/root$(2).$(1) of=$(BIN_DIR)/$(IMG_PREFIX)-$(1)-root$(3).img bs=2k conv=sync
+endef
+
+$(eval $(call BuildImage))
diff --git a/target/linux/ipq95xx/image/generic.mk b/target/linux/ipq95xx/image/generic.mk
new file mode 100644
index 0000000000..e341ea9e55
--- /dev/null
+++ b/target/linux/ipq95xx/image/generic.mk
@@ -0,0 +1,14 @@
+define Device/qcom_rdp433
+	$(call Device/FitImageLzma)
+	DEVICE_VENDOR := Qualcomm Technologies, Inc.
+	DEVICE_MODEL := RDP433
+	DEVICE_VARIANT := AP-AL02-C4
+	BOARD_NAME := ap-al02.1-c4
+	BUILD_DTS_ipq9574-rdp433 := 1
+	SOC := ipq9574
+	KERNEL_INSTALL := 1
+	KERNEL_SIZE := 6096k
+	IMAGE_SIZE := 25344k
+	IMAGE/sysupgrade.bin := append-kernel | pad-to $$$$(KERNEL_SIZE) | append-rootfs | pad-rootfs | append-metadata
+endef
+TARGET_DEVICES += qcom_rdp433
diff --git a/target/linux/ipq95xx/patches-6.1/0001-soc-qcom-smd-rpm-Add-IPQ9574-compatible.patch b/target/linux/ipq95xx/patches-6.1/0001-soc-qcom-smd-rpm-Add-IPQ9574-compatible.patch
new file mode 100644
index 0000000000..81b7f4ba7b
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0001-soc-qcom-smd-rpm-Add-IPQ9574-compatible.patch
@@ -0,0 +1,32 @@
+From d86de60f5e324034e1e917881ff0b46f2f9f00e7 Mon Sep 17 00:00:00 2001
+From: devi priya <quic_devipriy@quicinc.com>
+Date: Fri, 13 Jan 2023 20:33:05 +0530
+Subject: [PATCH 01/41] soc: qcom: smd-rpm: Add IPQ9574 compatible
+
+Adding compatible string to support RPM communication over SMD for
+IPQ9574 SoC
+
+Co-developed-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: devi priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230113150310.29709-2-quic_devipriy@quicinc.com
+---
+ drivers/soc/qcom/smd-rpm.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/soc/qcom/smd-rpm.c b/drivers/soc/qcom/smd-rpm.c
+index 413f9f4ae9cd..10765775ee17 100644
+--- a/drivers/soc/qcom/smd-rpm.c
++++ b/drivers/soc/qcom/smd-rpm.c
+@@ -233,6 +233,7 @@ static void qcom_smd_rpm_remove(struct rpmsg_device *rpdev)
+ static const struct of_device_id qcom_smd_rpm_of_match[] = {
+ 	{ .compatible = "qcom,rpm-apq8084" },
+ 	{ .compatible = "qcom,rpm-ipq6018" },
++	{ .compatible = "qcom,rpm-ipq9574" },
+ 	{ .compatible = "qcom,rpm-msm8226" },
+ 	{ .compatible = "qcom,rpm-msm8909" },
+ 	{ .compatible = "qcom,rpm-msm8916" },
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0002-clk-qcom-apss-ipq-pll-refactor-the-driver-to-accommo.patch b/target/linux/ipq95xx/patches-6.1/0002-clk-qcom-apss-ipq-pll-refactor-the-driver-to-accommo.patch
new file mode 100644
index 0000000000..20ed093577
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0002-clk-qcom-apss-ipq-pll-refactor-the-driver-to-accommo.patch
@@ -0,0 +1,127 @@
+From 19cd9f8fc024ba70659411f00fd8c4f4a3814647 Mon Sep 17 00:00:00 2001
+From: Kathiravan T <quic_kathirav@quicinc.com>
+Date: Fri, 17 Feb 2023 14:03:04 +0530
+Subject: [PATCH 02/41] clk: qcom: apss-ipq-pll: refactor the driver to
+ accommodate different PLL types
+
+APSS PLL found on the IPQ8074 and IPQ6018 are of type Huayra PLL. But,
+IPQ5332 APSS PLL is of type Stromer Plus. To accommodate both these PLLs,
+refactor the driver to take the clk_alpha_pll, alpha_pll_config via driver
+data.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230217083308.12017-2-quic_kathirav@quicinc.com
+---
+ drivers/clk/qcom/apss-ipq-pll.c | 60 ++++++++++++++++++++++-----------
+ 1 file changed, 41 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/clk/qcom/apss-ipq-pll.c b/drivers/clk/qcom/apss-ipq-pll.c
+index a5aea27eb867..4f2a147e9fb2 100644
+--- a/drivers/clk/qcom/apss-ipq-pll.c
++++ b/drivers/clk/qcom/apss-ipq-pll.c
+@@ -8,20 +8,27 @@
+ 
+ #include "clk-alpha-pll.h"
+ 
+-static const u8 ipq_pll_offsets[] = {
+-	[PLL_OFF_L_VAL] = 0x08,
+-	[PLL_OFF_ALPHA_VAL] = 0x10,
+-	[PLL_OFF_USER_CTL] = 0x18,
+-	[PLL_OFF_CONFIG_CTL] = 0x20,
+-	[PLL_OFF_CONFIG_CTL_U] = 0x24,
+-	[PLL_OFF_STATUS] = 0x28,
+-	[PLL_OFF_TEST_CTL] = 0x30,
+-	[PLL_OFF_TEST_CTL_U] = 0x34,
++/*
++ * Even though APSS PLL type is of existing one (like Huayra), its offsets
++ * are different from the one mentioned in the clk-alpha-pll.c, since the
++ * PLL is specific to APSS, so lets the define the same.
++ */
++static const u8 ipq_pll_offsets[][PLL_OFF_MAX_REGS] = {
++	[CLK_ALPHA_PLL_TYPE_HUAYRA] =  {
++		[PLL_OFF_L_VAL] = 0x08,
++		[PLL_OFF_ALPHA_VAL] = 0x10,
++		[PLL_OFF_USER_CTL] = 0x18,
++		[PLL_OFF_CONFIG_CTL] = 0x20,
++		[PLL_OFF_CONFIG_CTL_U] = 0x24,
++		[PLL_OFF_STATUS] = 0x28,
++		[PLL_OFF_TEST_CTL] = 0x30,
++		[PLL_OFF_TEST_CTL_U] = 0x34,
++	},
+ };
+ 
+-static struct clk_alpha_pll ipq_pll = {
++static struct clk_alpha_pll ipq_pll_huayra = {
+ 	.offset = 0x0,
+-	.regs = ipq_pll_offsets,
++	.regs = ipq_pll_offsets[CLK_ALPHA_PLL_TYPE_HUAYRA],
+ 	.flags = SUPPORTS_DYNAMIC_UPDATE,
+ 	.clkr = {
+ 		.enable_reg = 0x0,
+@@ -61,6 +68,21 @@ static const struct alpha_pll_config ipq8074_pll_config = {
+ 	.test_ctl_hi_val = 0x4000,
+ };
+ 
++struct apss_pll_data {
++	struct clk_alpha_pll *pll;
++	const struct alpha_pll_config *pll_config;
++};
++
++static struct apss_pll_data ipq8074_pll_data = {
++	.pll = &ipq_pll_huayra,
++	.pll_config = &ipq8074_pll_config,
++};
++
++static struct apss_pll_data ipq6018_pll_data = {
++	.pll = &ipq_pll_huayra,
++	.pll_config = &ipq6018_pll_config,
++};
++
+ static const struct regmap_config ipq_pll_regmap_config = {
+ 	.reg_bits		= 32,
+ 	.reg_stride		= 4,
+@@ -71,7 +93,7 @@ static const struct regmap_config ipq_pll_regmap_config = {
+ 
+ static int apss_ipq_pll_probe(struct platform_device *pdev)
+ {
+-	const struct alpha_pll_config *ipq_pll_config;
++	const struct apss_pll_data *data;
+ 	struct device *dev = &pdev->dev;
+ 	struct regmap *regmap;
+ 	void __iomem *base;
+@@ -85,23 +107,23 @@ static int apss_ipq_pll_probe(struct platform_device *pdev)
+ 	if (IS_ERR(regmap))
+ 		return PTR_ERR(regmap);
+ 
+-	ipq_pll_config = of_device_get_match_data(&pdev->dev);
+-	if (!ipq_pll_config)
++	data = of_device_get_match_data(&pdev->dev);
++	if (!data)
+ 		return -ENODEV;
+ 
+-	clk_alpha_pll_configure(&ipq_pll, regmap, ipq_pll_config);
++	clk_alpha_pll_configure(data->pll, regmap, data->pll_config);
+ 
+-	ret = devm_clk_register_regmap(dev, &ipq_pll.clkr);
++	ret = devm_clk_register_regmap(dev, &data->pll->clkr);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,
+-					   &ipq_pll.clkr.hw);
++					   &data->pll->clkr.hw);
+ }
+ 
+ static const struct of_device_id apss_ipq_pll_match_table[] = {
+-	{ .compatible = "qcom,ipq6018-a53pll", .data = &ipq6018_pll_config },
+-	{ .compatible = "qcom,ipq8074-a53pll", .data = &ipq8074_pll_config },
++	{ .compatible = "qcom,ipq6018-a53pll", .data = &ipq6018_pll_data },
++	{ .compatible = "qcom,ipq8074-a53pll", .data = &ipq8074_pll_data },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, apss_ipq_pll_match_table);
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0003-clk-qcom-clk-alpha-pll-Add-support-for-Stromer-PLLs.patch b/target/linux/ipq95xx/patches-6.1/0003-clk-qcom-clk-alpha-pll-Add-support-for-Stromer-PLLs.patch
new file mode 100644
index 0000000000..2e84493af1
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0003-clk-qcom-clk-alpha-pll-Add-support-for-Stromer-PLLs.patch
@@ -0,0 +1,229 @@
+From 5bd9fcb9c152a9ed0c9bb22e403d4df359faad7b Mon Sep 17 00:00:00 2001
+From: Varadarajan Narayanan <quic_varada@quicinc.com>
+Date: Tue, 7 Mar 2023 11:52:24 +0530
+Subject: [PATCH 03/41] clk: qcom: clk-alpha-pll: Add support for Stromer PLLs
+
+Add programming sequence support for managing the Stromer
+PLLs.
+
+Reviewed-by: Stephen Boyd <sboyd@kernel.org>
+Co-developed-by: Sricharan R <quic_srichara@quicinc.com>
+Signed-off-by: Sricharan R <quic_srichara@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230307062232.4889-2-quic_kathirav@quicinc.com
+---
+ drivers/clk/qcom/clk-alpha-pll.c | 128 ++++++++++++++++++++++++++++++-
+ drivers/clk/qcom/clk-alpha-pll.h |  13 +++-
+ 2 files changed, 139 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/clk/qcom/clk-alpha-pll.c b/drivers/clk/qcom/clk-alpha-pll.c
+index 1973d79c9465..8e5e7a26bcc4 100644
+--- a/drivers/clk/qcom/clk-alpha-pll.c
++++ b/drivers/clk/qcom/clk-alpha-pll.c
+@@ -1,7 +1,7 @@
+ // SPDX-License-Identifier: GPL-2.0
+ /*
+  * Copyright (c) 2015, 2018, The Linux Foundation. All rights reserved.
+- * Copyright (c) 2021, Qualcomm Innovation Center, Inc. All rights reserved.
++ * Copyright (c) 2021, 2023, Qualcomm Innovation Center, Inc. All rights reserved.
+  */
+ 
+ #include <linux/kernel.h>
+@@ -188,6 +188,18 @@ const u8 clk_alpha_pll_regs[][PLL_OFF_MAX_REGS] = {
+ 		[PLL_OFF_CONFIG_CTL] = 0x1C,
+ 		[PLL_OFF_STATUS] = 0x20,
+ 	},
++	[CLK_ALPHA_PLL_TYPE_STROMER] = {
++		[PLL_OFF_L_VAL] = 0x08,
++		[PLL_OFF_ALPHA_VAL] = 0x10,
++		[PLL_OFF_ALPHA_VAL_U] = 0x14,
++		[PLL_OFF_USER_CTL] = 0x18,
++		[PLL_OFF_USER_CTL_U] = 0x1c,
++		[PLL_OFF_CONFIG_CTL] = 0x20,
++		[PLL_OFF_CONFIG_CTL_U] = 0xff,
++		[PLL_OFF_TEST_CTL] = 0x30,
++		[PLL_OFF_TEST_CTL_U] = 0x34,
++		[PLL_OFF_STATUS] = 0x28,
++	},
+ };
+ EXPORT_SYMBOL_GPL(clk_alpha_pll_regs);
+ 
+@@ -199,6 +211,8 @@ EXPORT_SYMBOL_GPL(clk_alpha_pll_regs);
+ #define ALPHA_BITWIDTH		32U
+ #define ALPHA_SHIFT(w)		min(w, ALPHA_BITWIDTH)
+ 
++#define	ALPHA_PLL_STATUS_REG_SHIFT	8
++
+ #define PLL_HUAYRA_M_WIDTH		8
+ #define PLL_HUAYRA_M_SHIFT		8
+ #define PLL_HUAYRA_M_MASK		0xff
+@@ -2308,3 +2322,115 @@ const struct clk_ops clk_alpha_pll_rivian_evo_ops = {
+ 	.round_rate = clk_rivian_evo_pll_round_rate,
+ };
+ EXPORT_SYMBOL_GPL(clk_alpha_pll_rivian_evo_ops);
++
++void clk_stromer_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,
++			       const struct alpha_pll_config *config)
++{
++	u32 val, val_u, mask, mask_u;
++
++	regmap_write(regmap, PLL_L_VAL(pll), config->l);
++	regmap_write(regmap, PLL_ALPHA_VAL(pll), config->alpha);
++	regmap_write(regmap, PLL_CONFIG_CTL(pll), config->config_ctl_val);
++
++	if (pll_has_64bit_config(pll))
++		regmap_write(regmap, PLL_CONFIG_CTL_U(pll),
++			     config->config_ctl_hi_val);
++
++	if (pll_alpha_width(pll) > 32)
++		regmap_write(regmap, PLL_ALPHA_VAL_U(pll), config->alpha_hi);
++
++	val = config->main_output_mask;
++	val |= config->aux_output_mask;
++	val |= config->aux2_output_mask;
++	val |= config->early_output_mask;
++	val |= config->pre_div_val;
++	val |= config->post_div_val;
++	val |= config->vco_val;
++	val |= config->alpha_en_mask;
++	val |= config->alpha_mode_mask;
++
++	mask = config->main_output_mask;
++	mask |= config->aux_output_mask;
++	mask |= config->aux2_output_mask;
++	mask |= config->early_output_mask;
++	mask |= config->pre_div_mask;
++	mask |= config->post_div_mask;
++	mask |= config->vco_mask;
++	mask |= config->alpha_en_mask;
++	mask |= config->alpha_mode_mask;
++
++	regmap_update_bits(regmap, PLL_USER_CTL(pll), mask, val);
++
++	/* Stromer APSS PLL does not enable LOCK_DET by default, so enable it */
++	val_u = config->status_val << ALPHA_PLL_STATUS_REG_SHIFT;
++	val_u |= config->lock_det;
++
++	mask_u = config->status_mask;
++	mask_u |= config->lock_det;
++
++	regmap_update_bits(regmap, PLL_USER_CTL_U(pll), mask_u, val_u);
++	regmap_write(regmap, PLL_TEST_CTL(pll), config->test_ctl_val);
++	regmap_write(regmap, PLL_TEST_CTL_U(pll), config->test_ctl_hi_val);
++
++	if (pll->flags & SUPPORTS_FSM_MODE)
++		qcom_pll_set_fsm_mode(regmap, PLL_MODE(pll), 6, 0);
++}
++EXPORT_SYMBOL_GPL(clk_stromer_pll_configure);
++
++static int clk_alpha_pll_stromer_determine_rate(struct clk_hw *hw,
++						struct clk_rate_request *req)
++{
++	u32 l;
++	u64 a;
++
++	req->rate = alpha_pll_round_rate(req->rate, req->best_parent_rate,
++					 &l, &a, ALPHA_REG_BITWIDTH);
++
++	return 0;
++}
++
++static int clk_alpha_pll_stromer_set_rate(struct clk_hw *hw, unsigned long rate,
++					  unsigned long prate)
++{
++	struct clk_alpha_pll *pll = to_clk_alpha_pll(hw);
++	int ret;
++	u32 l;
++	u64 a;
++
++	rate = alpha_pll_round_rate(rate, prate, &l, &a, ALPHA_REG_BITWIDTH);
++
++	regmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);
++	regmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);
++	regmap_write(pll->clkr.regmap, PLL_ALPHA_VAL_U(pll),
++		     a >> ALPHA_BITWIDTH);
++
++	regmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),
++			   PLL_ALPHA_EN, PLL_ALPHA_EN);
++
++	if (!clk_hw_is_enabled(hw))
++		return 0;
++
++	/*
++	 * Stromer PLL supports Dynamic programming.
++	 * It allows the PLL frequency to be changed on-the-fly without first
++	 * execution of a shutdown procedure followed by a bring up procedure.
++	 */
++	regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_UPDATE,
++			   PLL_UPDATE);
++
++	ret = wait_for_pll_update(pll);
++	if (ret)
++		return ret;
++
++	return wait_for_pll_enable_lock(pll);
++}
++
++const struct clk_ops clk_alpha_pll_stromer_ops = {
++	.enable = clk_alpha_pll_enable,
++	.disable = clk_alpha_pll_disable,
++	.is_enabled = clk_alpha_pll_is_enabled,
++	.recalc_rate = clk_alpha_pll_recalc_rate,
++	.determine_rate = clk_alpha_pll_stromer_determine_rate,
++	.set_rate = clk_alpha_pll_stromer_set_rate,
++};
++EXPORT_SYMBOL_GPL(clk_alpha_pll_stromer_ops);
+diff --git a/drivers/clk/qcom/clk-alpha-pll.h b/drivers/clk/qcom/clk-alpha-pll.h
+index f9524b3fce6b..51d4043c7e4f 100644
+--- a/drivers/clk/qcom/clk-alpha-pll.h
++++ b/drivers/clk/qcom/clk-alpha-pll.h
+@@ -1,5 +1,9 @@
+ /* SPDX-License-Identifier: GPL-2.0 */
+-/* Copyright (c) 2015, 2018, The Linux Foundation. All rights reserved. */
++/*
++ * Copyright (c) 2015, 2018, 2021 The Linux Foundation. All rights reserved.
++ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
+ 
+ #ifndef __QCOM_CLK_ALPHA_PLL_H__
+ #define __QCOM_CLK_ALPHA_PLL_H__
+@@ -21,6 +25,7 @@ enum {
+ 	CLK_ALPHA_PLL_TYPE_RIVIAN_EVO,
+ 	CLK_ALPHA_PLL_TYPE_DEFAULT_EVO,
+ 	CLK_ALPHA_PLL_TYPE_BRAMMO_EVO,
++	CLK_ALPHA_PLL_TYPE_STROMER,
+ 	CLK_ALPHA_PLL_TYPE_MAX,
+ };
+ 
+@@ -128,6 +133,9 @@ struct alpha_pll_config {
+ 	u32 post_div_mask;
+ 	u32 vco_val;
+ 	u32 vco_mask;
++	u32 status_val;
++	u32 status_mask;
++	u32 lock_det;
+ };
+ 
+ extern const struct clk_ops clk_alpha_pll_ops;
+@@ -136,6 +144,7 @@ extern const struct clk_ops clk_alpha_pll_hwfsm_ops;
+ extern const struct clk_ops clk_alpha_pll_postdiv_ops;
+ extern const struct clk_ops clk_alpha_pll_huayra_ops;
+ extern const struct clk_ops clk_alpha_pll_postdiv_ro_ops;
++extern const struct clk_ops clk_alpha_pll_stromer_ops;
+ 
+ extern const struct clk_ops clk_alpha_pll_fabia_ops;
+ extern const struct clk_ops clk_alpha_pll_fixed_fabia_ops;
+@@ -182,5 +191,7 @@ void clk_lucid_evo_pll_configure(struct clk_alpha_pll *pll, struct regmap *regma
+ 				 const struct alpha_pll_config *config);
+ void clk_rivian_evo_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,
+ 				  const struct alpha_pll_config *config);
++void clk_stromer_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,
++			       const struct alpha_pll_config *config);
+ 
+ #endif
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0004-soc-qcom-socinfo-Add-IDs-for-IPQ9574-and-its-variant.patch b/target/linux/ipq95xx/patches-6.1/0004-soc-qcom-socinfo-Add-IDs-for-IPQ9574-and-its-variant.patch
new file mode 100644
index 0000000000..dbdda81419
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0004-soc-qcom-socinfo-Add-IDs-for-IPQ9574-and-its-variant.patch
@@ -0,0 +1,38 @@
+From d1429c2349b80274255a676404d15bb2e25fa4b9 Mon Sep 17 00:00:00 2001
+From: Varadarajan Narayanan <quic_varada@quicinc.com>
+Date: Tue, 14 Mar 2023 11:43:34 +0530
+Subject: [PATCH 04/41] soc: qcom: socinfo: Add IDs for IPQ9574 and its
+ variants
+
+Add SOC ID for Qualcomm IPQ9574, IPQ9570, IPQ9554, IPQ9550,
+IPQ9514 and IPQ9510
+
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Reviewed-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/1678774414-14414-3-git-send-email-quic_varada@quicinc.com
+---
+ drivers/soc/qcom/socinfo.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/drivers/soc/qcom/socinfo.c b/drivers/soc/qcom/socinfo.c
+index 510a48dbc4ac..5b507f247a64 100644
+--- a/drivers/soc/qcom/socinfo.c
++++ b/drivers/soc/qcom/socinfo.c
+@@ -280,6 +280,12 @@ static const struct soc_id soc_id[] = {
+ 	{ 487, "SC7280" },
+ 	{ 495, "SC7180P" },
+ 	{ 507, "SM6375" },
++	{ 510, "IPQ9514" },
++	{ 511, "IPQ9550" },
++	{ 512, "IPQ9554" },
++	{ 513, "IPQ9570" },
++	{ 514, "IPQ9574" },
++	{ 521, "IPQ9510" },
+ };
+ 
+ static const char *socinfo_machine(struct device *dev, unsigned int id)
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0005-arm64-dts-qcom-Add-ipq9574-SoC-and-AL02-board-suppor.patch b/target/linux/ipq95xx/patches-6.1/0005-arm64-dts-qcom-Add-ipq9574-SoC-and-AL02-board-suppor.patch
new file mode 100644
index 0000000000..43941c1386
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0005-arm64-dts-qcom-Add-ipq9574-SoC-and-AL02-board-suppor.patch
@@ -0,0 +1,404 @@
+From 036302b2ff40f3922ce839b44c4c731cb52d8766 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 16 Mar 2023 12:59:39 +0530
+Subject: [PATCH 05/41] arm64: dts: qcom: Add ipq9574 SoC and AL02 board
+ support
+
+Add initial device tree support for Qualcomm IPQ9574 SoC and AL02 board
+
+Co-developed-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Co-developed-by: Poovendhan Selvaraj <quic_poovendh@quicinc.com>
+Signed-off-by: Poovendhan Selvaraj <quic_poovendh@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230316072940.29137-6-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/Makefile            |   1 +
+ arch/arm64/boot/dts/qcom/ipq9574-al02-c7.dts |  84 ++++++
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi        | 270 +++++++++++++++++++
+ 3 files changed, 355 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/qcom/ipq9574-al02-c7.dts
+ create mode 100644 arch/arm64/boot/dts/qcom/ipq9574.dtsi
+
+diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
+index d7669a7cee9f..8e04f0f663da 100644
+--- a/arch/arm64/boot/dts/qcom/Makefile
++++ b/arch/arm64/boot/dts/qcom/Makefile
+@@ -7,6 +7,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= ipq6018-cp01-c1.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk01.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c1.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c2.dtb
++dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-al02-c7.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-idol347.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z00l.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-g7.dtb
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-al02-c7.dts b/arch/arm64/boot/dts/qcom/ipq9574-al02-c7.dts
+new file mode 100644
+index 000000000000..2c8430197ec0
+--- /dev/null
++++ b/arch/arm64/boot/dts/qcom/ipq9574-al02-c7.dts
+@@ -0,0 +1,84 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
++/*
++ * IPQ9574 AL02-C7 board device tree source
++ *
++ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
++ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++/dts-v1/;
++
++#include "ipq9574.dtsi"
++
++/ {
++	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C7";
++	compatible = "qcom,ipq9574-ap-al02-c7", "qcom,ipq9574";
++
++	aliases {
++		serial0 = &blsp1_uart2;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++};
++
++&blsp1_uart2 {
++	pinctrl-0 = <&uart2_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++};
++
++&sdhc_1 {
++	pinctrl-0 = <&sdc_default_state>;
++	pinctrl-names = "default";
++	mmc-ddr-1_8v;
++	mmc-hs200-1_8v;
++	mmc-hs400-1_8v;
++	mmc-hs400-enhanced-strobe;
++	max-frequency = <384000000>;
++	bus-width = <8>;
++	status = "okay";
++};
++
++&sleep_clk {
++	clock-frequency = <32000>;
++};
++
++&tlmm {
++	sdc_default_state: sdc-default-state {
++		clk-pins {
++			pins = "gpio5";
++			function = "sdc_clk";
++			drive-strength = <8>;
++			bias-disable;
++		};
++
++		cmd-pins {
++			pins = "gpio4";
++			function = "sdc_cmd";
++			drive-strength = <8>;
++			bias-pull-up;
++		};
++
++		data-pins {
++			pins = "gpio0", "gpio1", "gpio2",
++			       "gpio3", "gpio6", "gpio7",
++			       "gpio8", "gpio9";
++			function = "sdc_data";
++			drive-strength = <8>;
++			bias-pull-up;
++		};
++
++		rclk-pins {
++			pins = "gpio10";
++			function = "sdc_rclk";
++			drive-strength = <8>;
++			bias-pull-down;
++		};
++	};
++};
++
++&xo_board_clk {
++	clock-frequency = <24000000>;
++};
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+new file mode 100644
+index 000000000000..3bb7435f5e7f
+--- /dev/null
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -0,0 +1,270 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
++/*
++ * IPQ9574 SoC device tree source
++ *
++ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
++ * Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++#include <dt-bindings/interrupt-controller/arm-gic.h>
++#include <dt-bindings/clock/qcom,ipq9574-gcc.h>
++#include <dt-bindings/reset/qcom,ipq9574-gcc.h>
++
++/ {
++	interrupt-parent = <&intc>;
++	#address-cells = <2>;
++	#size-cells = <2>;
++
++	clocks {
++		bias_pll_ubi_nc_clk: bias-pll-ubi-nc-clk {
++			compatible = "fixed-clock";
++			clock-frequency = <353000000>;
++			#clock-cells = <0>;
++		};
++
++		sleep_clk: sleep-clk {
++			compatible = "fixed-clock";
++			#clock-cells = <0>;
++		};
++
++		xo_board_clk: xo-board-clk {
++			compatible = "fixed-clock";
++			#clock-cells = <0>;
++		};
++	};
++
++	cpus {
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		CPU0: cpu@0 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a73";
++			reg = <0x0>;
++			enable-method = "psci";
++			next-level-cache = <&L2_0>;
++		};
++
++		CPU1: cpu@1 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a73";
++			reg = <0x1>;
++			enable-method = "psci";
++			next-level-cache = <&L2_0>;
++		};
++
++		CPU2: cpu@2 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a73";
++			reg = <0x2>;
++			enable-method = "psci";
++			next-level-cache = <&L2_0>;
++		};
++
++		CPU3: cpu@3 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a73";
++			reg = <0x3>;
++			enable-method = "psci";
++			next-level-cache = <&L2_0>;
++		};
++
++		L2_0: l2-cache {
++			compatible = "cache";
++			cache-level = <2>;
++		};
++	};
++
++	memory@40000000 {
++		device_type = "memory";
++		/* We expect the bootloader to fill in the size */
++		reg = <0x0 0x40000000 0x0 0x0>;
++	};
++
++	pmu {
++		compatible = "arm,cortex-a73-pmu";
++		interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
++	};
++
++	psci {
++		compatible = "arm,psci-1.0";
++		method = "smc";
++	};
++
++	reserved-memory {
++		#address-cells = <2>;
++		#size-cells = <2>;
++		ranges;
++
++		tz_region: tz@4a600000 {
++			reg = <0x0 0x4a600000 0x0 0x400000>;
++			no-map;
++		};
++	};
++
++	soc: soc@0 {
++		compatible = "simple-bus";
++		#address-cells = <1>;
++		#size-cells = <1>;
++		ranges = <0 0 0 0xffffffff>;
++
++		tlmm: pinctrl@1000000 {
++			compatible = "qcom,ipq9574-tlmm";
++			reg = <0x01000000 0x300000>;
++			interrupts = <GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>;
++			gpio-controller;
++			#gpio-cells = <2>;
++			gpio-ranges = <&tlmm 0 0 65>;
++			interrupt-controller;
++			#interrupt-cells = <2>;
++
++			uart2_pins: uart2-state {
++				pins = "gpio34", "gpio35";
++				function = "blsp2_uart";
++				drive-strength = <8>;
++				bias-disable;
++			};
++		};
++
++		gcc: clock-controller@1800000 {
++			compatible = "qcom,ipq9574-gcc";
++			reg = <0x01800000 0x80000>;
++			clocks = <&xo_board_clk>,
++				 <&sleep_clk>,
++				 <&bias_pll_ubi_nc_clk>,
++				 <0>,
++				 <0>,
++				 <0>,
++				 <0>,
++				 <0>;
++			#clock-cells = <1>;
++			#reset-cells = <1>;
++			#power-domain-cells = <1>;
++		};
++
++		sdhc_1: mmc@7804000 {
++			compatible = "qcom,ipq9574-sdhci", "qcom,sdhci-msm-v5";
++			reg = <0x07804000 0x1000>, <0x07805000 0x1000>;
++			reg-names = "hc", "cqhci";
++
++			interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "hc_irq", "pwr_irq";
++
++			clocks = <&gcc GCC_SDCC1_AHB_CLK>,
++				 <&gcc GCC_SDCC1_APPS_CLK>,
++				 <&xo_board_clk>;
++			clock-names = "iface", "core", "xo";
++			non-removable;
++			status = "disabled";
++		};
++
++		blsp1_uart2: serial@78b1000 {
++			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
++			reg = <0x078b1000 0x200>;
++			interrupts = <GIC_SPI 306 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_UART3_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			status = "disabled";
++		};
++
++		intc: interrupt-controller@b000000 {
++			compatible = "qcom,msm-qgic2";
++			reg = <0x0b000000 0x1000>,  /* GICD */
++			      <0x0b002000 0x1000>,  /* GICC */
++			      <0x0b001000 0x1000>,  /* GICH */
++			      <0x0b004000 0x1000>;  /* GICV */
++			#address-cells = <1>;
++			#size-cells = <1>;
++			interrupt-controller;
++			#interrupt-cells = <3>;
++			interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
++			ranges = <0 0x0b00c000 0x3000>;
++
++			v2m0: v2m@0 {
++				compatible = "arm,gic-v2m-frame";
++				reg = <0x00000000 0xffd>;
++				msi-controller;
++			};
++
++			v2m1: v2m@1000 {
++				compatible = "arm,gic-v2m-frame";
++				reg = <0x00001000 0xffd>;
++				msi-controller;
++			};
++
++			v2m2: v2m@2000 {
++				compatible = "arm,gic-v2m-frame";
++				reg = <0x00002000 0xffd>;
++				msi-controller;
++			};
++		};
++
++		timer@b120000 {
++			compatible = "arm,armv7-timer-mem";
++			reg = <0x0b120000 0x1000>;
++			#address-cells = <1>;
++			#size-cells = <1>;
++			ranges;
++
++			frame@b120000 {
++				reg = <0x0b121000 0x1000>,
++				      <0x0b122000 0x1000>;
++				frame-number = <0>;
++				interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
++			};
++
++			frame@b123000 {
++				reg = <0x0b123000 0x1000>;
++				frame-number = <1>;
++				interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
++				status = "disabled";
++			};
++
++			frame@b124000 {
++				reg = <0x0b124000 0x1000>;
++				frame-number = <2>;
++				interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
++				status = "disabled";
++			};
++
++			frame@b125000 {
++				reg = <0x0b125000 0x1000>;
++				frame-number = <3>;
++				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
++				status = "disabled";
++			};
++
++			frame@b126000 {
++				reg = <0x0b126000 0x1000>;
++				frame-number = <4>;
++				interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
++				status = "disabled";
++			};
++
++			frame@b127000 {
++				reg = <0x0b127000 0x1000>;
++				frame-number = <5>;
++				interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
++				status = "disabled";
++			};
++
++			frame@b128000 {
++				reg = <0x0b128000 0x1000>;
++				frame-number = <6>;
++				interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
++				status = "disabled";
++			};
++		};
++	};
++
++	timer {
++		compatible = "arm,armv8-timer";
++		interrupts = <GIC_PPI 2 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
++			     <GIC_PPI 3 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
++			     <GIC_PPI 4 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
++			     <GIC_PPI 1 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
++	};
++};
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0006-arm64-defconfig-Enable-IPQ9574-SoC-base-configs.patch b/target/linux/ipq95xx/patches-6.1/0006-arm64-defconfig-Enable-IPQ9574-SoC-base-configs.patch
new file mode 100644
index 0000000000..39a373a915
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0006-arm64-defconfig-Enable-IPQ9574-SoC-base-configs.patch
@@ -0,0 +1,38 @@
+From 10899f01cc0a72a2a06b2baa2261c5b898e4a26d Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 16 Mar 2023 12:59:40 +0530
+Subject: [PATCH 06/41] arm64: defconfig: Enable IPQ9574 SoC base configs
+
+Enables clk & pinctrl related configs for Qualcomm IPQ9574 SoC
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230316072940.29137-7-quic_devipriy@quicinc.com
+---
+ arch/arm64/configs/defconfig | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
+index 623e9f308f38..90dd3cf7bcad 100644
+--- a/arch/arm64/configs/defconfig
++++ b/arch/arm64/configs/defconfig
+@@ -537,6 +537,7 @@ CONFIG_PINCTRL_IMX93=y
+ CONFIG_PINCTRL_MSM=y
+ CONFIG_PINCTRL_IPQ8074=y
+ CONFIG_PINCTRL_IPQ6018=y
++CONFIG_PINCTRL_IPQ9574=y
+ CONFIG_PINCTRL_MSM8916=y
+ CONFIG_PINCTRL_MSM8994=y
+ CONFIG_PINCTRL_MSM8996=y
+@@ -1068,6 +1069,7 @@ CONFIG_QCOM_CLK_SMD_RPM=y
+ CONFIG_QCOM_CLK_RPMH=y
+ CONFIG_IPQ_GCC_6018=y
+ CONFIG_IPQ_GCC_8074=y
++CONFIG_IPQ_GCC_9574=y
+ CONFIG_MSM_GCC_8916=y
+ CONFIG_MSM_GCC_8994=y
+ CONFIG_MSM_MMCC_8996=y
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0007-clk-qcom-Add-Global-Clock-Controller-driver-for-IPQ9.patch b/target/linux/ipq95xx/patches-6.1/0007-clk-qcom-Add-Global-Clock-Controller-driver-for-IPQ9.patch
new file mode 100644
index 0000000000..a5d30558c2
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0007-clk-qcom-Add-Global-Clock-Controller-driver-for-IPQ9.patch
@@ -0,0 +1,4308 @@
+From 443758ff3c5ab0445bc802cb4d4a318691de2917 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 16 Mar 2023 12:59:36 +0530
+Subject: [PATCH 07/41] clk: qcom: Add Global Clock Controller driver for
+ IPQ9574
+
+Add Global Clock Controller (GCC) driver for ipq9574 based devices
+
+Co-developed-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230316072940.29137-3-quic_devipriy@quicinc.com
+---
+ drivers/clk/qcom/Kconfig       |    8 +
+ drivers/clk/qcom/Makefile      |    1 +
+ drivers/clk/qcom/gcc-ipq9574.c | 4248 ++++++++++++++++++++++++++++++++
+ 3 files changed, 4257 insertions(+)
+ create mode 100644 drivers/clk/qcom/gcc-ipq9574.c
+
+diff --git a/drivers/clk/qcom/Kconfig b/drivers/clk/qcom/Kconfig
+index cbf55949c649..94340ee631c3 100644
+--- a/drivers/clk/qcom/Kconfig
++++ b/drivers/clk/qcom/Kconfig
+@@ -174,6 +174,14 @@ config IPQ_GCC_8074
+ 	  i2c, USB, SD/eMMC, etc. Select this for the root clock
+ 	  of ipq8074.
+ 
++config IPQ_GCC_9574
++	tristate "IPQ9574 Global Clock Controller"
++	help
++	  Support for global clock controller on ipq9574 devices.
++	  Say Y if you want to use peripheral devices such as UART, SPI,
++	  i2c, USB, SD/eMMC, etc. Select this for the root clock
++	  of ipq9574.
++
+ config MSM_GCC_8660
+ 	tristate "MSM8660 Global Clock Controller"
+ 	help
+diff --git a/drivers/clk/qcom/Makefile b/drivers/clk/qcom/Makefile
+index e6cecf9e0436..1a4c4d55cb17 100644
+--- a/drivers/clk/qcom/Makefile
++++ b/drivers/clk/qcom/Makefile
+@@ -27,6 +27,7 @@ obj-$(CONFIG_IPQ_GCC_4019) += gcc-ipq4019.o
+ obj-$(CONFIG_IPQ_GCC_6018) += gcc-ipq6018.o
+ obj-$(CONFIG_IPQ_GCC_806X) += gcc-ipq806x.o
+ obj-$(CONFIG_IPQ_GCC_8074) += gcc-ipq8074.o
++obj-$(CONFIG_IPQ_GCC_9574) += gcc-ipq9574.o
+ obj-$(CONFIG_IPQ_LCC_806X) += lcc-ipq806x.o
+ obj-$(CONFIG_MDM_GCC_9607) += gcc-mdm9607.o
+ obj-$(CONFIG_MDM_GCC_9615) += gcc-mdm9615.o
+diff --git a/drivers/clk/qcom/gcc-ipq9574.c b/drivers/clk/qcom/gcc-ipq9574.c
+new file mode 100644
+index 000000000000..b2a2d618a5ec
+--- /dev/null
++++ b/drivers/clk/qcom/gcc-ipq9574.c
+@@ -0,0 +1,4248 @@
++// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++/*
++ * Copyright (c) 2023 The Linux Foundation. All rights reserved.
++ */
++
++#include <linux/kernel.h>
++#include <linux/err.h>
++#include <linux/platform_device.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/regmap.h>
++
++#include <linux/reset-controller.h>
++#include <dt-bindings/clock/qcom,ipq9574-gcc.h>
++#include <dt-bindings/reset/qcom,ipq9574-gcc.h>
++
++#include "clk-rcg.h"
++#include "clk-branch.h"
++#include "clk-alpha-pll.h"
++#include "clk-regmap-divider.h"
++#include "clk-regmap-mux.h"
++#include "clk-regmap-phy-mux.h"
++#include "reset.h"
++
++/* Need to match the order of clocks in DT binding */
++enum {
++	DT_XO,
++	DT_SLEEP_CLK,
++	DT_BIAS_PLL_UBI_NC_CLK,
++	DT_PCIE30_PHY0_PIPE_CLK,
++	DT_PCIE30_PHY1_PIPE_CLK,
++	DT_PCIE30_PHY2_PIPE_CLK,
++	DT_PCIE30_PHY3_PIPE_CLK,
++	DT_USB3PHY_0_CC_PIPE_CLK,
++};
++
++enum {
++	P_XO,
++	P_PCIE30_PHY0_PIPE,
++	P_PCIE30_PHY1_PIPE,
++	P_PCIE30_PHY2_PIPE,
++	P_PCIE30_PHY3_PIPE,
++	P_USB3PHY_0_PIPE,
++	P_GPLL0,
++	P_GPLL0_DIV2,
++	P_GPLL0_OUT_AUX,
++	P_GPLL2,
++	P_GPLL4,
++	P_PI_SLEEP,
++	P_BIAS_PLL_UBI_NC_CLK,
++};
++
++static const struct parent_map gcc_xo_map[] = {
++	{ P_XO, 0 },
++};
++
++static const struct clk_parent_data gcc_xo_data[] = {
++	{ .index = DT_XO },
++};
++
++static const struct clk_parent_data gcc_sleep_clk_data[] = {
++	{ .index = DT_SLEEP_CLK },
++};
++
++static struct clk_alpha_pll gpll0_main = {
++	.offset = 0x20000,
++	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
++	.clkr = {
++		.enable_reg = 0x0b000,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gpll0_main",
++			.parent_data = gcc_xo_data,
++			.num_parents = ARRAY_SIZE(gcc_xo_data),
++			.ops = &clk_alpha_pll_ops,
++		},
++	},
++};
++
++static struct clk_fixed_factor gpll0_out_main_div2 = {
++	.mult = 1,
++	.div = 2,
++	.hw.init = &(struct clk_init_data) {
++		.name = "gpll0_out_main_div2",
++		.parent_hws = (const struct clk_hw *[]) {
++			&gpll0_main.clkr.hw
++		},
++		.num_parents = 1,
++		.flags = CLK_SET_RATE_PARENT,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++static struct clk_alpha_pll_postdiv gpll0 = {
++	.offset = 0x20000,
++	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
++	.width = 4,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "gpll0",
++		.parent_hws = (const struct clk_hw *[]) {
++			&gpll0_main.clkr.hw
++		},
++		.num_parents = 1,
++		.flags = CLK_SET_RATE_PARENT,
++		.ops = &clk_alpha_pll_postdiv_ro_ops,
++	},
++};
++
++static struct clk_alpha_pll gpll4_main = {
++	.offset = 0x22000,
++	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
++	.clkr = {
++		.enable_reg = 0x0b000,
++		.enable_mask = BIT(2),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gpll4_main",
++			.parent_data = gcc_xo_data,
++			.num_parents = ARRAY_SIZE(gcc_xo_data),
++			.ops = &clk_alpha_pll_ops,
++		},
++	},
++};
++
++static struct clk_alpha_pll_postdiv gpll4 = {
++	.offset = 0x22000,
++	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
++	.width = 4,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "gpll4",
++		.parent_hws = (const struct clk_hw *[]) {
++			&gpll4_main.clkr.hw
++		},
++		.num_parents = 1,
++		.flags = CLK_SET_RATE_PARENT,
++		.ops = &clk_alpha_pll_postdiv_ro_ops,
++	},
++};
++
++static struct clk_alpha_pll gpll2_main = {
++	.offset = 0x21000,
++	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
++	.clkr = {
++		.enable_reg = 0x0b000,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gpll2_main",
++			.parent_data = gcc_xo_data,
++			.num_parents = ARRAY_SIZE(gcc_xo_data),
++			.ops = &clk_alpha_pll_ops,
++		},
++	},
++};
++
++static struct clk_alpha_pll_postdiv gpll2 = {
++	.offset = 0x21000,
++	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
++	.width = 4,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "gpll2",
++		.parent_hws = (const struct clk_hw *[]) {
++			&gpll2_main.clkr.hw
++		},
++		.num_parents = 1,
++		.flags = CLK_SET_RATE_PARENT,
++		.ops = &clk_alpha_pll_postdiv_ro_ops,
++	},
++};
++
++static struct clk_branch gcc_sleep_clk_src = {
++	.halt_reg = 0x3400c,
++	.clkr = {
++		.enable_reg = 0x3400c,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_sleep_clk_src",
++			.parent_data = gcc_sleep_clk_data,
++			.num_parents = ARRAY_SIZE(gcc_sleep_clk_data),
++			.flags = CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll0_out_main_div2[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll0_out_main_div2.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll0_out_main_div2_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL0_DIV2, 4 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll4[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll4.clkr.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll4_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL4, 2 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll0_div2_gpll0[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll0_out_main_div2.hw },
++	{ .hw = &gpll0.clkr.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll0_div2_gpll0_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL0_DIV2, 4 },
++	{ P_GPLL0, 5 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll0_sleep_clk[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll0_out_main_div2.hw },
++	{ .index = DT_SLEEP_CLK },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll0_sleep_clk_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL0_DIV2, 4 },
++	{ P_PI_SLEEP, 6 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_core_pi_sleep_clk[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .index = DT_SLEEP_CLK },
++};
++
++static const struct parent_map gcc_xo_gpll0_core_pi_sleep_clk_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 2 },
++	{ P_PI_SLEEP, 6 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll4.clkr.hw },
++	{ .index = DT_BIAS_PLL_UBI_NC_CLK },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL4, 2 },
++	{ P_BIAS_PLL_UBI_NC_CLK, 3 },
++};
++
++static const struct clk_parent_data
++			gcc_xo_gpll0_gpll0_aux_core_pi_sleep_clk[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll0.clkr.hw },
++	{ .index = DT_SLEEP_CLK },
++};
++
++static const struct parent_map
++			gcc_xo_gpll0_gpll0_aux_core_pi_sleep_clk_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL0_OUT_AUX, 2 },
++	{ P_PI_SLEEP, 6 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_out_main_div2_gpll0[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll0_out_main_div2.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_out_main_div2_gpll0_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL0_DIV2, 4 },
++};
++
++static const struct clk_parent_data
++			gcc_xo_gpll4_gpll0_gpll0_out_main_div2[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll4.clkr.hw },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll0_out_main_div2.hw },
++};
++
++static const struct parent_map gcc_xo_gpll4_gpll0_gpll0_out_main_div2_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL4, 1 },
++	{ P_GPLL0, 3 },
++	{ P_GPLL0_DIV2, 4 },
++};
++
++static const struct clk_parent_data gcc_usb3phy_0_cc_pipe_clk_xo[] = {
++	{ .index = DT_USB3PHY_0_CC_PIPE_CLK },
++	{ .index = DT_XO },
++};
++
++static const struct parent_map gcc_usb3phy_0_cc_pipe_clk_xo_map[] = {
++	{ P_USB3PHY_0_PIPE, 0 },
++	{ P_XO, 2 },
++};
++
++static const struct clk_parent_data
++			gcc_xo_gpll0_gpll2_gpll0_out_main_div2[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll2.clkr.hw },
++	{ .hw = &gpll0_out_main_div2.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll2_gpll0_out_main_div2_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL2, 2 },
++	{ P_GPLL0_DIV2, 4 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll4_gpll0_div2[] = {
++	{ .index = DT_XO},
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll4.clkr.hw },
++	{ .hw = &gpll0_out_main_div2.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll4_gpll0_div2_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL4, 2 },
++	{ P_GPLL0_DIV2, 4 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll4_gpll0_gpll0_div2[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll4.clkr.hw },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll0_out_main_div2.hw },
++};
++
++static const struct parent_map gcc_xo_gpll4_gpll0_gpll0_div2_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL4, 1 },
++	{ P_GPLL0, 2 },
++	{ P_GPLL0_DIV2, 4 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll2[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll2.clkr.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll2_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL2, 2 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll2_gpll4_pi_sleep[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll2.clkr.hw },
++	{ .hw = &gpll4.clkr.hw },
++	{ .index = DT_SLEEP_CLK },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll2_gpll4_pi_sleep_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL2, 2 },
++	{ P_GPLL4, 3 },
++	{ P_PI_SLEEP, 6 },
++};
++
++static const struct clk_parent_data gcc_xo_gpll0_gpll0_aux_gpll2[] = {
++	{ .index = DT_XO },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll0.clkr.hw },
++	{ .hw = &gpll2.clkr.hw },
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll0_aux_gpll2_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL0_OUT_AUX, 2 },
++	{ P_GPLL2, 3 },
++};
++
++static const struct freq_tbl ftbl_apss_ahb_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(50000000, P_GPLL0, 16, 0, 0),
++	F(100000000, P_GPLL0, 8, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 apss_ahb_clk_src = {
++	.cmd_rcgr = 0x2400c,
++	.freq_tbl = ftbl_apss_ahb_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "apss_ahb_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static const struct freq_tbl ftbl_apss_axi_clk_src[] = {
++	F(533000000, P_GPLL0, 1.5, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 apss_axi_clk_src = {
++	.cmd_rcgr = 0x24004,
++	.freq_tbl = ftbl_apss_axi_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_div2_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "apss_axi_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_div2_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_div2_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static const struct freq_tbl ftbl_blsp1_qup_i2c_apps_clk_src[] = {
++	F(9600000, P_XO, 2.5, 0, 0),
++	F(24000000, P_XO, 1, 0, 0),
++	F(50000000, P_GPLL0, 16, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 blsp1_qup1_i2c_apps_clk_src = {
++	.cmd_rcgr = 0x02018,
++	.freq_tbl = ftbl_blsp1_qup_i2c_apps_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup1_i2c_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static const struct freq_tbl ftbl_blsp1_qup_spi_apps_clk_src[] = {
++	F(960000, P_XO, 10, 2, 5),
++	F(4800000, P_XO, 5, 0, 0),
++	F(9600000, P_XO, 2, 4, 5),
++	F(16000000, P_GPLL0, 10, 1, 5),
++	F(24000000, P_XO, 1, 0, 0),
++	F(25000000, P_GPLL0, 16, 1, 2),
++	F(50000000, P_GPLL0, 16, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 blsp1_qup1_spi_apps_clk_src = {
++	.cmd_rcgr = 0x02004,
++	.freq_tbl = ftbl_blsp1_qup_spi_apps_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup1_spi_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup2_i2c_apps_clk_src = {
++	.cmd_rcgr = 0x03018,
++	.freq_tbl = ftbl_blsp1_qup_i2c_apps_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup2_i2c_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup2_spi_apps_clk_src = {
++	.cmd_rcgr = 0x03004,
++	.freq_tbl = ftbl_blsp1_qup_spi_apps_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup2_spi_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup3_i2c_apps_clk_src = {
++	.cmd_rcgr = 0x04018,
++	.freq_tbl = ftbl_blsp1_qup_i2c_apps_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup3_i2c_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup3_spi_apps_clk_src = {
++	.cmd_rcgr = 0x04004,
++	.freq_tbl = ftbl_blsp1_qup_spi_apps_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup3_spi_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup4_i2c_apps_clk_src = {
++	.cmd_rcgr = 0x05018,
++	.freq_tbl = ftbl_blsp1_qup_i2c_apps_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup4_i2c_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup4_spi_apps_clk_src = {
++	.cmd_rcgr = 0x05004,
++	.freq_tbl = ftbl_blsp1_qup_spi_apps_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup4_spi_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup5_i2c_apps_clk_src = {
++	.cmd_rcgr = 0x06018,
++	.freq_tbl = ftbl_blsp1_qup_i2c_apps_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup5_i2c_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup5_spi_apps_clk_src = {
++	.cmd_rcgr = 0x06004,
++	.freq_tbl = ftbl_blsp1_qup_spi_apps_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup5_spi_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup6_i2c_apps_clk_src = {
++	.cmd_rcgr = 0x07018,
++	.freq_tbl = ftbl_blsp1_qup_i2c_apps_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup6_i2c_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_qup6_spi_apps_clk_src = {
++	.cmd_rcgr = 0x07004,
++	.freq_tbl = ftbl_blsp1_qup_spi_apps_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_qup6_spi_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static const struct freq_tbl ftbl_blsp1_uart_apps_clk_src[] = {
++	F(3686400, P_GPLL0_DIV2, 1, 144, 15625),
++	F(7372800, P_GPLL0_DIV2, 1, 288, 15625),
++	F(14745600, P_GPLL0_DIV2, 1, 576, 15625),
++	F(24000000, P_XO, 1, 0, 0),
++	F(25000000, P_GPLL0, 16, 1, 2),
++	F(32000000, P_GPLL0, 1, 1, 25),
++	F(40000000, P_GPLL0, 1, 1, 20),
++	F(46400000, P_GPLL0, 1, 29, 500),
++	F(48000000, P_GPLL0, 1, 3, 50),
++	F(51200000, P_GPLL0, 1, 8, 125),
++	F(56000000, P_GPLL0, 1, 7, 100),
++	F(58982400, P_GPLL0, 1, 1152, 15625),
++	F(60000000, P_GPLL0, 1, 3, 40),
++	F(64000000, P_GPLL0, 12.5, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 blsp1_uart1_apps_clk_src = {
++	.cmd_rcgr = 0x0202c,
++	.freq_tbl = ftbl_blsp1_uart_apps_clk_src,
++	.mnd_width = 16,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_uart1_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_uart2_apps_clk_src = {
++	.cmd_rcgr = 0x0302c,
++	.freq_tbl = ftbl_blsp1_uart_apps_clk_src,
++	.mnd_width = 16,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_uart2_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_uart3_apps_clk_src = {
++	.cmd_rcgr = 0x0402c,
++	.freq_tbl = ftbl_blsp1_uart_apps_clk_src,
++	.mnd_width = 16,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_uart3_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_uart4_apps_clk_src = {
++	.cmd_rcgr = 0x0502c,
++	.freq_tbl = ftbl_blsp1_uart_apps_clk_src,
++	.mnd_width = 16,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_uart4_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_uart5_apps_clk_src = {
++	.cmd_rcgr = 0x0602c,
++	.freq_tbl = ftbl_blsp1_uart_apps_clk_src,
++	.mnd_width = 16,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_uart5_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 blsp1_uart6_apps_clk_src = {
++	.cmd_rcgr = 0x0702c,
++	.freq_tbl = ftbl_blsp1_uart_apps_clk_src,
++	.mnd_width = 16,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "blsp1_uart6_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_apss_ahb_clk = {
++	.halt_reg = 0x24018,
++	.halt_check = BRANCH_HALT_VOTED,
++	.clkr = {
++		.enable_reg = 0x0b004,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_apss_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&apss_ahb_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_apss_axi_clk = {
++	.halt_reg = 0x2401c,
++	.halt_check = BRANCH_HALT_VOTED,
++	.clkr = {
++		.enable_reg = 0x0b004,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_apss_axi_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&apss_axi_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup1_i2c_apps_clk = {
++	.halt_reg = 0x2024,
++	.clkr = {
++		.enable_reg = 0x2024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup1_i2c_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup1_i2c_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup1_spi_apps_clk = {
++	.halt_reg = 0x02020,
++	.clkr = {
++		.enable_reg = 0x02020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup1_spi_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup1_spi_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup2_i2c_apps_clk = {
++	.halt_reg = 0x03024,
++	.clkr = {
++		.enable_reg = 0x03024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup2_i2c_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup2_i2c_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup2_spi_apps_clk = {
++	.halt_reg = 0x03020,
++	.clkr = {
++		.enable_reg = 0x03020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup2_spi_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup2_spi_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup3_i2c_apps_clk = {
++	.halt_reg = 0x04024,
++	.clkr = {
++		.enable_reg = 0x04024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup3_i2c_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup3_i2c_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup3_spi_apps_clk = {
++	.halt_reg = 0x04020,
++	.clkr = {
++		.enable_reg = 0x04020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup3_spi_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup3_spi_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup4_i2c_apps_clk = {
++	.halt_reg = 0x05024,
++	.clkr = {
++		.enable_reg = 0x05024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup4_i2c_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup4_i2c_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup4_spi_apps_clk = {
++	.halt_reg = 0x05020,
++	.clkr = {
++		.enable_reg = 0x05020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup4_spi_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup4_spi_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup5_i2c_apps_clk = {
++	.halt_reg = 0x06024,
++	.clkr = {
++		.enable_reg = 0x06024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup5_i2c_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup5_i2c_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup5_spi_apps_clk = {
++	.halt_reg = 0x06020,
++	.clkr = {
++		.enable_reg = 0x06020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup5_spi_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup5_spi_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup6_i2c_apps_clk = {
++	.halt_reg = 0x07024,
++	.clkr = {
++		.enable_reg = 0x07024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup6_i2c_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup6_i2c_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_qup6_spi_apps_clk = {
++	.halt_reg = 0x07020,
++	.clkr = {
++		.enable_reg = 0x07020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_qup6_spi_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_qup6_spi_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_uart1_apps_clk = {
++	.halt_reg = 0x02040,
++	.clkr = {
++		.enable_reg = 0x02040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_uart1_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_uart1_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_uart2_apps_clk = {
++	.halt_reg = 0x03040,
++	.clkr = {
++		.enable_reg = 0x03040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_uart2_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_uart2_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_uart3_apps_clk = {
++	.halt_reg = 0x04054,
++	.clkr = {
++		.enable_reg = 0x04054,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_uart3_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_uart3_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_uart4_apps_clk = {
++	.halt_reg = 0x05040,
++	.clkr = {
++		.enable_reg = 0x05040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_uart4_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_uart4_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_uart5_apps_clk = {
++	.halt_reg = 0x06040,
++	.clkr = {
++		.enable_reg = 0x06040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_uart5_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_uart5_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_uart6_apps_clk = {
++	.halt_reg = 0x07040,
++	.clkr = {
++		.enable_reg = 0x07040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_uart6_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&blsp1_uart6_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_pcie0_axi_m_clk_src[] = {
++	F(240000000, P_GPLL4, 5, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 pcie0_axi_m_clk_src = {
++	.cmd_rcgr = 0x28018,
++	.freq_tbl = ftbl_pcie0_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie0_axi_m_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie0_axi_m_clk = {
++	.halt_reg = 0x28038,
++	.clkr = {
++		.enable_reg = 0x28038,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie0_axi_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie0_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_anoc_pcie0_1lane_m_clk = {
++	.halt_reg = 0x2e07c,
++	.clkr = {
++		.enable_reg = 0x2e07c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_anoc_pcie0_1lane_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie0_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie1_axi_m_clk_src = {
++	.cmd_rcgr = 0x29018,
++	.freq_tbl = ftbl_pcie0_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie1_axi_m_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie1_axi_m_clk = {
++	.halt_reg = 0x29038,
++	.clkr = {
++		.enable_reg = 0x29038,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie1_axi_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie1_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_anoc_pcie1_1lane_m_clk = {
++	.halt_reg = 0x2e08c,
++	.clkr = {
++		.enable_reg = 0x2e08c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_anoc_pcie1_1lane_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie1_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_pcie2_axi_m_clk_src[] = {
++	F(342857143, P_GPLL4, 3.5, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 pcie2_axi_m_clk_src = {
++	.cmd_rcgr = 0x2a018,
++	.freq_tbl = ftbl_pcie2_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie2_axi_m_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie2_axi_m_clk = {
++	.halt_reg = 0x2a038,
++	.clkr = {
++		.enable_reg = 0x2a038,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie2_axi_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie2_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_anoc_pcie2_2lane_m_clk = {
++	.halt_reg = 0x2e080,
++	.clkr = {
++		.enable_reg = 0x2e080,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_anoc_pcie2_2lane_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie2_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie3_axi_m_clk_src = {
++	.cmd_rcgr = 0x2b018,
++	.freq_tbl = ftbl_pcie2_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie3_axi_m_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie3_axi_m_clk = {
++	.halt_reg = 0x2b038,
++	.clkr = {
++		.enable_reg = 0x2b038,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie3_axi_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie3_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_anoc_pcie3_2lane_m_clk = {
++	.halt_reg = 0x2e090,
++	.clkr = {
++		.enable_reg = 0x2e090,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_anoc_pcie3_2lane_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie3_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie0_axi_s_clk_src = {
++	.cmd_rcgr = 0x28020,
++	.freq_tbl = ftbl_pcie0_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie0_axi_s_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie0_axi_s_clk = {
++	.halt_reg = 0x2803c,
++	.clkr = {
++		.enable_reg = 0x2803c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie0_axi_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie0_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie0_axi_s_bridge_clk = {
++	.halt_reg = 0x28040,
++	.clkr = {
++		.enable_reg = 0x28040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie0_axi_s_bridge_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie0_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_snoc_pcie0_1lane_s_clk = {
++	.halt_reg = 0x2e048,
++	.clkr = {
++		.enable_reg = 0x2e048,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_snoc_pcie0_1lane_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie0_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie1_axi_s_clk_src = {
++	.cmd_rcgr = 0x29020,
++	.freq_tbl = ftbl_pcie0_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie1_axi_s_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie1_axi_s_clk = {
++	.halt_reg = 0x2903c,
++	.clkr = {
++		.enable_reg = 0x2903c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie1_axi_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie1_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie1_axi_s_bridge_clk = {
++	.halt_reg = 0x29040,
++	.clkr = {
++		.enable_reg = 0x29040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie1_axi_s_bridge_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie1_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_snoc_pcie1_1lane_s_clk = {
++	.halt_reg = 0x2e04c,
++	.clkr = {
++		.enable_reg = 0x2e04c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_snoc_pcie1_1lane_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie1_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie2_axi_s_clk_src = {
++	.cmd_rcgr = 0x2a020,
++	.freq_tbl = ftbl_pcie0_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie2_axi_s_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie2_axi_s_clk = {
++	.halt_reg = 0x2a03c,
++	.clkr = {
++		.enable_reg = 0x2a03c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie2_axi_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie2_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie2_axi_s_bridge_clk = {
++	.halt_reg = 0x2a040,
++	.clkr = {
++		.enable_reg = 0x2a040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie2_axi_s_bridge_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie2_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_snoc_pcie2_2lane_s_clk = {
++	.halt_reg = 0x2e050,
++	.clkr = {
++		.enable_reg = 0x2e050,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_snoc_pcie2_2lane_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie2_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie3_axi_s_clk_src = {
++	.cmd_rcgr = 0x2b020,
++	.freq_tbl = ftbl_pcie0_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie3_axi_s_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie3_axi_s_clk = {
++	.halt_reg = 0x2b03c,
++	.clkr = {
++		.enable_reg = 0x2b03c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie3_axi_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie3_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie3_axi_s_bridge_clk = {
++	.halt_reg = 0x2b040,
++	.clkr = {
++		.enable_reg = 0x2b040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie3_axi_s_bridge_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie3_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_snoc_pcie3_2lane_s_clk = {
++	.halt_reg = 0x2e054,
++	.clkr = {
++		.enable_reg = 0x2e054,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_snoc_pcie3_2lane_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie3_axi_s_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_regmap_phy_mux pcie0_pipe_clk_src = {
++	.reg = 0x28064,
++	.clkr = {
++		.hw.init = &(struct clk_init_data) {
++			.name = "pcie0_pipe_clk_src",
++			.parent_data = &(const struct clk_parent_data) {
++				.index = DT_PCIE30_PHY0_PIPE_CLK,
++			},
++			.num_parents = 1,
++			.ops = &clk_regmap_phy_mux_ops,
++		},
++	},
++};
++
++static struct clk_regmap_phy_mux pcie1_pipe_clk_src = {
++	.reg = 0x29064,
++	.clkr = {
++		.hw.init = &(struct clk_init_data) {
++			.name = "pcie1_pipe_clk_src",
++			.parent_data = &(const struct clk_parent_data) {
++				.index = DT_PCIE30_PHY1_PIPE_CLK,
++			},
++			.num_parents = 1,
++			.ops = &clk_regmap_phy_mux_ops,
++		},
++	},
++};
++
++static struct clk_regmap_phy_mux pcie2_pipe_clk_src = {
++	.reg = 0x2a064,
++	.clkr = {
++		.hw.init = &(struct clk_init_data) {
++			.name = "pcie2_pipe_clk_src",
++			.parent_data = &(const struct clk_parent_data) {
++				.index = DT_PCIE30_PHY2_PIPE_CLK,
++			},
++			.num_parents = 1,
++			.ops = &clk_regmap_phy_mux_ops,
++		},
++	},
++};
++
++static struct clk_regmap_phy_mux pcie3_pipe_clk_src = {
++	.reg = 0x2b064,
++	.clkr = {
++		.hw.init = &(struct clk_init_data) {
++			.name = "pcie3_pipe_clk_src",
++			.parent_data = &(const struct clk_parent_data) {
++				.index = DT_PCIE30_PHY3_PIPE_CLK,
++			},
++			.num_parents = 1,
++			.ops = &clk_regmap_phy_mux_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_pcie_rchng_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(100000000, P_GPLL0, 8, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 pcie0_rchng_clk_src = {
++	.cmd_rcgr = 0x28028,
++	.freq_tbl = ftbl_pcie_rchng_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie0_rchng_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie0_rchng_clk = {
++	.halt_reg = 0x28028,
++	.clkr = {
++		.enable_reg = 0x28028,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie0_rchng_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie0_rchng_clk_src.clkr.hw
++
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie1_rchng_clk_src = {
++	.cmd_rcgr = 0x29028,
++	.freq_tbl = ftbl_pcie_rchng_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie1_rchng_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie1_rchng_clk = {
++	.halt_reg = 0x29028,
++	.clkr = {
++		.enable_reg = 0x29028,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie1_rchng_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie1_rchng_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie2_rchng_clk_src = {
++	.cmd_rcgr = 0x2a028,
++	.freq_tbl = ftbl_pcie_rchng_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie2_rchng_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie2_rchng_clk = {
++	.halt_reg = 0x2a028,
++	.clkr = {
++		.enable_reg = 0x2a028,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie2_rchng_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie2_rchng_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_rcg2 pcie3_rchng_clk_src = {
++	.cmd_rcgr = 0x2b028,
++	.freq_tbl = ftbl_pcie_rchng_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie3_rchng_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie3_rchng_clk = {
++	.halt_reg = 0x2b028,
++	.clkr = {
++		.enable_reg = 0x2b028,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie3_rchng_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie3_rchng_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_pcie_aux_clk_src[] = {
++	F(20000000, P_GPLL0, 10, 1, 4),
++	{ }
++};
++
++static struct clk_rcg2 pcie_aux_clk_src = {
++	.cmd_rcgr = 0x28004,
++	.freq_tbl = ftbl_pcie_aux_clk_src,
++	.mnd_width = 16,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_aux_core_pi_sleep_clk_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcie_aux_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_aux_core_pi_sleep_clk,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_aux_core_pi_sleep_clk),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_pcie0_aux_clk = {
++	.halt_reg = 0x28034,
++	.clkr = {
++		.enable_reg = 0x28034,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie0_aux_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie_aux_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie1_aux_clk = {
++	.halt_reg = 0x29034,
++	.clkr = {
++		.enable_reg = 0x29034,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie1_aux_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie_aux_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie2_aux_clk = {
++	.halt_reg = 0x2a034,
++	.clkr = {
++		.enable_reg = 0x2a034,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie2_aux_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie_aux_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie3_aux_clk = {
++	.halt_reg = 0x2b034,
++	.clkr = {
++		.enable_reg = 0x2b034,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie3_aux_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcie_aux_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_usb_aux_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 usb0_aux_clk_src = {
++	.cmd_rcgr = 0x2c018,
++	.freq_tbl = ftbl_usb_aux_clk_src,
++	.mnd_width = 16,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_core_pi_sleep_clk_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "usb0_aux_clk_src",
++		.parent_data = gcc_xo_gpll0_core_pi_sleep_clk,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_core_pi_sleep_clk),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_usb0_aux_clk = {
++	.halt_reg = 0x2c048,
++	.clkr = {
++		.enable_reg = 0x2c048,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_usb0_aux_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&usb0_aux_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_usb0_master_clk_src[] = {
++	F(100000000, P_GPLL0, 8, 0, 0),
++	F(200000000, P_GPLL0, 4, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 usb0_master_clk_src = {
++	.cmd_rcgr = 0x2c004,
++	.freq_tbl = ftbl_usb0_master_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_out_main_div2_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "usb0_master_clk_src",
++		.parent_data = gcc_xo_gpll0_out_main_div2_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_out_main_div2_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_usb0_master_clk = {
++	.halt_reg = 0x2c044,
++	.clkr = {
++		.enable_reg = 0x2c044,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_usb0_master_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&usb0_master_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_snoc_usb_clk = {
++	.halt_reg = 0x2e058,
++	.clkr = {
++		.enable_reg = 0x2e058,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_snoc_usb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&usb0_master_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_anoc_usb_axi_clk = {
++	.halt_reg = 0x2e084,
++	.clkr = {
++		.enable_reg = 0x2e084,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_anoc_usb_axi_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&usb0_master_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_usb0_mock_utmi_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(60000000, P_GPLL4, 10, 1, 2),
++	{ }
++};
++
++static struct clk_rcg2 usb0_mock_utmi_clk_src = {
++	.cmd_rcgr = 0x2c02c,
++	.freq_tbl = ftbl_usb0_mock_utmi_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll4_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "usb0_mock_utmi_clk_src",
++		.parent_data = gcc_xo_gpll4_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll4_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_regmap_div usb0_mock_utmi_div_clk_src = {
++	.reg = 0x2c040,
++	.shift = 0,
++	.width = 2,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "usb0_mock_utmi_div_clk_src",
++		.parent_data = &(const struct clk_parent_data) {
++			.hw = &usb0_mock_utmi_clk_src.clkr.hw,
++		},
++		.num_parents = 1,
++		.flags = CLK_SET_RATE_PARENT,
++		.ops = &clk_regmap_div_ro_ops,
++	},
++};
++
++static struct clk_branch gcc_usb0_mock_utmi_clk = {
++	.halt_reg = 0x2c04c,
++	.clkr = {
++		.enable_reg = 0x2c04c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_usb0_mock_utmi_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&usb0_mock_utmi_div_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_regmap_mux usb0_pipe_clk_src = {
++	.reg = 0x2C074,
++	.shift = 8,
++	.width = 2,
++	.parent_map = gcc_usb3phy_0_cc_pipe_clk_xo_map,
++	.clkr = {
++		.hw.init = &(struct clk_init_data) {
++			.name = "usb0_pipe_clk_src",
++			.parent_data = gcc_usb3phy_0_cc_pipe_clk_xo,
++			.num_parents = ARRAY_SIZE(gcc_usb3phy_0_cc_pipe_clk_xo),
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_regmap_mux_closest_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_sdcc_apps_clk_src[] = {
++	F(144000, P_XO, 16, 12, 125),
++	F(400000, P_XO, 12, 1, 5),
++	F(24000000, P_GPLL2, 12, 1, 4),
++	F(48000000, P_GPLL2, 12, 1, 2),
++	F(96000000, P_GPLL2, 12, 0, 0),
++	F(177777778, P_GPLL0, 4.5, 0, 0),
++	F(192000000, P_GPLL2, 6, 0, 0),
++	F(384000000, P_GPLL2, 3, 0, 0),
++	F(400000000, P_GPLL0, 2, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 sdcc1_apps_clk_src = {
++	.cmd_rcgr = 0x33004,
++	.freq_tbl = ftbl_sdcc_apps_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll2_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "sdcc1_apps_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll2_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll2_gpll0_out_main_div2),
++		.ops = &clk_rcg2_floor_ops,
++	},
++};
++
++static struct clk_branch gcc_sdcc1_apps_clk = {
++	.halt_reg = 0x3302c,
++	.clkr = {
++		.enable_reg = 0x3302c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_sdcc1_apps_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&sdcc1_apps_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_sdcc_ice_core_clk_src[] = {
++	F(150000000, P_GPLL4, 8, 0, 0),
++	F(300000000, P_GPLL4, 4, 0, 0),
++};
++
++static struct clk_rcg2 sdcc1_ice_core_clk_src = {
++	.cmd_rcgr = 0x33018,
++	.freq_tbl = ftbl_sdcc_ice_core_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_gpll0_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "sdcc1_ice_core_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4_gpll0_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4_gpll0_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_sdcc1_ice_core_clk = {
++	.halt_reg = 0x33030,
++	.clkr = {
++		.enable_reg = 0x33030,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_sdcc1_ice_core_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&sdcc1_ice_core_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_pcnoc_bfdcd_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(50000000, P_GPLL0, 16, 0, 0),
++	F(80000000, P_GPLL0, 10, 0, 0),
++	F(100000000, P_GPLL0, 8, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 pcnoc_bfdcd_clk_src = {
++	.cmd_rcgr = 0x31004,
++	.freq_tbl = ftbl_pcnoc_bfdcd_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "pcnoc_bfdcd_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.flags = CLK_IS_CRITICAL,
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_nsscfg_clk = {
++	.halt_reg = 0x1702c,
++	.clkr = {
++		.enable_reg = 0x1702c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nsscfg_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nssnoc_nsscc_clk = {
++	.halt_reg = 0x17030,
++	.clkr = {
++		.enable_reg = 0x17030,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_nsscc_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nsscc_clk = {
++	.halt_reg = 0x17034,
++	.clkr = {
++		.enable_reg = 0x17034,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nsscc_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nssnoc_pcnoc_1_clk = {
++	.halt_reg = 0x17080,
++	.clkr = {
++		.enable_reg = 0x17080,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_pcnoc_1_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_dap_ahb_clk = {
++	.halt_reg = 0x2d064,
++	.clkr = {
++		.enable_reg = 0x2d064,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_dap_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_cfg_ahb_clk = {
++	.halt_reg = 0x2d068,
++	.clkr = {
++		.enable_reg = 0x2d068,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_cfg_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qpic_ahb_clk = {
++	.halt_reg = 0x32010,
++	.clkr = {
++		.enable_reg = 0x32010,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qpic_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qpic_clk = {
++	.halt_reg = 0x32014,
++	.clkr = {
++		.enable_reg = 0x32014,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qpic_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_blsp1_ahb_clk = {
++	.halt_reg = 0x01004,
++	.halt_check = BRANCH_HALT_VOTED,
++	.clkr = {
++		.enable_reg = 0x0b004,
++		.enable_mask = BIT(4),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_blsp1_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_mdio_ahb_clk = {
++	.halt_reg = 0x17040,
++	.clkr = {
++		.enable_reg = 0x17040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_mdio_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_prng_ahb_clk = {
++	.halt_reg = 0x13024,
++	.halt_check = BRANCH_HALT_VOTED,
++	.clkr = {
++		.enable_reg = 0x0b004,
++		.enable_mask = BIT(10),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_prng_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_uniphy0_ahb_clk = {
++	.halt_reg = 0x1704c,
++	.clkr = {
++		.enable_reg = 0x1704c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_uniphy0_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_uniphy1_ahb_clk = {
++	.halt_reg = 0x1705c,
++	.clkr = {
++		.enable_reg = 0x1705c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_uniphy1_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_uniphy2_ahb_clk = {
++	.halt_reg = 0x1706c,
++	.clkr = {
++		.enable_reg = 0x1706c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_uniphy2_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_cmn_12gpll_ahb_clk = {
++	.halt_reg = 0x3a004,
++	.clkr = {
++		.enable_reg = 0x3a004,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_cmn_12gpll_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_cmn_12gpll_apu_clk = {
++	.halt_reg = 0x3a00c,
++	.clkr = {
++		.enable_reg = 0x3a00c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_cmn_12gpll_apu_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie0_ahb_clk = {
++	.halt_reg = 0x28030,
++	.clkr = {
++		.enable_reg = 0x28030,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie0_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie1_ahb_clk = {
++	.halt_reg = 0x29030,
++	.clkr = {
++		.enable_reg = 0x29030,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie1_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie2_ahb_clk = {
++	.halt_reg = 0x2a030,
++	.clkr = {
++		.enable_reg = 0x2a030,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie2_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcie3_ahb_clk = {
++	.halt_reg = 0x2b030,
++	.clkr = {
++		.enable_reg = 0x2b030,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcie3_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_usb0_phy_cfg_ahb_clk = {
++	.halt_reg = 0x2c05c,
++	.clkr = {
++		.enable_reg = 0x2c05c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_usb0_phy_cfg_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_sdcc1_ahb_clk = {
++	.halt_reg = 0x33034,
++	.clkr = {
++		.enable_reg = 0x33034,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_sdcc1_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&pcnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_system_noc_bfdcd_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(133333333, P_GPLL0, 6, 0, 0),
++	F(200000000, P_GPLL0, 4, 0, 0),
++	F(342850000, P_GPLL4, 3.5, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 system_noc_bfdcd_clk_src = {
++	.cmd_rcgr = 0x2e004,
++	.freq_tbl = ftbl_system_noc_bfdcd_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "system_noc_bfdcd_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4),
++		.flags = CLK_IS_CRITICAL,
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_q6ss_boot_clk = {
++	.halt_reg = 0x25080,
++	.halt_check = BRANCH_HALT_SKIP,
++	.clkr = {
++		.enable_reg = 0x25080,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_q6ss_boot_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&system_noc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nssnoc_snoc_clk = {
++	.halt_reg = 0x17028,
++	.clkr = {
++		.enable_reg = 0x17028,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_snoc_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&system_noc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nssnoc_snoc_1_clk = {
++	.halt_reg = 0x1707c,
++	.clkr = {
++		.enable_reg = 0x1707c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_snoc_1_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&system_noc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_etr_usb_clk = {
++	.halt_reg = 0x2d060,
++	.clkr = {
++		.enable_reg = 0x2d060,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_etr_usb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&system_noc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_wcss_ahb_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(133333333, P_GPLL0, 6, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 wcss_ahb_clk_src = {
++	.cmd_rcgr = 0x25030,
++	.freq_tbl = ftbl_wcss_ahb_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "wcss_ahb_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_q6_ahb_clk = {
++	.halt_reg = 0x25014,
++	.clkr = {
++		.enable_reg = 0x25014,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_q6_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&wcss_ahb_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_q6_ahb_s_clk = {
++	.halt_reg = 0x25018,
++	.clkr = {
++		.enable_reg = 0x25018,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_q6_ahb_s_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&wcss_ahb_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_wcss_ecahb_clk = {
++	.halt_reg = 0x25058,
++	.clkr = {
++		.enable_reg = 0x25058,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_wcss_ecahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&wcss_ahb_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_wcss_acmt_clk = {
++	.halt_reg = 0x2505c,
++	.clkr = {
++		.enable_reg = 0x2505c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_wcss_acmt_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&wcss_ahb_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_sys_noc_wcss_ahb_clk = {
++	.halt_reg = 0x2e030,
++	.clkr = {
++		.enable_reg = 0x2e030,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_sys_noc_wcss_ahb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&wcss_ahb_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_wcss_axi_m_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(133333333, P_GPLL0, 6, 0, 0),
++	F(266666667, P_GPLL0, 3, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 wcss_axi_m_clk_src = {
++	.cmd_rcgr = 0x25078,
++	.freq_tbl = ftbl_wcss_axi_m_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "wcss_axi_m_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_anoc_wcss_axi_m_clk = {
++	.halt_reg = 0x2e0a8,
++	.clkr = {
++		.enable_reg = 0x2e0a8,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_anoc_wcss_axi_m_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&wcss_axi_m_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_qdss_at_clk_src[] = {
++	F(240000000, P_GPLL4, 5, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 qdss_at_clk_src = {
++	.cmd_rcgr = 0x2d004,
++	.freq_tbl = ftbl_qdss_at_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll4_gpll0_gpll0_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "qdss_at_clk_src",
++		.parent_data = gcc_xo_gpll4_gpll0_gpll0_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll4_gpll0_gpll0_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_q6ss_atbm_clk = {
++	.halt_reg = 0x2501c,
++	.clkr = {
++		.enable_reg = 0x2501c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_q6ss_atbm_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_at_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_wcss_dbg_ifc_atb_clk = {
++	.halt_reg = 0x2503c,
++	.clkr = {
++		.enable_reg = 0x2503c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_wcss_dbg_ifc_atb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_at_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nssnoc_atb_clk = {
++	.halt_reg = 0x17014,
++	.clkr = {
++		.enable_reg = 0x17014,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_atb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_at_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_at_clk = {
++	.halt_reg = 0x2d038,
++	.clkr = {
++		.enable_reg = 0x2d038,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_at_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_at_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_sys_noc_at_clk = {
++	.halt_reg = 0x2e038,
++	.clkr = {
++		.enable_reg = 0x2e038,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_sys_noc_at_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_at_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_pcnoc_at_clk = {
++	.halt_reg = 0x31024,
++	.clkr = {
++		.enable_reg = 0x31024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_pcnoc_at_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_at_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_fixed_factor gcc_eud_at_div_clk_src = {
++	.mult = 1,
++	.div = 6,
++	.hw.init = &(struct clk_init_data) {
++		.name = "gcc_eud_at_div_clk_src",
++		.parent_hws = (const struct clk_hw *[]) {
++			&qdss_at_clk_src.clkr.hw
++		},
++		.num_parents = 1,
++		.flags = CLK_SET_RATE_PARENT,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++static struct clk_branch gcc_usb0_eud_at_clk = {
++	.halt_reg = 0x30004,
++	.clkr = {
++		.enable_reg = 0x30004,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_usb0_eud_at_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&gcc_eud_at_div_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_eud_at_clk = {
++	.halt_reg = 0x2d06c,
++	.clkr = {
++		.enable_reg = 0x2d06c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_eud_at_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&gcc_eud_at_div_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_qdss_stm_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(200000000, P_GPLL0, 4, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 qdss_stm_clk_src = {
++	.cmd_rcgr = 0x2d00c,
++	.freq_tbl = ftbl_qdss_stm_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_out_main_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "qdss_stm_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_out_main_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_out_main_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_qdss_stm_clk = {
++	.halt_reg = 0x2d03c,
++	.clkr = {
++		.enable_reg = 0x2d03c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_stm_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_stm_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_sys_noc_qdss_stm_axi_clk = {
++	.halt_reg = 0x2e034,
++	.clkr = {
++		.enable_reg = 0x2e034,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_sys_noc_qdss_stm_axi_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_stm_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_qdss_traceclkin_clk_src[] = {
++	F(300000000, P_GPLL4, 4, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 qdss_traceclkin_clk_src = {
++	.cmd_rcgr = 0x2d014,
++	.freq_tbl = ftbl_qdss_traceclkin_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll4_gpll0_gpll0_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "qdss_traceclkin_clk_src",
++		.parent_data = gcc_xo_gpll4_gpll0_gpll0_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll4_gpll0_gpll0_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_qdss_traceclkin_clk = {
++	.halt_reg = 0x2d040,
++	.clkr = {
++		.enable_reg = 0x2d040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_traceclkin_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_traceclkin_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_qdss_tsctr_clk_src[] = {
++	F(600000000, P_GPLL4, 2, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 qdss_tsctr_clk_src = {
++	.cmd_rcgr = 0x2d01c,
++	.freq_tbl = ftbl_qdss_tsctr_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll4_gpll0_gpll0_div2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "qdss_tsctr_clk_src",
++		.parent_data = gcc_xo_gpll4_gpll0_gpll0_div2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll4_gpll0_gpll0_div2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_fixed_factor qdss_tsctr_div2_clk_src = {
++	.mult = 1,
++	.div = 2,
++	.hw.init = &(struct clk_init_data) {
++		.name = "qdss_tsctr_div2_clk_src",
++		.parent_hws = (const struct clk_hw *[]) {
++			&qdss_tsctr_clk_src.clkr.hw
++		},
++		.num_parents = 1,
++		.flags = CLK_SET_RATE_PARENT,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++static struct clk_branch gcc_q6_tsctr_1to2_clk = {
++	.halt_reg = 0x25020,
++	.clkr = {
++		.enable_reg = 0x25020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_q6_tsctr_1to2_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_tsctr_div2_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_wcss_dbg_ifc_nts_clk = {
++	.halt_reg = 0x25040,
++	.clkr = {
++		.enable_reg = 0x25040,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_wcss_dbg_ifc_nts_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_tsctr_div2_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_tsctr_div2_clk = {
++	.halt_reg = 0x2d044,
++	.clkr = {
++		.enable_reg = 0x2d044,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_tsctr_div2_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_tsctr_div2_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_uniphy_sys_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 uniphy_sys_clk_src = {
++	.cmd_rcgr = 0x17090,
++	.freq_tbl = ftbl_uniphy_sys_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "uniphy_sys_clk_src",
++		.parent_data = gcc_xo_data,
++		.num_parents = ARRAY_SIZE(gcc_xo_data),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 nss_ts_clk_src = {
++	.cmd_rcgr = 0x17088,
++	.freq_tbl = ftbl_uniphy_sys_clk_src,
++	.mnd_width = 8,
++	.hid_width = 5,
++	.parent_map = gcc_xo_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "nss_ts_clk_src",
++		.parent_data = gcc_xo_data,
++		.num_parents = ARRAY_SIZE(gcc_xo_data),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_qdss_ts_clk = {
++	.halt_reg = 0x2d078,
++	.clkr = {
++		.enable_reg = 0x2d078,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_ts_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&nss_ts_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_fixed_factor qdss_dap_sync_clk_src = {
++	.mult = 1,
++	.div = 4,
++	.hw.init = &(struct clk_init_data) {
++		.name = "qdss_dap_sync_clk_src",
++		.parent_hws = (const struct clk_hw *[]) {
++			&qdss_tsctr_clk_src.clkr.hw
++		},
++		.num_parents = 1,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++static struct clk_branch gcc_qdss_tsctr_div4_clk = {
++	.halt_reg = 0x2d04c,
++	.clkr = {
++		.enable_reg = 0x2d04c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_tsctr_div4_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_dap_sync_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_fixed_factor qdss_tsctr_div8_clk_src = {
++	.mult = 1,
++	.div = 8,
++	.hw.init = &(struct clk_init_data) {
++		.name = "qdss_tsctr_div8_clk_src",
++		.parent_hws = (const struct clk_hw *[]) {
++			&qdss_tsctr_clk_src.clkr.hw
++		},
++		.num_parents = 1,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++static struct clk_branch gcc_nss_ts_clk = {
++	.halt_reg = 0x17018,
++	.clkr = {
++		.enable_reg = 0x17018,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nss_ts_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&nss_ts_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_tsctr_div8_clk = {
++	.halt_reg = 0x2d050,
++	.clkr = {
++		.enable_reg = 0x2d050,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_tsctr_div8_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_tsctr_div8_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_fixed_factor qdss_tsctr_div16_clk_src = {
++	.mult = 1,
++	.div = 16,
++	.hw.init = &(struct clk_init_data) {
++		.name = "qdss_tsctr_div16_clk_src",
++		.parent_hws = (const struct clk_hw *[]) {
++			&qdss_tsctr_clk_src.clkr.hw
++		},
++		.num_parents = 1,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++static struct clk_branch gcc_qdss_tsctr_div16_clk = {
++	.halt_reg = 0x2d054,
++	.clkr = {
++		.enable_reg = 0x2d054,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_tsctr_div16_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_tsctr_div16_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_q6ss_pclkdbg_clk = {
++	.halt_reg = 0x25024,
++	.clkr = {
++		.enable_reg = 0x25024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_q6ss_pclkdbg_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_dap_sync_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_q6ss_trig_clk = {
++	.halt_reg = 0x25068,
++	.clkr = {
++		.enable_reg = 0x25068,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_q6ss_trig_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_dap_sync_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_wcss_dbg_ifc_apb_clk = {
++	.halt_reg = 0x25038,
++	.clkr = {
++		.enable_reg = 0x25038,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_wcss_dbg_ifc_apb_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_dap_sync_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_wcss_dbg_ifc_dapbus_clk = {
++	.halt_reg = 0x25044,
++	.clkr = {
++		.enable_reg = 0x25044,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_wcss_dbg_ifc_dapbus_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_dap_sync_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_dap_clk = {
++	.halt_reg = 0x2d058,
++	.clkr = {
++		.enable_reg = 0x2d058,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_dap_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_dap_sync_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_qdss_apb2jtag_clk = {
++	.halt_reg = 0x2d05c,
++	.clkr = {
++		.enable_reg = 0x2d05c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_apb2jtag_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_dap_sync_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_fixed_factor qdss_tsctr_div3_clk_src = {
++	.mult = 1,
++	.div = 3,
++	.hw.init = &(struct clk_init_data) {
++		.name = "qdss_tsctr_div3_clk_src",
++		.parent_hws = (const struct clk_hw *[]) {
++			&qdss_tsctr_clk_src.clkr.hw
++		},
++		.num_parents = 1,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++static struct clk_branch gcc_qdss_tsctr_div3_clk = {
++	.halt_reg = 0x2d048,
++	.clkr = {
++		.enable_reg = 0x2d048,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_qdss_tsctr_div3_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&qdss_tsctr_div3_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_qpic_io_macro_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(100000000, P_GPLL0, 8, 0, 0),
++	F(200000000, P_GPLL0, 4, 0, 0),
++	F(320000000, P_GPLL0, 2.5, 0, 0),
++	F(400000000, P_GPLL0, 2, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 qpic_io_macro_clk_src = {
++	.cmd_rcgr = 0x32004,
++	.freq_tbl = ftbl_qpic_io_macro_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "qpic_io_macro_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_qpic_io_macro_clk = {
++	.halt_reg = 0x3200c,
++	.clkr = {
++		.enable_reg = 0x3200c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "gcc_qpic_io_macro_clk",
++			.parent_hws = (const struct clk_hw *[]){
++				&qpic_io_macro_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_q6_axi_clk_src[] = {
++	F(533333333, P_GPLL0, 1.5, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 q6_axi_clk_src = {
++	.cmd_rcgr = 0x25004,
++	.freq_tbl = ftbl_q6_axi_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll2_gpll4_pi_sleep_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "q6_axi_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll2_gpll4_pi_sleep,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll2_gpll4_pi_sleep),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_q6_axim_clk = {
++	.halt_reg = 0x2500c,
++	.clkr = {
++		.enable_reg = 0x2500c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_q6_axim_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&q6_axi_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_wcss_q6_tbu_clk = {
++	.halt_reg = 0x12050,
++	.halt_check = BRANCH_HALT_DELAY,
++	.clkr = {
++		.enable_reg = 0xb00c,
++		.enable_mask = BIT(6),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_wcss_q6_tbu_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&q6_axi_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_mem_noc_q6_axi_clk = {
++	.halt_reg = 0x19010,
++	.clkr = {
++		.enable_reg = 0x19010,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_mem_noc_q6_axi_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&q6_axi_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_q6_axim2_clk_src[] = {
++	F(342857143, P_GPLL4, 3.5, 0, 0),
++	{ }
++};
++
++static const struct parent_map gcc_xo_gpll0_gpll4_bias_pll_ubinc_clk_map[] = {
++	{ P_XO, 0 },
++	{ P_GPLL0, 1 },
++	{ P_GPLL4, 2 },
++	{ P_BIAS_PLL_UBI_NC_CLK, 4 },
++};
++
++static struct clk_rcg2 q6_axim2_clk_src = {
++	.cmd_rcgr = 0x25028,
++	.freq_tbl = ftbl_q6_axim2_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll4_bias_pll_ubinc_clk_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "q6_axim2_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll4_bias_pll_ubi_nc_clk),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static const struct freq_tbl ftbl_nssnoc_memnoc_bfdcd_clk_src[] = {
++	F(533333333, P_GPLL0, 1.5, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 nssnoc_memnoc_bfdcd_clk_src = {
++	.cmd_rcgr = 0x17004,
++	.freq_tbl = ftbl_nssnoc_memnoc_bfdcd_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_aux_gpll2_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "nssnoc_memnoc_bfdcd_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_aux_gpll2,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_aux_gpll2),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_nssnoc_memnoc_clk = {
++	.halt_reg = 0x17024,
++	.clkr = {
++		.enable_reg = 0x17024,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_memnoc_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&nssnoc_memnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nssnoc_mem_noc_1_clk = {
++	.halt_reg = 0x17084,
++	.clkr = {
++		.enable_reg = 0x17084,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_mem_noc_1_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&nssnoc_memnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nss_tbu_clk = {
++	.halt_reg = 0x12040,
++	.clkr = {
++		.enable_reg = 0xb00c,
++		.enable_mask = BIT(4),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nss_tbu_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&nssnoc_memnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_mem_noc_nssnoc_clk = {
++	.halt_reg = 0x19014,
++	.clkr = {
++		.enable_reg = 0x19014,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_mem_noc_nssnoc_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&nssnoc_memnoc_bfdcd_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_lpass_axim_clk_src[] = {
++	F(133333333, P_GPLL0, 6, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 lpass_axim_clk_src = {
++	.cmd_rcgr = 0x2700c,
++	.freq_tbl = ftbl_lpass_axim_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "lpass_axim_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 lpass_sway_clk_src = {
++	.cmd_rcgr = 0x27004,
++	.freq_tbl = ftbl_lpass_axim_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "lpass_sway_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static const struct freq_tbl ftbl_adss_pwm_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(100000000, P_GPLL0, 8, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 adss_pwm_clk_src = {
++	.cmd_rcgr = 0x1c004,
++	.freq_tbl = ftbl_adss_pwm_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "adss_pwm_clk_src",
++		.parent_data = gcc_xo_gpll0,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_adss_pwm_clk = {
++	.halt_reg = 0x1c00c,
++	.clkr = {
++		.enable_reg = 0x1c00c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_adss_pwm_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&adss_pwm_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static const struct freq_tbl ftbl_gp1_clk_src[] = {
++	F(24000000, P_XO, 1, 0, 0),
++	F(200000000, P_GPLL0, 4, 0, 0),
++	{ }
++};
++
++static struct clk_rcg2 gp1_clk_src = {
++	.cmd_rcgr = 0x8004,
++	.freq_tbl = ftbl_gp1_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_sleep_clk_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "gp1_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_sleep_clk,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_sleep_clk),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 gp2_clk_src = {
++	.cmd_rcgr = 0x9004,
++	.freq_tbl = ftbl_gp1_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_sleep_clk_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "gp2_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_sleep_clk,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_sleep_clk),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_rcg2 gp3_clk_src = {
++	.cmd_rcgr = 0xa004,
++	.freq_tbl = ftbl_gp1_clk_src,
++	.hid_width = 5,
++	.parent_map = gcc_xo_gpll0_gpll0_sleep_clk_map,
++	.clkr.hw.init = &(struct clk_init_data) {
++		.name = "gp3_clk_src",
++		.parent_data = gcc_xo_gpll0_gpll0_sleep_clk,
++		.num_parents = ARRAY_SIZE(gcc_xo_gpll0_gpll0_sleep_clk),
++		.ops = &clk_rcg2_ops,
++	},
++};
++
++static struct clk_branch gcc_xo_clk_src = {
++	.halt_reg = 0x34004,
++	.clkr = {
++		.enable_reg = 0x34004,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_xo_clk_src",
++			.parent_data = gcc_xo_data,
++			.num_parents = ARRAY_SIZE(gcc_xo_data),
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nssnoc_xo_dcd_clk = {
++	.halt_reg = 0x17074,
++	.clkr = {
++		.enable_reg = 0x17074,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_xo_dcd_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&gcc_xo_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_xo_clk = {
++	.halt_reg = 0x34018,
++	.clkr = {
++		.enable_reg = 0x34018,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_xo_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&gcc_xo_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_uniphy0_sys_clk = {
++	.halt_reg = 0x17048,
++	.clkr = {
++		.enable_reg = 0x17048,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_uniphy0_sys_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&uniphy_sys_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_uniphy1_sys_clk = {
++	.halt_reg = 0x17058,
++	.clkr = {
++		.enable_reg = 0x17058,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_uniphy1_sys_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&uniphy_sys_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_uniphy2_sys_clk = {
++	.halt_reg = 0x17068,
++	.clkr = {
++		.enable_reg = 0x17068,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_uniphy2_sys_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&uniphy_sys_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_cmn_12gpll_sys_clk = {
++	.halt_reg = 0x3a008,
++	.clkr = {
++		.enable_reg = 0x3a008,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_cmn_12gpll_sys_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&uniphy_sys_clk_src.clkr.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_fixed_factor gcc_xo_div4_clk_src = {
++	.mult = 1,
++	.div = 4,
++	.hw.init = &(struct clk_init_data) {
++		.name = "gcc_xo_div4_clk_src",
++		.parent_hws = (const struct clk_hw *[]) {
++			&gcc_xo_clk_src.clkr.hw
++		},
++		.num_parents = 1,
++		.flags = CLK_SET_RATE_PARENT,
++		.ops = &clk_fixed_factor_ops,
++	},
++};
++
++static struct clk_branch gcc_nssnoc_qosgen_ref_clk = {
++	.halt_reg = 0x1701c,
++	.clkr = {
++		.enable_reg = 0x1701c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_qosgen_ref_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&gcc_xo_div4_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_nssnoc_timeout_ref_clk = {
++	.halt_reg = 0x17020,
++	.clkr = {
++		.enable_reg = 0x17020,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_nssnoc_timeout_ref_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&gcc_xo_div4_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_branch gcc_xo_div4_clk = {
++	.halt_reg = 0x3401c,
++	.clkr = {
++		.enable_reg = 0x3401c,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data) {
++			.name = "gcc_xo_div4_clk",
++			.parent_hws = (const struct clk_hw *[]) {
++				&gcc_xo_div4_clk_src.hw
++			},
++			.num_parents = 1,
++			.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,
++			.ops = &clk_branch2_ops,
++		},
++	},
++};
++
++static struct clk_hw *gcc_ipq9574_hws[] = {
++	&gpll0_out_main_div2.hw,
++	&gcc_xo_div4_clk_src.hw,
++	&qdss_dap_sync_clk_src.hw,
++	&qdss_tsctr_div2_clk_src.hw,
++	&qdss_tsctr_div8_clk_src.hw,
++	&qdss_tsctr_div16_clk_src.hw,
++	&qdss_tsctr_div3_clk_src.hw,
++	&gcc_eud_at_div_clk_src.hw,
++};
++
++static struct clk_regmap *gcc_ipq9574_clks[] = {
++	[GPLL0_MAIN] = &gpll0_main.clkr,
++	[GPLL0] = &gpll0.clkr,
++	[GPLL4_MAIN] = &gpll4_main.clkr,
++	[GPLL4] = &gpll4.clkr,
++	[GPLL2_MAIN] = &gpll2_main.clkr,
++	[GPLL2] = &gpll2.clkr,
++	[GCC_SLEEP_CLK_SRC] = &gcc_sleep_clk_src.clkr,
++	[APSS_AHB_CLK_SRC] = &apss_ahb_clk_src.clkr,
++	[APSS_AXI_CLK_SRC] = &apss_axi_clk_src.clkr,
++	[BLSP1_QUP1_I2C_APPS_CLK_SRC] = &blsp1_qup1_i2c_apps_clk_src.clkr,
++	[BLSP1_QUP1_SPI_APPS_CLK_SRC] = &blsp1_qup1_spi_apps_clk_src.clkr,
++	[BLSP1_QUP2_I2C_APPS_CLK_SRC] = &blsp1_qup2_i2c_apps_clk_src.clkr,
++	[BLSP1_QUP2_SPI_APPS_CLK_SRC] = &blsp1_qup2_spi_apps_clk_src.clkr,
++	[BLSP1_QUP3_I2C_APPS_CLK_SRC] = &blsp1_qup3_i2c_apps_clk_src.clkr,
++	[BLSP1_QUP3_SPI_APPS_CLK_SRC] = &blsp1_qup3_spi_apps_clk_src.clkr,
++	[BLSP1_QUP4_I2C_APPS_CLK_SRC] = &blsp1_qup4_i2c_apps_clk_src.clkr,
++	[BLSP1_QUP4_SPI_APPS_CLK_SRC] = &blsp1_qup4_spi_apps_clk_src.clkr,
++	[BLSP1_QUP5_I2C_APPS_CLK_SRC] = &blsp1_qup5_i2c_apps_clk_src.clkr,
++	[BLSP1_QUP5_SPI_APPS_CLK_SRC] = &blsp1_qup5_spi_apps_clk_src.clkr,
++	[BLSP1_QUP6_I2C_APPS_CLK_SRC] = &blsp1_qup6_i2c_apps_clk_src.clkr,
++	[BLSP1_QUP6_SPI_APPS_CLK_SRC] = &blsp1_qup6_spi_apps_clk_src.clkr,
++	[BLSP1_UART1_APPS_CLK_SRC] = &blsp1_uart1_apps_clk_src.clkr,
++	[BLSP1_UART2_APPS_CLK_SRC] = &blsp1_uart2_apps_clk_src.clkr,
++	[BLSP1_UART3_APPS_CLK_SRC] = &blsp1_uart3_apps_clk_src.clkr,
++	[BLSP1_UART4_APPS_CLK_SRC] = &blsp1_uart4_apps_clk_src.clkr,
++	[BLSP1_UART5_APPS_CLK_SRC] = &blsp1_uart5_apps_clk_src.clkr,
++	[BLSP1_UART6_APPS_CLK_SRC] = &blsp1_uart6_apps_clk_src.clkr,
++	[GCC_APSS_AHB_CLK] = &gcc_apss_ahb_clk.clkr,
++	[GCC_APSS_AXI_CLK] = &gcc_apss_axi_clk.clkr,
++	[GCC_BLSP1_QUP1_I2C_APPS_CLK] = &gcc_blsp1_qup1_i2c_apps_clk.clkr,
++	[GCC_BLSP1_QUP1_SPI_APPS_CLK] = &gcc_blsp1_qup1_spi_apps_clk.clkr,
++	[GCC_BLSP1_QUP2_I2C_APPS_CLK] = &gcc_blsp1_qup2_i2c_apps_clk.clkr,
++	[GCC_BLSP1_QUP2_SPI_APPS_CLK] = &gcc_blsp1_qup2_spi_apps_clk.clkr,
++	[GCC_BLSP1_QUP3_I2C_APPS_CLK] = &gcc_blsp1_qup3_i2c_apps_clk.clkr,
++	[GCC_BLSP1_QUP3_SPI_APPS_CLK] = &gcc_blsp1_qup3_spi_apps_clk.clkr,
++	[GCC_BLSP1_QUP4_I2C_APPS_CLK] = &gcc_blsp1_qup4_i2c_apps_clk.clkr,
++	[GCC_BLSP1_QUP4_SPI_APPS_CLK] = &gcc_blsp1_qup4_spi_apps_clk.clkr,
++	[GCC_BLSP1_QUP5_I2C_APPS_CLK] = &gcc_blsp1_qup5_i2c_apps_clk.clkr,
++	[GCC_BLSP1_QUP5_SPI_APPS_CLK] = &gcc_blsp1_qup5_spi_apps_clk.clkr,
++	[GCC_BLSP1_QUP6_I2C_APPS_CLK] = &gcc_blsp1_qup6_i2c_apps_clk.clkr,
++	[GCC_BLSP1_QUP6_SPI_APPS_CLK] = &gcc_blsp1_qup6_spi_apps_clk.clkr,
++	[GCC_BLSP1_UART1_APPS_CLK] = &gcc_blsp1_uart1_apps_clk.clkr,
++	[GCC_BLSP1_UART2_APPS_CLK] = &gcc_blsp1_uart2_apps_clk.clkr,
++	[GCC_BLSP1_UART3_APPS_CLK] = &gcc_blsp1_uart3_apps_clk.clkr,
++	[GCC_BLSP1_UART4_APPS_CLK] = &gcc_blsp1_uart4_apps_clk.clkr,
++	[GCC_BLSP1_UART5_APPS_CLK] = &gcc_blsp1_uart5_apps_clk.clkr,
++	[GCC_BLSP1_UART6_APPS_CLK] = &gcc_blsp1_uart6_apps_clk.clkr,
++	[PCIE0_AXI_M_CLK_SRC] = &pcie0_axi_m_clk_src.clkr,
++	[GCC_PCIE0_AXI_M_CLK] = &gcc_pcie0_axi_m_clk.clkr,
++	[PCIE1_AXI_M_CLK_SRC] = &pcie1_axi_m_clk_src.clkr,
++	[GCC_PCIE1_AXI_M_CLK] = &gcc_pcie1_axi_m_clk.clkr,
++	[PCIE2_AXI_M_CLK_SRC] = &pcie2_axi_m_clk_src.clkr,
++	[GCC_PCIE2_AXI_M_CLK] = &gcc_pcie2_axi_m_clk.clkr,
++	[PCIE3_AXI_M_CLK_SRC] = &pcie3_axi_m_clk_src.clkr,
++	[GCC_PCIE3_AXI_M_CLK] = &gcc_pcie3_axi_m_clk.clkr,
++	[PCIE0_AXI_S_CLK_SRC] = &pcie0_axi_s_clk_src.clkr,
++	[GCC_PCIE0_AXI_S_BRIDGE_CLK] = &gcc_pcie0_axi_s_bridge_clk.clkr,
++	[GCC_PCIE0_AXI_S_CLK] = &gcc_pcie0_axi_s_clk.clkr,
++	[PCIE1_AXI_S_CLK_SRC] = &pcie1_axi_s_clk_src.clkr,
++	[GCC_PCIE1_AXI_S_BRIDGE_CLK] = &gcc_pcie1_axi_s_bridge_clk.clkr,
++	[GCC_PCIE1_AXI_S_CLK] = &gcc_pcie1_axi_s_clk.clkr,
++	[PCIE2_AXI_S_CLK_SRC] = &pcie2_axi_s_clk_src.clkr,
++	[GCC_PCIE2_AXI_S_BRIDGE_CLK] = &gcc_pcie2_axi_s_bridge_clk.clkr,
++	[GCC_PCIE2_AXI_S_CLK] = &gcc_pcie2_axi_s_clk.clkr,
++	[PCIE3_AXI_S_CLK_SRC] = &pcie3_axi_s_clk_src.clkr,
++	[GCC_PCIE3_AXI_S_BRIDGE_CLK] = &gcc_pcie3_axi_s_bridge_clk.clkr,
++	[GCC_PCIE3_AXI_S_CLK] = &gcc_pcie3_axi_s_clk.clkr,
++	[PCIE0_PIPE_CLK_SRC] = &pcie0_pipe_clk_src.clkr,
++	[PCIE1_PIPE_CLK_SRC] = &pcie1_pipe_clk_src.clkr,
++	[PCIE2_PIPE_CLK_SRC] = &pcie2_pipe_clk_src.clkr,
++	[PCIE3_PIPE_CLK_SRC] = &pcie3_pipe_clk_src.clkr,
++	[PCIE_AUX_CLK_SRC] = &pcie_aux_clk_src.clkr,
++	[GCC_PCIE0_AUX_CLK] = &gcc_pcie0_aux_clk.clkr,
++	[GCC_PCIE1_AUX_CLK] = &gcc_pcie1_aux_clk.clkr,
++	[GCC_PCIE2_AUX_CLK] = &gcc_pcie2_aux_clk.clkr,
++	[GCC_PCIE3_AUX_CLK] = &gcc_pcie3_aux_clk.clkr,
++	[PCIE0_RCHNG_CLK_SRC] = &pcie0_rchng_clk_src.clkr,
++	[GCC_PCIE0_RCHNG_CLK] = &gcc_pcie0_rchng_clk.clkr,
++	[PCIE1_RCHNG_CLK_SRC] = &pcie1_rchng_clk_src.clkr,
++	[GCC_PCIE1_RCHNG_CLK] = &gcc_pcie1_rchng_clk.clkr,
++	[PCIE2_RCHNG_CLK_SRC] = &pcie2_rchng_clk_src.clkr,
++	[GCC_PCIE2_RCHNG_CLK] = &gcc_pcie2_rchng_clk.clkr,
++	[PCIE3_RCHNG_CLK_SRC] = &pcie3_rchng_clk_src.clkr,
++	[GCC_PCIE3_RCHNG_CLK] = &gcc_pcie3_rchng_clk.clkr,
++	[GCC_PCIE0_AHB_CLK] = &gcc_pcie0_ahb_clk.clkr,
++	[GCC_PCIE1_AHB_CLK] = &gcc_pcie1_ahb_clk.clkr,
++	[GCC_PCIE2_AHB_CLK] = &gcc_pcie2_ahb_clk.clkr,
++	[GCC_PCIE3_AHB_CLK] = &gcc_pcie3_ahb_clk.clkr,
++	[USB0_AUX_CLK_SRC] = &usb0_aux_clk_src.clkr,
++	[GCC_USB0_AUX_CLK] = &gcc_usb0_aux_clk.clkr,
++	[USB0_MASTER_CLK_SRC] = &usb0_master_clk_src.clkr,
++	[GCC_USB0_MASTER_CLK] = &gcc_usb0_master_clk.clkr,
++	[GCC_SNOC_USB_CLK] = &gcc_snoc_usb_clk.clkr,
++	[GCC_ANOC_USB_AXI_CLK] = &gcc_anoc_usb_axi_clk.clkr,
++	[USB0_MOCK_UTMI_CLK_SRC] = &usb0_mock_utmi_clk_src.clkr,
++	[USB0_MOCK_UTMI_DIV_CLK_SRC] = &usb0_mock_utmi_div_clk_src.clkr,
++	[GCC_USB0_MOCK_UTMI_CLK] = &gcc_usb0_mock_utmi_clk.clkr,
++	[USB0_PIPE_CLK_SRC] = &usb0_pipe_clk_src.clkr,
++	[GCC_USB0_PHY_CFG_AHB_CLK] = &gcc_usb0_phy_cfg_ahb_clk.clkr,
++	[SDCC1_APPS_CLK_SRC] = &sdcc1_apps_clk_src.clkr,
++	[GCC_SDCC1_APPS_CLK] = &gcc_sdcc1_apps_clk.clkr,
++	[SDCC1_ICE_CORE_CLK_SRC] = &sdcc1_ice_core_clk_src.clkr,
++	[GCC_SDCC1_ICE_CORE_CLK] = &gcc_sdcc1_ice_core_clk.clkr,
++	[GCC_SDCC1_AHB_CLK] = &gcc_sdcc1_ahb_clk.clkr,
++	[PCNOC_BFDCD_CLK_SRC] = &pcnoc_bfdcd_clk_src.clkr,
++	[GCC_NSSCFG_CLK] = &gcc_nsscfg_clk.clkr,
++	[GCC_NSSNOC_NSSCC_CLK] = &gcc_nssnoc_nsscc_clk.clkr,
++	[GCC_NSSCC_CLK] = &gcc_nsscc_clk.clkr,
++	[GCC_NSSNOC_PCNOC_1_CLK] = &gcc_nssnoc_pcnoc_1_clk.clkr,
++	[GCC_QDSS_DAP_AHB_CLK] = &gcc_qdss_dap_ahb_clk.clkr,
++	[GCC_QDSS_CFG_AHB_CLK] = &gcc_qdss_cfg_ahb_clk.clkr,
++	[GCC_QPIC_AHB_CLK] = &gcc_qpic_ahb_clk.clkr,
++	[GCC_QPIC_CLK] = &gcc_qpic_clk.clkr,
++	[GCC_BLSP1_AHB_CLK] = &gcc_blsp1_ahb_clk.clkr,
++	[GCC_MDIO_AHB_CLK] = &gcc_mdio_ahb_clk.clkr,
++	[GCC_PRNG_AHB_CLK] = &gcc_prng_ahb_clk.clkr,
++	[GCC_UNIPHY0_AHB_CLK] = &gcc_uniphy0_ahb_clk.clkr,
++	[GCC_UNIPHY1_AHB_CLK] = &gcc_uniphy1_ahb_clk.clkr,
++	[GCC_UNIPHY2_AHB_CLK] = &gcc_uniphy2_ahb_clk.clkr,
++	[GCC_CMN_12GPLL_AHB_CLK] = &gcc_cmn_12gpll_ahb_clk.clkr,
++	[GCC_CMN_12GPLL_APU_CLK] = &gcc_cmn_12gpll_apu_clk.clkr,
++	[SYSTEM_NOC_BFDCD_CLK_SRC] = &system_noc_bfdcd_clk_src.clkr,
++	[GCC_NSSNOC_SNOC_CLK] = &gcc_nssnoc_snoc_clk.clkr,
++	[GCC_NSSNOC_SNOC_1_CLK] = &gcc_nssnoc_snoc_1_clk.clkr,
++	[GCC_QDSS_ETR_USB_CLK] = &gcc_qdss_etr_usb_clk.clkr,
++	[WCSS_AHB_CLK_SRC] = &wcss_ahb_clk_src.clkr,
++	[GCC_Q6_AHB_CLK] = &gcc_q6_ahb_clk.clkr,
++	[GCC_Q6_AHB_S_CLK] = &gcc_q6_ahb_s_clk.clkr,
++	[GCC_WCSS_ECAHB_CLK] = &gcc_wcss_ecahb_clk.clkr,
++	[GCC_WCSS_ACMT_CLK] = &gcc_wcss_acmt_clk.clkr,
++	[GCC_SYS_NOC_WCSS_AHB_CLK] = &gcc_sys_noc_wcss_ahb_clk.clkr,
++	[WCSS_AXI_M_CLK_SRC] = &wcss_axi_m_clk_src.clkr,
++	[GCC_ANOC_WCSS_AXI_M_CLK] = &gcc_anoc_wcss_axi_m_clk.clkr,
++	[QDSS_AT_CLK_SRC] = &qdss_at_clk_src.clkr,
++	[GCC_Q6SS_ATBM_CLK] = &gcc_q6ss_atbm_clk.clkr,
++	[GCC_WCSS_DBG_IFC_ATB_CLK] = &gcc_wcss_dbg_ifc_atb_clk.clkr,
++	[GCC_NSSNOC_ATB_CLK] = &gcc_nssnoc_atb_clk.clkr,
++	[GCC_QDSS_AT_CLK] = &gcc_qdss_at_clk.clkr,
++	[GCC_SYS_NOC_AT_CLK] = &gcc_sys_noc_at_clk.clkr,
++	[GCC_PCNOC_AT_CLK] = &gcc_pcnoc_at_clk.clkr,
++	[GCC_USB0_EUD_AT_CLK] = &gcc_usb0_eud_at_clk.clkr,
++	[GCC_QDSS_EUD_AT_CLK] = &gcc_qdss_eud_at_clk.clkr,
++	[QDSS_STM_CLK_SRC] = &qdss_stm_clk_src.clkr,
++	[GCC_QDSS_STM_CLK] = &gcc_qdss_stm_clk.clkr,
++	[GCC_SYS_NOC_QDSS_STM_AXI_CLK] = &gcc_sys_noc_qdss_stm_axi_clk.clkr,
++	[QDSS_TRACECLKIN_CLK_SRC] = &qdss_traceclkin_clk_src.clkr,
++	[GCC_QDSS_TRACECLKIN_CLK] = &gcc_qdss_traceclkin_clk.clkr,
++	[QDSS_TSCTR_CLK_SRC] = &qdss_tsctr_clk_src.clkr,
++	[GCC_Q6_TSCTR_1TO2_CLK] = &gcc_q6_tsctr_1to2_clk.clkr,
++	[GCC_WCSS_DBG_IFC_NTS_CLK] = &gcc_wcss_dbg_ifc_nts_clk.clkr,
++	[GCC_QDSS_TSCTR_DIV2_CLK] = &gcc_qdss_tsctr_div2_clk.clkr,
++	[GCC_QDSS_TS_CLK] = &gcc_qdss_ts_clk.clkr,
++	[GCC_QDSS_TSCTR_DIV4_CLK] = &gcc_qdss_tsctr_div4_clk.clkr,
++	[GCC_NSS_TS_CLK] = &gcc_nss_ts_clk.clkr,
++	[GCC_QDSS_TSCTR_DIV8_CLK] = &gcc_qdss_tsctr_div8_clk.clkr,
++	[GCC_QDSS_TSCTR_DIV16_CLK] = &gcc_qdss_tsctr_div16_clk.clkr,
++	[GCC_Q6SS_PCLKDBG_CLK] = &gcc_q6ss_pclkdbg_clk.clkr,
++	[GCC_Q6SS_TRIG_CLK] = &gcc_q6ss_trig_clk.clkr,
++	[GCC_WCSS_DBG_IFC_APB_CLK] = &gcc_wcss_dbg_ifc_apb_clk.clkr,
++	[GCC_WCSS_DBG_IFC_DAPBUS_CLK] = &gcc_wcss_dbg_ifc_dapbus_clk.clkr,
++	[GCC_QDSS_DAP_CLK] = &gcc_qdss_dap_clk.clkr,
++	[GCC_QDSS_APB2JTAG_CLK] = &gcc_qdss_apb2jtag_clk.clkr,
++	[GCC_QDSS_TSCTR_DIV3_CLK] = &gcc_qdss_tsctr_div3_clk.clkr,
++	[QPIC_IO_MACRO_CLK_SRC] = &qpic_io_macro_clk_src.clkr,
++	[GCC_QPIC_IO_MACRO_CLK] = &gcc_qpic_io_macro_clk.clkr,
++	[Q6_AXI_CLK_SRC] = &q6_axi_clk_src.clkr,
++	[GCC_Q6_AXIM_CLK] = &gcc_q6_axim_clk.clkr,
++	[GCC_WCSS_Q6_TBU_CLK] = &gcc_wcss_q6_tbu_clk.clkr,
++	[GCC_MEM_NOC_Q6_AXI_CLK] = &gcc_mem_noc_q6_axi_clk.clkr,
++	[Q6_AXIM2_CLK_SRC] = &q6_axim2_clk_src.clkr,
++	[NSSNOC_MEMNOC_BFDCD_CLK_SRC] = &nssnoc_memnoc_bfdcd_clk_src.clkr,
++	[GCC_NSSNOC_MEMNOC_CLK] = &gcc_nssnoc_memnoc_clk.clkr,
++	[GCC_NSSNOC_MEM_NOC_1_CLK] = &gcc_nssnoc_mem_noc_1_clk.clkr,
++	[GCC_NSS_TBU_CLK] = &gcc_nss_tbu_clk.clkr,
++	[GCC_MEM_NOC_NSSNOC_CLK] = &gcc_mem_noc_nssnoc_clk.clkr,
++	[LPASS_AXIM_CLK_SRC] = &lpass_axim_clk_src.clkr,
++	[LPASS_SWAY_CLK_SRC] = &lpass_sway_clk_src.clkr,
++	[ADSS_PWM_CLK_SRC] = &adss_pwm_clk_src.clkr,
++	[GCC_ADSS_PWM_CLK] = &gcc_adss_pwm_clk.clkr,
++	[GP1_CLK_SRC] = &gp1_clk_src.clkr,
++	[GP2_CLK_SRC] = &gp2_clk_src.clkr,
++	[GP3_CLK_SRC] = &gp3_clk_src.clkr,
++	[GCC_XO_CLK_SRC] = &gcc_xo_clk_src.clkr,
++	[GCC_NSSNOC_XO_DCD_CLK] = &gcc_nssnoc_xo_dcd_clk.clkr,
++	[GCC_XO_CLK] = &gcc_xo_clk.clkr,
++	[GCC_NSSNOC_QOSGEN_REF_CLK] = &gcc_nssnoc_qosgen_ref_clk.clkr,
++	[GCC_NSSNOC_TIMEOUT_REF_CLK] = &gcc_nssnoc_timeout_ref_clk.clkr,
++	[GCC_XO_DIV4_CLK] = &gcc_xo_div4_clk.clkr,
++	[GCC_UNIPHY0_SYS_CLK] = &gcc_uniphy0_sys_clk.clkr,
++	[GCC_UNIPHY1_SYS_CLK] = &gcc_uniphy1_sys_clk.clkr,
++	[GCC_UNIPHY2_SYS_CLK] = &gcc_uniphy2_sys_clk.clkr,
++	[GCC_CMN_12GPLL_SYS_CLK] = &gcc_cmn_12gpll_sys_clk.clkr,
++	[GCC_Q6SS_BOOT_CLK] = &gcc_q6ss_boot_clk.clkr,
++	[UNIPHY_SYS_CLK_SRC] = &uniphy_sys_clk_src.clkr,
++	[NSS_TS_CLK_SRC] = &nss_ts_clk_src.clkr,
++	[GCC_ANOC_PCIE0_1LANE_M_CLK] = &gcc_anoc_pcie0_1lane_m_clk.clkr,
++	[GCC_ANOC_PCIE1_1LANE_M_CLK] = &gcc_anoc_pcie1_1lane_m_clk.clkr,
++	[GCC_ANOC_PCIE2_2LANE_M_CLK] = &gcc_anoc_pcie2_2lane_m_clk.clkr,
++	[GCC_ANOC_PCIE3_2LANE_M_CLK] = &gcc_anoc_pcie3_2lane_m_clk.clkr,
++	[GCC_SNOC_PCIE0_1LANE_S_CLK] = &gcc_snoc_pcie0_1lane_s_clk.clkr,
++	[GCC_SNOC_PCIE1_1LANE_S_CLK] = &gcc_snoc_pcie1_1lane_s_clk.clkr,
++	[GCC_SNOC_PCIE2_2LANE_S_CLK] = &gcc_snoc_pcie2_2lane_s_clk.clkr,
++	[GCC_SNOC_PCIE3_2LANE_S_CLK] = &gcc_snoc_pcie3_2lane_s_clk.clkr,
++};
++
++static const struct qcom_reset_map gcc_ipq9574_resets[] = {
++	[GCC_ADSS_BCR] = { 0x1c000, 0 },
++	[GCC_ANOC0_TBU_BCR] = { 0x1203c, 0 },
++	[GCC_ANOC1_TBU_BCR] = { 0x1204c, 0 },
++	[GCC_ANOC_BCR] = { 0x2e074, 0 },
++	[GCC_APC0_VOLTAGE_DROOP_DETECTOR_BCR] = { 0x38000, 0 },
++	[GCC_APSS_TCU_BCR] = { 0x12014, 0 },
++	[GCC_BLSP1_BCR] = { 0x01000, 0 },
++	[GCC_BLSP1_QUP1_BCR] = { 0x02000, 0 },
++	[GCC_BLSP1_QUP2_BCR] = { 0x03000, 0 },
++	[GCC_BLSP1_QUP3_BCR] = { 0x04000, 0 },
++	[GCC_BLSP1_QUP4_BCR] = { 0x05000, 0 },
++	[GCC_BLSP1_QUP5_BCR] = { 0x06000, 0 },
++	[GCC_BLSP1_QUP6_BCR] = { 0x07000, 0 },
++	[GCC_BLSP1_UART1_BCR] = { 0x02028, 0 },
++	[GCC_BLSP1_UART2_BCR] = { 0x03028, 0 },
++	[GCC_BLSP1_UART3_BCR] = { 0x04028, 0 },
++	[GCC_BLSP1_UART4_BCR] = { 0x05028, 0 },
++	[GCC_BLSP1_UART5_BCR] = { 0x06028, 0 },
++	[GCC_BLSP1_UART6_BCR] = { 0x07028, 0 },
++	[GCC_BOOT_ROM_BCR] = { 0x13028, 0 },
++	[GCC_CMN_BLK_BCR] = { 0x3a000, 0 },
++	[GCC_CMN_BLK_AHB_ARES] = { 0x3a010, 0 },
++	[GCC_CMN_BLK_SYS_ARES] = { 0x3a010, 1 },
++	[GCC_CMN_BLK_APU_ARES] = { 0x3a010, 2 },
++	[GCC_DCC_BCR] = { 0x35000, 0 },
++	[GCC_DDRSS_BCR] = { 0x11000, 0 },
++	[GCC_IMEM_BCR] = { 0x0e000, 0 },
++	[GCC_LPASS_BCR] = { 0x27000, 0 },
++	[GCC_MDIO_BCR] = { 0x1703c, 0 },
++	[GCC_MPM_BCR] = { 0x37000, 0 },
++	[GCC_MSG_RAM_BCR] = { 0x26000, 0 },
++	[GCC_NSS_BCR] = { 0x17000, 0 },
++	[GCC_NSS_TBU_BCR] = { 0x12044, 0 },
++	[GCC_NSSNOC_MEMNOC_1_ARES] = { 0x17038, 13 },
++	[GCC_NSSNOC_PCNOC_1_ARES] = { 0x17038, 12 },
++	[GCC_NSSNOC_SNOC_1_ARES] = { 0x17038,  11 },
++	[GCC_NSSNOC_XO_DCD_ARES] = { 0x17038,  10 },
++	[GCC_NSSNOC_TS_ARES] = { 0x17038, 9 },
++	[GCC_NSSCC_ARES] = { 0x17038, 8 },
++	[GCC_NSSNOC_NSSCC_ARES] = { 0x17038, 7 },
++	[GCC_NSSNOC_ATB_ARES] = { 0x17038, 6 },
++	[GCC_NSSNOC_MEMNOC_ARES] = { 0x17038, 5 },
++	[GCC_NSSNOC_QOSGEN_REF_ARES] = { 0x17038, 4 },
++	[GCC_NSSNOC_SNOC_ARES] = { 0x17038, 3 },
++	[GCC_NSSNOC_TIMEOUT_REF_ARES] = { 0x17038, 2 },
++	[GCC_NSS_CFG_ARES] = { 0x17038, 1 },
++	[GCC_UBI0_DBG_ARES] = { 0x17038, 0 },
++	[GCC_PCIE0PHY_PHY_BCR] = { 0x2805c, 0 },
++	[GCC_PCIE0_AHB_ARES] = { 0x28058, 7 },
++	[GCC_PCIE0_AUX_ARES] = { 0x28058, 6 },
++	[GCC_PCIE0_AXI_M_ARES] = { 0x28058, 5 },
++	[GCC_PCIE0_AXI_M_STICKY_ARES] = { 0x28058, 4 },
++	[GCC_PCIE0_AXI_S_ARES] = { 0x28058, 3 },
++	[GCC_PCIE0_AXI_S_STICKY_ARES] = { 0x28058, 2 },
++	[GCC_PCIE0_CORE_STICKY_ARES] = { 0x28058, 1 },
++	[GCC_PCIE0_PIPE_ARES] = { 0x28058, 0 },
++	[GCC_PCIE1_AHB_ARES] = { 0x29058, 7 },
++	[GCC_PCIE1_AUX_ARES] = { 0x29058, 6 },
++	[GCC_PCIE1_AXI_M_ARES] = { 0x29058, 5 },
++	[GCC_PCIE1_AXI_M_STICKY_ARES] = { 0x29058, 4 },
++	[GCC_PCIE1_AXI_S_ARES] = { 0x29058, 3 },
++	[GCC_PCIE1_AXI_S_STICKY_ARES] = { 0x29058, 2 },
++	[GCC_PCIE1_CORE_STICKY_ARES] = { 0x29058, 1 },
++	[GCC_PCIE1_PIPE_ARES] = { 0x29058, 0 },
++	[GCC_PCIE2_AHB_ARES] = { 0x2a058, 7 },
++	[GCC_PCIE2_AUX_ARES] = { 0x2a058, 6 },
++	[GCC_PCIE2_AXI_M_ARES] = { 0x2a058, 5 },
++	[GCC_PCIE2_AXI_M_STICKY_ARES] = { 0x2a058, 4 },
++	[GCC_PCIE2_AXI_S_ARES] = { 0x2a058, 3 },
++	[GCC_PCIE2_AXI_S_STICKY_ARES] = { 0x2a058, 2 },
++	[GCC_PCIE2_CORE_STICKY_ARES] = { 0x2a058, 1 },
++	[GCC_PCIE2_PIPE_ARES] = { 0x2a058, 0 },
++	[GCC_PCIE3_AHB_ARES] = { 0x2b058, 7 },
++	[GCC_PCIE3_AUX_ARES] = { 0x2b058, 6 },
++	[GCC_PCIE3_AXI_M_ARES] = { 0x2b058, 5 },
++	[GCC_PCIE3_AXI_M_STICKY_ARES] = { 0x2b058, 4 },
++	[GCC_PCIE3_AXI_S_ARES] = { 0x2b058, 3 },
++	[GCC_PCIE3_AXI_S_STICKY_ARES] = { 0x2b058, 2 },
++	[GCC_PCIE3_CORE_STICKY_ARES] = { 0x2b058, 1 },
++	[GCC_PCIE3_PIPE_ARES] = { 0x2b058, 0 },
++	[GCC_PCIE0_BCR] = { 0x28000, 0 },
++	[GCC_PCIE0_LINK_DOWN_BCR] = { 0x28054, 0 },
++	[GCC_PCIE0_PHY_BCR] = { 0x28060, 0 },
++	[GCC_PCIE1_BCR] = { 0x29000, 0 },
++	[GCC_PCIE1_LINK_DOWN_BCR] = { 0x29054, 0 },
++	[GCC_PCIE1_PHY_BCR] = { 0x29060, 0 },
++	[GCC_PCIE1PHY_PHY_BCR] = { 0x2905c, 0 },
++	[GCC_PCIE2_BCR] = { 0x2a000, 0 },
++	[GCC_PCIE2_LINK_DOWN_BCR] = { 0x2a054, 0 },
++	[GCC_PCIE2_PHY_BCR] = { 0x2a060, 0 },
++	[GCC_PCIE2PHY_PHY_BCR] = { 0x2a05c, 0 },
++	[GCC_PCIE3_BCR] = { 0x2b000, 0 },
++	[GCC_PCIE3_LINK_DOWN_BCR] = { 0x2b054, 0 },
++	[GCC_PCIE3PHY_PHY_BCR] = { 0x2b05c, 0 },
++	[GCC_PCIE3_PHY_BCR] = { 0x2b060, 0 },
++	[GCC_PCNOC_BCR] = { 0x31000, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT0_BCR] = { 0x31030, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT1_BCR] = { 0x31038, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT2_BCR] = { 0x31040, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT3_BCR] = { 0x31048, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT4_BCR] = { 0x31050, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT5_BCR] = { 0x31058, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT6_BCR] = { 0x31060, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT7_BCR] = { 0x31068, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT8_BCR] = { 0x31070, 0 },
++	[GCC_PCNOC_BUS_TIMEOUT9_BCR] = { 0x31078, 0 },
++	[GCC_PCNOC_TBU_BCR] = { 0x12034, 0 },
++	[GCC_PRNG_BCR] = { 0x13020, 0 },
++	[GCC_Q6SS_DBG_ARES] = { 0x2506c, 4 },
++	[GCC_Q6_AHB_ARES] = { 0x2506c, 3 },
++	[GCC_Q6_AHB_S_ARES] = { 0x2506c, 2 },
++	[GCC_Q6_AXIM2_ARES] = { 0x2506c, 1 },
++	[GCC_Q6_AXIM_ARES] = { 0x2506c, 0 },
++	[GCC_QDSS_BCR] = { 0x2d000, 0 },
++	[GCC_QPIC_BCR] = { 0x32000, 0 },
++	[GCC_QPIC_AHB_ARES] = { 0x3201c, 1 },
++	[GCC_QPIC_ARES] = { 0x3201c, 0 },
++	[GCC_QUSB2_0_PHY_BCR] = { 0x2c068, 0 },
++	[GCC_RBCPR_BCR] = { 0x39000, 0 },
++	[GCC_RBCPR_MX_BCR] = { 0x39014, 0 },
++	[GCC_SDCC_BCR] = { 0x33000, 0 },
++	[GCC_SEC_CTRL_BCR] = { 0x1a000, 0 },
++	[GCC_SMMU_CFG_BCR] = { 0x1202c, 0 },
++	[GCC_SNOC_BCR] = { 0x2e000, 0 },
++	[GCC_SPDM_BCR] = { 0x36000, 0 },
++	[GCC_TCSR_BCR] = { 0x3d000, 0 },
++	[GCC_TLMM_BCR] = { 0x3e000, 0 },
++	[GCC_TME_BCR] = { 0x10000, 0 },
++	[GCC_UNIPHY0_BCR] = { 0x17044, 0 },
++	[GCC_UNIPHY0_SYS_RESET] = { 0x17050, 0 },
++	[GCC_UNIPHY0_AHB_RESET] = { 0x17050, 1 },
++	[GCC_UNIPHY0_XPCS_RESET] = { 0x17050, 2 },
++	[GCC_UNIPHY1_SYS_RESET] = { 0x17060, 0 },
++	[GCC_UNIPHY1_AHB_RESET] = { 0x17060, 1 },
++	[GCC_UNIPHY1_XPCS_RESET] = { 0x17060, 2 },
++	[GCC_UNIPHY2_SYS_RESET] = { 0x17070, 0 },
++	[GCC_UNIPHY2_AHB_RESET] = { 0x17070, 1 },
++	[GCC_UNIPHY2_XPCS_RESET] = { 0x17070, 2 },
++	[GCC_UNIPHY1_BCR] = { 0x17054, 0 },
++	[GCC_UNIPHY2_BCR] = { 0x17064, 0 },
++	[GCC_USB0_PHY_BCR] = { 0x2c06c, 0 },
++	[GCC_USB3PHY_0_PHY_BCR] = { 0x2c070, 0 },
++	[GCC_USB_BCR] = { 0x2c000, 0 },
++	[GCC_USB_MISC_RESET] = { 0x2c064, 0 },
++	[GCC_WCSSAON_RESET] = { 0x25074, 0 },
++	[GCC_WCSS_ACMT_ARES] = { 0x25070, 5 },
++	[GCC_WCSS_AHB_S_ARES] = { 0x25070, 4 },
++	[GCC_WCSS_AXI_M_ARES] = { 0x25070, 3 },
++	[GCC_WCSS_BCR] = { 0x18004, 0 },
++	[GCC_WCSS_DBG_ARES] = { 0x25070, 2 },
++	[GCC_WCSS_DBG_BDG_ARES] = { 0x25070, 1 },
++	[GCC_WCSS_ECAHB_ARES] = { 0x25070, 0 },
++	[GCC_WCSS_Q6_BCR] = { 0x18000, 0 },
++	[GCC_WCSS_Q6_TBU_BCR] = { 0x12054, 0 },
++};
++
++static const struct of_device_id gcc_ipq9574_match_table[] = {
++	{ .compatible = "qcom,ipq9574-gcc" },
++	{ }
++};
++MODULE_DEVICE_TABLE(of, gcc_ipq9574_match_table);
++
++static const struct regmap_config gcc_ipq9574_regmap_config = {
++	.reg_bits       = 32,
++	.reg_stride     = 4,
++	.val_bits       = 32,
++	.max_register   = 0x7fffc,
++	.fast_io	= true,
++};
++
++static const struct qcom_cc_desc gcc_ipq9574_desc = {
++	.config = &gcc_ipq9574_regmap_config,
++	.clks = gcc_ipq9574_clks,
++	.num_clks = ARRAY_SIZE(gcc_ipq9574_clks),
++	.resets = gcc_ipq9574_resets,
++	.num_resets = ARRAY_SIZE(gcc_ipq9574_resets),
++	.clk_hws = gcc_ipq9574_hws,
++	.num_clk_hws = ARRAY_SIZE(gcc_ipq9574_hws),
++};
++
++static int gcc_ipq9574_probe(struct platform_device *pdev)
++{
++	return qcom_cc_probe(pdev, &gcc_ipq9574_desc);
++}
++
++static struct platform_driver gcc_ipq9574_driver = {
++	.probe = gcc_ipq9574_probe,
++	.driver = {
++		.name   = "qcom,gcc-ipq9574",
++		.of_match_table = gcc_ipq9574_match_table,
++	},
++};
++
++static int __init gcc_ipq9574_init(void)
++{
++	return platform_driver_register(&gcc_ipq9574_driver);
++}
++core_initcall(gcc_ipq9574_init);
++
++static void __exit gcc_ipq9574_exit(void)
++{
++	platform_driver_unregister(&gcc_ipq9574_driver);
++}
++module_exit(gcc_ipq9574_exit);
++
++MODULE_DESCRIPTION("Qualcomm Technologies, Inc. GCC IPQ9574 Driver");
++MODULE_LICENSE("GPL");
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0008-dt-bindings-clock-Add-ipq9574-clock-and-reset-defini.patch b/target/linux/ipq95xx/patches-6.1/0008-dt-bindings-clock-Add-ipq9574-clock-and-reset-defini.patch
new file mode 100644
index 0000000000..abdea2ab2b
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0008-dt-bindings-clock-Add-ipq9574-clock-and-reset-defini.patch
@@ -0,0 +1,482 @@
+From 471b2c31ee9c3a0ab76f9ccb6a514cb9713afd80 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 16 Mar 2023 12:59:35 +0530
+Subject: [PATCH 08/41] dt-bindings: clock: Add ipq9574 clock and reset
+ definitions
+
+Add clock and reset ID definitions for ipq9574
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Co-developed-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230316072940.29137-2-quic_devipriy@quicinc.com
+---
+ .../bindings/clock/qcom,ipq9574-gcc.yaml      |  61 +++++
+ include/dt-bindings/clock/qcom,ipq9574-gcc.h  | 213 ++++++++++++++++++
+ include/dt-bindings/reset/qcom,ipq9574-gcc.h  | 164 ++++++++++++++
+ 3 files changed, 438 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/clock/qcom,ipq9574-gcc.yaml
+ create mode 100644 include/dt-bindings/clock/qcom,ipq9574-gcc.h
+ create mode 100644 include/dt-bindings/reset/qcom,ipq9574-gcc.h
+
+diff --git a/Documentation/devicetree/bindings/clock/qcom,ipq9574-gcc.yaml b/Documentation/devicetree/bindings/clock/qcom,ipq9574-gcc.yaml
+new file mode 100644
+index 000000000000..afc68eb9d7cc
+--- /dev/null
++++ b/Documentation/devicetree/bindings/clock/qcom,ipq9574-gcc.yaml
+@@ -0,0 +1,61 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/clock/qcom,ipq9574-gcc.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Qualcomm Global Clock & Reset Controller on IPQ9574
++
++maintainers:
++  - Anusha Rao <quic_anusha@quicinc.com>
++
++description: |
++  Qualcomm global clock control module provides the clocks, resets and power
++  domains on IPQ9574
++
++  See also::
++    include/dt-bindings/clock/qcom,ipq9574-gcc.h
++    include/dt-bindings/reset/qcom,ipq9574-gcc.h
++
++properties:
++  compatible:
++    const: qcom,ipq9574-gcc
++
++  clocks:
++    items:
++      - description: Board XO source
++      - description: Sleep clock source
++      - description: Bias PLL ubi clock source
++      - description: PCIE30 PHY0 pipe clock source
++      - description: PCIE30 PHY1 pipe clock source
++      - description: PCIE30 PHY2 pipe clock source
++      - description: PCIE30 PHY3 pipe clock source
++      - description: USB3 PHY pipe clock source
++
++required:
++  - compatible
++  - clocks
++
++allOf:
++  - $ref: qcom,gcc.yaml#
++
++unevaluatedProperties: false
++
++examples:
++  - |
++    clock-controller@1800000 {
++      compatible = "qcom,ipq9574-gcc";
++      reg = <0x01800000 0x80000>;
++      clocks = <&xo_board_clk>,
++               <&sleep_clk>,
++               <&bias_pll_ubi_nc_clk>,
++               <&pcie30_phy0_pipe_clk>,
++               <&pcie30_phy1_pipe_clk>,
++               <&pcie30_phy2_pipe_clk>,
++               <&pcie30_phy3_pipe_clk>,
++               <&usb3phy_0_cc_pipe_clk>;
++      #clock-cells = <1>;
++      #reset-cells = <1>;
++      #power-domain-cells = <1>;
++    };
++...
+diff --git a/include/dt-bindings/clock/qcom,ipq9574-gcc.h b/include/dt-bindings/clock/qcom,ipq9574-gcc.h
+new file mode 100644
+index 000000000000..5a2961bfe893
+--- /dev/null
++++ b/include/dt-bindings/clock/qcom,ipq9574-gcc.h
+@@ -0,0 +1,213 @@
++/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
++/*
++ * Copyright (c) 2018-2023 The Linux Foundation. All rights reserved.
++ */
++
++#ifndef _DT_BINDINGS_CLOCK_IPQ_GCC_9574_H
++#define _DT_BINDINGS_CLOCK_IPQ_GCC_9574_H
++
++#define GPLL0_MAIN					0
++#define GPLL0						1
++#define GPLL2_MAIN					2
++#define GPLL2						3
++#define GPLL4_MAIN					4
++#define GPLL4						5
++#define GCC_SLEEP_CLK_SRC				6
++#define APSS_AHB_CLK_SRC				7
++#define APSS_AXI_CLK_SRC				8
++#define BLSP1_QUP1_I2C_APPS_CLK_SRC			9
++#define BLSP1_QUP1_SPI_APPS_CLK_SRC			10
++#define BLSP1_QUP2_I2C_APPS_CLK_SRC			11
++#define BLSP1_QUP2_SPI_APPS_CLK_SRC			12
++#define BLSP1_QUP3_I2C_APPS_CLK_SRC			13
++#define BLSP1_QUP3_SPI_APPS_CLK_SRC			14
++#define BLSP1_QUP4_I2C_APPS_CLK_SRC			15
++#define BLSP1_QUP4_SPI_APPS_CLK_SRC			16
++#define BLSP1_QUP5_I2C_APPS_CLK_SRC			17
++#define BLSP1_QUP5_SPI_APPS_CLK_SRC			18
++#define BLSP1_QUP6_I2C_APPS_CLK_SRC			19
++#define BLSP1_QUP6_SPI_APPS_CLK_SRC			20
++#define BLSP1_UART1_APPS_CLK_SRC			21
++#define BLSP1_UART2_APPS_CLK_SRC			22
++#define BLSP1_UART3_APPS_CLK_SRC			23
++#define BLSP1_UART4_APPS_CLK_SRC			24
++#define BLSP1_UART5_APPS_CLK_SRC			25
++#define BLSP1_UART6_APPS_CLK_SRC			26
++#define GCC_APSS_AHB_CLK				27
++#define GCC_APSS_AXI_CLK				28
++#define GCC_BLSP1_QUP1_I2C_APPS_CLK			29
++#define GCC_BLSP1_QUP1_SPI_APPS_CLK			30
++#define GCC_BLSP1_QUP2_I2C_APPS_CLK			31
++#define GCC_BLSP1_QUP2_SPI_APPS_CLK			32
++#define GCC_BLSP1_QUP3_I2C_APPS_CLK			33
++#define GCC_BLSP1_QUP3_SPI_APPS_CLK			34
++#define GCC_BLSP1_QUP4_I2C_APPS_CLK			35
++#define GCC_BLSP1_QUP4_SPI_APPS_CLK			36
++#define GCC_BLSP1_QUP5_I2C_APPS_CLK			37
++#define GCC_BLSP1_QUP5_SPI_APPS_CLK			38
++#define GCC_BLSP1_QUP6_I2C_APPS_CLK			39
++#define GCC_BLSP1_QUP6_SPI_APPS_CLK			40
++#define GCC_BLSP1_UART1_APPS_CLK			41
++#define GCC_BLSP1_UART2_APPS_CLK			42
++#define GCC_BLSP1_UART3_APPS_CLK			43
++#define GCC_BLSP1_UART4_APPS_CLK			44
++#define GCC_BLSP1_UART5_APPS_CLK			45
++#define GCC_BLSP1_UART6_APPS_CLK			46
++#define PCIE0_AXI_M_CLK_SRC				47
++#define GCC_PCIE0_AXI_M_CLK				48
++#define PCIE1_AXI_M_CLK_SRC				49
++#define GCC_PCIE1_AXI_M_CLK				50
++#define PCIE2_AXI_M_CLK_SRC				51
++#define GCC_PCIE2_AXI_M_CLK				52
++#define PCIE3_AXI_M_CLK_SRC				53
++#define GCC_PCIE3_AXI_M_CLK				54
++#define PCIE0_AXI_S_CLK_SRC				55
++#define GCC_PCIE0_AXI_S_BRIDGE_CLK			56
++#define GCC_PCIE0_AXI_S_CLK				57
++#define PCIE1_AXI_S_CLK_SRC				58
++#define GCC_PCIE1_AXI_S_BRIDGE_CLK			59
++#define GCC_PCIE1_AXI_S_CLK				60
++#define PCIE2_AXI_S_CLK_SRC				61
++#define GCC_PCIE2_AXI_S_BRIDGE_CLK			62
++#define GCC_PCIE2_AXI_S_CLK				63
++#define PCIE3_AXI_S_CLK_SRC				64
++#define GCC_PCIE3_AXI_S_BRIDGE_CLK			65
++#define GCC_PCIE3_AXI_S_CLK				66
++#define PCIE0_PIPE_CLK_SRC				67
++#define PCIE1_PIPE_CLK_SRC				68
++#define PCIE2_PIPE_CLK_SRC				69
++#define PCIE3_PIPE_CLK_SRC				70
++#define PCIE_AUX_CLK_SRC				71
++#define GCC_PCIE0_AUX_CLK				72
++#define GCC_PCIE1_AUX_CLK				73
++#define GCC_PCIE2_AUX_CLK				74
++#define GCC_PCIE3_AUX_CLK				75
++#define PCIE0_RCHNG_CLK_SRC				76
++#define GCC_PCIE0_RCHNG_CLK				77
++#define PCIE1_RCHNG_CLK_SRC				78
++#define GCC_PCIE1_RCHNG_CLK				79
++#define PCIE2_RCHNG_CLK_SRC				80
++#define GCC_PCIE2_RCHNG_CLK				81
++#define PCIE3_RCHNG_CLK_SRC				82
++#define GCC_PCIE3_RCHNG_CLK				83
++#define GCC_PCIE0_AHB_CLK				84
++#define GCC_PCIE1_AHB_CLK				85
++#define GCC_PCIE2_AHB_CLK				86
++#define GCC_PCIE3_AHB_CLK				87
++#define USB0_AUX_CLK_SRC				88
++#define GCC_USB0_AUX_CLK				89
++#define USB0_MASTER_CLK_SRC				90
++#define GCC_USB0_MASTER_CLK				91
++#define GCC_SNOC_USB_CLK				92
++#define GCC_ANOC_USB_AXI_CLK				93
++#define USB0_MOCK_UTMI_CLK_SRC				94
++#define USB0_MOCK_UTMI_DIV_CLK_SRC			95
++#define GCC_USB0_MOCK_UTMI_CLK				96
++#define USB0_PIPE_CLK_SRC				97
++#define GCC_USB0_PHY_CFG_AHB_CLK			98
++#define SDCC1_APPS_CLK_SRC				99
++#define GCC_SDCC1_APPS_CLK				100
++#define SDCC1_ICE_CORE_CLK_SRC				101
++#define GCC_SDCC1_ICE_CORE_CLK				102
++#define GCC_SDCC1_AHB_CLK				103
++#define PCNOC_BFDCD_CLK_SRC				104
++#define GCC_NSSCFG_CLK					105
++#define GCC_NSSNOC_NSSCC_CLK				106
++#define GCC_NSSCC_CLK					107
++#define GCC_NSSNOC_PCNOC_1_CLK				108
++#define GCC_QDSS_DAP_AHB_CLK				109
++#define GCC_QDSS_CFG_AHB_CLK				110
++#define GCC_QPIC_AHB_CLK				111
++#define GCC_QPIC_CLK					112
++#define GCC_BLSP1_AHB_CLK				113
++#define GCC_MDIO_AHB_CLK				114
++#define GCC_PRNG_AHB_CLK				115
++#define GCC_UNIPHY0_AHB_CLK				116
++#define GCC_UNIPHY1_AHB_CLK				117
++#define GCC_UNIPHY2_AHB_CLK				118
++#define GCC_CMN_12GPLL_AHB_CLK				119
++#define GCC_CMN_12GPLL_APU_CLK				120
++#define SYSTEM_NOC_BFDCD_CLK_SRC			121
++#define GCC_NSSNOC_SNOC_CLK				122
++#define GCC_NSSNOC_SNOC_1_CLK				123
++#define GCC_QDSS_ETR_USB_CLK				124
++#define WCSS_AHB_CLK_SRC				125
++#define GCC_Q6_AHB_CLK					126
++#define GCC_Q6_AHB_S_CLK				127
++#define GCC_WCSS_ECAHB_CLK				128
++#define GCC_WCSS_ACMT_CLK				129
++#define GCC_SYS_NOC_WCSS_AHB_CLK			130
++#define WCSS_AXI_M_CLK_SRC				131
++#define GCC_ANOC_WCSS_AXI_M_CLK				132
++#define QDSS_AT_CLK_SRC					133
++#define GCC_Q6SS_ATBM_CLK				134
++#define GCC_WCSS_DBG_IFC_ATB_CLK			135
++#define GCC_NSSNOC_ATB_CLK				136
++#define GCC_QDSS_AT_CLK					137
++#define GCC_SYS_NOC_AT_CLK				138
++#define GCC_PCNOC_AT_CLK				139
++#define GCC_USB0_EUD_AT_CLK				140
++#define GCC_QDSS_EUD_AT_CLK				141
++#define QDSS_STM_CLK_SRC				142
++#define GCC_QDSS_STM_CLK				143
++#define GCC_SYS_NOC_QDSS_STM_AXI_CLK			144
++#define QDSS_TRACECLKIN_CLK_SRC				145
++#define GCC_QDSS_TRACECLKIN_CLK				146
++#define QDSS_TSCTR_CLK_SRC				147
++#define GCC_Q6_TSCTR_1TO2_CLK				148
++#define GCC_WCSS_DBG_IFC_NTS_CLK			149
++#define GCC_QDSS_TSCTR_DIV2_CLK				150
++#define GCC_QDSS_TS_CLK					151
++#define GCC_QDSS_TSCTR_DIV4_CLK				152
++#define GCC_NSS_TS_CLK					153
++#define GCC_QDSS_TSCTR_DIV8_CLK				154
++#define GCC_QDSS_TSCTR_DIV16_CLK			155
++#define GCC_Q6SS_PCLKDBG_CLK				156
++#define GCC_Q6SS_TRIG_CLK				157
++#define GCC_WCSS_DBG_IFC_APB_CLK			158
++#define GCC_WCSS_DBG_IFC_DAPBUS_CLK			159
++#define GCC_QDSS_DAP_CLK				160
++#define GCC_QDSS_APB2JTAG_CLK				161
++#define GCC_QDSS_TSCTR_DIV3_CLK				162
++#define QPIC_IO_MACRO_CLK_SRC				163
++#define GCC_QPIC_IO_MACRO_CLK                           164
++#define Q6_AXI_CLK_SRC					165
++#define GCC_Q6_AXIM_CLK					166
++#define GCC_WCSS_Q6_TBU_CLK				167
++#define GCC_MEM_NOC_Q6_AXI_CLK				168
++#define Q6_AXIM2_CLK_SRC				169
++#define NSSNOC_MEMNOC_BFDCD_CLK_SRC			170
++#define GCC_NSSNOC_MEMNOC_CLK				171
++#define GCC_NSSNOC_MEM_NOC_1_CLK			172
++#define GCC_NSS_TBU_CLK					173
++#define GCC_MEM_NOC_NSSNOC_CLK				174
++#define LPASS_AXIM_CLK_SRC				175
++#define LPASS_SWAY_CLK_SRC				176
++#define ADSS_PWM_CLK_SRC				177
++#define GCC_ADSS_PWM_CLK				178
++#define GP1_CLK_SRC					179
++#define GP2_CLK_SRC					180
++#define GP3_CLK_SRC					181
++#define DDRSS_SMS_SLOW_CLK_SRC				182
++#define GCC_XO_CLK_SRC					183
++#define GCC_XO_CLK					184
++#define GCC_NSSNOC_QOSGEN_REF_CLK			185
++#define GCC_NSSNOC_TIMEOUT_REF_CLK			186
++#define GCC_XO_DIV4_CLK					187
++#define GCC_UNIPHY0_SYS_CLK				188
++#define GCC_UNIPHY1_SYS_CLK				189
++#define GCC_UNIPHY2_SYS_CLK				190
++#define GCC_CMN_12GPLL_SYS_CLK				191
++#define GCC_NSSNOC_XO_DCD_CLK				192
++#define GCC_Q6SS_BOOT_CLK				193
++#define UNIPHY_SYS_CLK_SRC				194
++#define NSS_TS_CLK_SRC					195
++#define GCC_ANOC_PCIE0_1LANE_M_CLK			196
++#define GCC_ANOC_PCIE1_1LANE_M_CLK			197
++#define GCC_ANOC_PCIE2_2LANE_M_CLK			198
++#define GCC_ANOC_PCIE3_2LANE_M_CLK			199
++#define GCC_SNOC_PCIE0_1LANE_S_CLK			200
++#define GCC_SNOC_PCIE1_1LANE_S_CLK			201
++#define GCC_SNOC_PCIE2_2LANE_S_CLK			202
++#define GCC_SNOC_PCIE3_2LANE_S_CLK			203
++#endif
+diff --git a/include/dt-bindings/reset/qcom,ipq9574-gcc.h b/include/dt-bindings/reset/qcom,ipq9574-gcc.h
+new file mode 100644
+index 000000000000..d01dc6a24cf1
+--- /dev/null
++++ b/include/dt-bindings/reset/qcom,ipq9574-gcc.h
+@@ -0,0 +1,164 @@
++/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
++/*
++ * Copyright (c) 2018-2023, The Linux Foundation. All rights reserved.
++ */
++
++#ifndef _DT_BINDINGS_RESET_IPQ_GCC_9574_H
++#define _DT_BINDINGS_RESET_IPQ_GCC_9574_H
++
++#define GCC_ADSS_BCR						0
++#define GCC_APC0_VOLTAGE_DROOP_DETECTOR_BCR			1
++#define GCC_BLSP1_BCR						2
++#define GCC_BLSP1_QUP1_BCR					3
++#define GCC_BLSP1_QUP2_BCR					4
++#define GCC_BLSP1_QUP3_BCR					5
++#define GCC_BLSP1_QUP4_BCR					6
++#define GCC_BLSP1_QUP5_BCR					7
++#define GCC_BLSP1_QUP6_BCR					8
++#define GCC_BLSP1_UART1_BCR					9
++#define GCC_BLSP1_UART2_BCR					10
++#define GCC_BLSP1_UART3_BCR					11
++#define GCC_BLSP1_UART4_BCR					12
++#define GCC_BLSP1_UART5_BCR					13
++#define GCC_BLSP1_UART6_BCR					14
++#define GCC_BOOT_ROM_BCR					15
++#define GCC_MDIO_BCR						16
++#define GCC_NSS_BCR						17
++#define GCC_NSS_TBU_BCR						18
++#define GCC_PCIE0_BCR						19
++#define GCC_PCIE0_LINK_DOWN_BCR					20
++#define GCC_PCIE0_PHY_BCR					21
++#define GCC_PCIE0PHY_PHY_BCR					22
++#define GCC_PCIE1_BCR						23
++#define GCC_PCIE1_LINK_DOWN_BCR					24
++#define GCC_PCIE1_PHY_BCR					25
++#define GCC_PCIE1PHY_PHY_BCR					26
++#define GCC_PCIE2_BCR						27
++#define GCC_PCIE2_LINK_DOWN_BCR					28
++#define GCC_PCIE2_PHY_BCR					29
++#define GCC_PCIE2PHY_PHY_BCR					30
++#define GCC_PCIE3_BCR						31
++#define GCC_PCIE3_LINK_DOWN_BCR					32
++#define GCC_PCIE3_PHY_BCR					33
++#define GCC_PCIE3PHY_PHY_BCR					34
++#define GCC_PRNG_BCR						35
++#define GCC_QUSB2_0_PHY_BCR					36
++#define GCC_SDCC_BCR						37
++#define GCC_TLMM_BCR						38
++#define GCC_UNIPHY0_BCR						39
++#define GCC_UNIPHY1_BCR						40
++#define GCC_UNIPHY2_BCR						41
++#define GCC_USB0_PHY_BCR					42
++#define GCC_USB3PHY_0_PHY_BCR					43
++#define GCC_USB_BCR						44
++#define GCC_ANOC0_TBU_BCR					45
++#define GCC_ANOC1_TBU_BCR					46
++#define GCC_ANOC_BCR						47
++#define GCC_APSS_TCU_BCR					48
++#define GCC_CMN_BLK_BCR						49
++#define GCC_CMN_BLK_AHB_ARES					50
++#define GCC_CMN_BLK_SYS_ARES					51
++#define GCC_CMN_BLK_APU_ARES					52
++#define GCC_DCC_BCR						53
++#define GCC_DDRSS_BCR						54
++#define GCC_IMEM_BCR						55
++#define GCC_LPASS_BCR						56
++#define GCC_MPM_BCR						57
++#define GCC_MSG_RAM_BCR						58
++#define GCC_NSSNOC_MEMNOC_1_ARES				59
++#define GCC_NSSNOC_PCNOC_1_ARES					60
++#define GCC_NSSNOC_SNOC_1_ARES					61
++#define GCC_NSSNOC_XO_DCD_ARES					62
++#define GCC_NSSNOC_TS_ARES					63
++#define GCC_NSSCC_ARES						64
++#define GCC_NSSNOC_NSSCC_ARES					65
++#define GCC_NSSNOC_ATB_ARES					66
++#define GCC_NSSNOC_MEMNOC_ARES					67
++#define GCC_NSSNOC_QOSGEN_REF_ARES				68
++#define GCC_NSSNOC_SNOC_ARES					69
++#define GCC_NSSNOC_TIMEOUT_REF_ARES				70
++#define GCC_NSS_CFG_ARES					71
++#define GCC_UBI0_DBG_ARES					72
++#define GCC_PCIE0_AHB_ARES					73
++#define GCC_PCIE0_AUX_ARES					74
++#define GCC_PCIE0_AXI_M_ARES					75
++#define GCC_PCIE0_AXI_M_STICKY_ARES				76
++#define GCC_PCIE0_AXI_S_ARES					77
++#define GCC_PCIE0_AXI_S_STICKY_ARES				78
++#define GCC_PCIE0_CORE_STICKY_ARES				79
++#define GCC_PCIE0_PIPE_ARES					80
++#define GCC_PCIE1_AHB_ARES					81
++#define GCC_PCIE1_AUX_ARES					82
++#define GCC_PCIE1_AXI_M_ARES					83
++#define GCC_PCIE1_AXI_M_STICKY_ARES				84
++#define GCC_PCIE1_AXI_S_ARES					85
++#define GCC_PCIE1_AXI_S_STICKY_ARES				86
++#define GCC_PCIE1_CORE_STICKY_ARES				87
++#define GCC_PCIE1_PIPE_ARES					88
++#define GCC_PCIE2_AHB_ARES					89
++#define GCC_PCIE2_AUX_ARES					90
++#define GCC_PCIE2_AXI_M_ARES					91
++#define GCC_PCIE2_AXI_M_STICKY_ARES				92
++#define GCC_PCIE2_AXI_S_ARES					93
++#define GCC_PCIE2_AXI_S_STICKY_ARES				94
++#define GCC_PCIE2_CORE_STICKY_ARES				95
++#define GCC_PCIE2_PIPE_ARES					96
++#define GCC_PCIE3_AHB_ARES					97
++#define GCC_PCIE3_AUX_ARES					98
++#define GCC_PCIE3_AXI_M_ARES					99
++#define GCC_PCIE3_AXI_M_STICKY_ARES				100
++#define GCC_PCIE3_AXI_S_ARES					101
++#define GCC_PCIE3_AXI_S_STICKY_ARES				102
++#define GCC_PCIE3_CORE_STICKY_ARES				103
++#define GCC_PCIE3_PIPE_ARES					104
++#define GCC_PCNOC_BCR						105
++#define GCC_PCNOC_BUS_TIMEOUT0_BCR				106
++#define GCC_PCNOC_BUS_TIMEOUT1_BCR				107
++#define GCC_PCNOC_BUS_TIMEOUT2_BCR				108
++#define GCC_PCNOC_BUS_TIMEOUT3_BCR				109
++#define GCC_PCNOC_BUS_TIMEOUT4_BCR				110
++#define GCC_PCNOC_BUS_TIMEOUT5_BCR				111
++#define GCC_PCNOC_BUS_TIMEOUT6_BCR				112
++#define GCC_PCNOC_BUS_TIMEOUT7_BCR				113
++#define GCC_PCNOC_BUS_TIMEOUT8_BCR				114
++#define GCC_PCNOC_BUS_TIMEOUT9_BCR				115
++#define GCC_PCNOC_TBU_BCR					116
++#define GCC_Q6SS_DBG_ARES					117
++#define GCC_Q6_AHB_ARES						118
++#define GCC_Q6_AHB_S_ARES					119
++#define GCC_Q6_AXIM2_ARES					120
++#define GCC_Q6_AXIM_ARES					121
++#define GCC_QDSS_BCR						122
++#define GCC_QPIC_BCR						123
++#define GCC_QPIC_AHB_ARES					124
++#define GCC_QPIC_ARES						125
++#define GCC_RBCPR_BCR						126
++#define GCC_RBCPR_MX_BCR					127
++#define GCC_SEC_CTRL_BCR					128
++#define GCC_SMMU_CFG_BCR					129
++#define GCC_SNOC_BCR						130
++#define GCC_SPDM_BCR						131
++#define GCC_TME_BCR						132
++#define GCC_UNIPHY0_SYS_RESET					133
++#define GCC_UNIPHY0_AHB_RESET					134
++#define GCC_UNIPHY0_XPCS_RESET					135
++#define GCC_UNIPHY1_SYS_RESET					136
++#define GCC_UNIPHY1_AHB_RESET					137
++#define GCC_UNIPHY1_XPCS_RESET					138
++#define GCC_UNIPHY2_SYS_RESET					139
++#define GCC_UNIPHY2_AHB_RESET					140
++#define GCC_UNIPHY2_XPCS_RESET					141
++#define GCC_USB_MISC_RESET					142
++#define GCC_WCSSAON_RESET					143
++#define GCC_WCSS_ACMT_ARES					144
++#define GCC_WCSS_AHB_S_ARES					145
++#define GCC_WCSS_AXI_M_ARES					146
++#define GCC_WCSS_BCR						147
++#define GCC_WCSS_DBG_ARES					148
++#define GCC_WCSS_DBG_BDG_ARES					149
++#define GCC_WCSS_ECAHB_ARES					150
++#define GCC_WCSS_Q6_BCR						151
++#define GCC_WCSS_Q6_TBU_BCR					152
++#define GCC_TCSR_BCR						153
++
++#endif
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0009-pinctrl-qcom-Add-IPQ9574-pinctrl-driver.patch b/target/linux/ipq95xx/patches-6.1/0009-pinctrl-qcom-Add-IPQ9574-pinctrl-driver.patch
new file mode 100644
index 0000000000..087f776677
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0009-pinctrl-qcom-Add-IPQ9574-pinctrl-driver.patch
@@ -0,0 +1,889 @@
+From 1d437190764f774f61f1ab389b4c074e0f69bbb1 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 16 Mar 2023 12:59:38 +0530
+Subject: [PATCH 09/41] pinctrl: qcom: Add IPQ9574 pinctrl driver
+
+Add pinctrl definitions for the TLMM of IPQ9574
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Co-developed-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Link: https://lore.kernel.org/r/20230316072940.29137-5-quic_devipriy@quicinc.com
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/qcom/Kconfig           |  11 +
+ drivers/pinctrl/qcom/Makefile          |   1 +
+ drivers/pinctrl/qcom/pinctrl-ipq9574.c | 826 +++++++++++++++++++++++++
+ 3 files changed, 838 insertions(+)
+ create mode 100644 drivers/pinctrl/qcom/pinctrl-ipq9574.c
+
+diff --git a/drivers/pinctrl/qcom/Kconfig b/drivers/pinctrl/qcom/Kconfig
+index 9dc2d803a586..c8b6a4d90f3c 100644
+--- a/drivers/pinctrl/qcom/Kconfig
++++ b/drivers/pinctrl/qcom/Kconfig
+@@ -70,6 +70,17 @@ config PINCTRL_IPQ6018
+ 	  Qualcomm Technologies Inc. IPQ6018 platform. Select this for
+ 	  IPQ6018.
+ 
++config PINCTRL_IPQ9574
++	tristate "Qualcomm Technologies, Inc. IPQ9574 pin controller driver"
++	depends on OF || COMPILE_TEST
++	depends on ARM64 || COMPILE_TEST
++	depends on PINCTRL_MSM
++	help
++	  This is the pinctrl, pinmux, pinconf and gpiolib driver for
++          the Qualcomm Technologies Inc. TLMM block found on the
++          Qualcomm Technologies Inc. IPQ9574 platform. Select this for
++          IPQ9574.
++
+ config PINCTRL_MSM8226
+ 	tristate "Qualcomm 8226 pin controller driver"
+ 	depends on OF
+diff --git a/drivers/pinctrl/qcom/Makefile b/drivers/pinctrl/qcom/Makefile
+index 8269a1db8794..79302d518ff3 100644
+--- a/drivers/pinctrl/qcom/Makefile
++++ b/drivers/pinctrl/qcom/Makefile
+@@ -7,6 +7,7 @@ obj-$(CONFIG_PINCTRL_IPQ4019)	+= pinctrl-ipq4019.o
+ obj-$(CONFIG_PINCTRL_IPQ8064)	+= pinctrl-ipq8064.o
+ obj-$(CONFIG_PINCTRL_IPQ8074)	+= pinctrl-ipq8074.o
+ obj-$(CONFIG_PINCTRL_IPQ6018)	+= pinctrl-ipq6018.o
++obj-$(CONFIG_PINCTRL_IPQ9574)	+= pinctrl-ipq9574.o
+ obj-$(CONFIG_PINCTRL_MSM8226)	+= pinctrl-msm8226.o
+ obj-$(CONFIG_PINCTRL_MSM8660)	+= pinctrl-msm8660.o
+ obj-$(CONFIG_PINCTRL_MSM8960)	+= pinctrl-msm8960.o
+diff --git a/drivers/pinctrl/qcom/pinctrl-ipq9574.c b/drivers/pinctrl/qcom/pinctrl-ipq9574.c
+new file mode 100644
+index 000000000000..7f057b62475f
+--- /dev/null
++++ b/drivers/pinctrl/qcom/pinctrl-ipq9574.c
+@@ -0,0 +1,826 @@
++// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++/*
++ * Copyright (c) 2023 The Linux Foundation. All rights reserved.
++ */
++
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/pinctrl/pinctrl.h>
++
++#include "pinctrl-msm.h"
++
++#define FUNCTION(fname)			                \
++	[msm_mux_##fname] = {		                \
++		.name = #fname,				\
++		.groups = fname##_groups,               \
++		.ngroups = ARRAY_SIZE(fname##_groups),	\
++	}
++
++#define REG_SIZE 0x1000
++#define PINGROUP(id, f1, f2, f3, f4, f5, f6, f7, f8, f9)	\
++	{					        \
++		.name = "gpio" #id,			\
++		.pins = gpio##id##_pins,		\
++		.npins = (unsigned int)ARRAY_SIZE(gpio##id##_pins),	\
++		.funcs = (int[]){			\
++			msm_mux_gpio, /* gpio mode */	\
++			msm_mux_##f1,			\
++			msm_mux_##f2,			\
++			msm_mux_##f3,			\
++			msm_mux_##f4,			\
++			msm_mux_##f5,			\
++			msm_mux_##f6,			\
++			msm_mux_##f7,			\
++			msm_mux_##f8,			\
++			msm_mux_##f9			\
++		},				        \
++		.nfuncs = 10,				\
++		.ctl_reg = REG_SIZE * id,			\
++		.io_reg = 0x4 + REG_SIZE * id,		\
++		.intr_cfg_reg = 0x8 + REG_SIZE * id,		\
++		.intr_status_reg = 0xc + REG_SIZE * id,	\
++		.intr_target_reg = 0x8 + REG_SIZE * id,	\
++		.mux_bit = 2,			\
++		.pull_bit = 0,			\
++		.drv_bit = 6,			\
++		.oe_bit = 9,			\
++		.in_bit = 0,			\
++		.out_bit = 1,			\
++		.intr_enable_bit = 0,		\
++		.intr_status_bit = 0,		\
++		.intr_target_bit = 5,		\
++		.intr_target_kpss_val = 3,	\
++		.intr_raw_status_bit = 4,	\
++		.intr_polarity_bit = 1,		\
++		.intr_detection_bit = 2,	\
++		.intr_detection_width = 2,	\
++	}
++
++static const struct pinctrl_pin_desc ipq9574_pins[] = {
++	PINCTRL_PIN(0, "GPIO_0"),
++	PINCTRL_PIN(1, "GPIO_1"),
++	PINCTRL_PIN(2, "GPIO_2"),
++	PINCTRL_PIN(3, "GPIO_3"),
++	PINCTRL_PIN(4, "GPIO_4"),
++	PINCTRL_PIN(5, "GPIO_5"),
++	PINCTRL_PIN(6, "GPIO_6"),
++	PINCTRL_PIN(7, "GPIO_7"),
++	PINCTRL_PIN(8, "GPIO_8"),
++	PINCTRL_PIN(9, "GPIO_9"),
++	PINCTRL_PIN(10, "GPIO_10"),
++	PINCTRL_PIN(11, "GPIO_11"),
++	PINCTRL_PIN(12, "GPIO_12"),
++	PINCTRL_PIN(13, "GPIO_13"),
++	PINCTRL_PIN(14, "GPIO_14"),
++	PINCTRL_PIN(15, "GPIO_15"),
++	PINCTRL_PIN(16, "GPIO_16"),
++	PINCTRL_PIN(17, "GPIO_17"),
++	PINCTRL_PIN(18, "GPIO_18"),
++	PINCTRL_PIN(19, "GPIO_19"),
++	PINCTRL_PIN(20, "GPIO_20"),
++	PINCTRL_PIN(21, "GPIO_21"),
++	PINCTRL_PIN(22, "GPIO_22"),
++	PINCTRL_PIN(23, "GPIO_23"),
++	PINCTRL_PIN(24, "GPIO_24"),
++	PINCTRL_PIN(25, "GPIO_25"),
++	PINCTRL_PIN(26, "GPIO_26"),
++	PINCTRL_PIN(27, "GPIO_27"),
++	PINCTRL_PIN(28, "GPIO_28"),
++	PINCTRL_PIN(29, "GPIO_29"),
++	PINCTRL_PIN(30, "GPIO_30"),
++	PINCTRL_PIN(31, "GPIO_31"),
++	PINCTRL_PIN(32, "GPIO_32"),
++	PINCTRL_PIN(33, "GPIO_33"),
++	PINCTRL_PIN(34, "GPIO_34"),
++	PINCTRL_PIN(35, "GPIO_35"),
++	PINCTRL_PIN(36, "GPIO_36"),
++	PINCTRL_PIN(37, "GPIO_37"),
++	PINCTRL_PIN(38, "GPIO_38"),
++	PINCTRL_PIN(39, "GPIO_39"),
++	PINCTRL_PIN(40, "GPIO_40"),
++	PINCTRL_PIN(41, "GPIO_41"),
++	PINCTRL_PIN(42, "GPIO_42"),
++	PINCTRL_PIN(43, "GPIO_43"),
++	PINCTRL_PIN(44, "GPIO_44"),
++	PINCTRL_PIN(45, "GPIO_45"),
++	PINCTRL_PIN(46, "GPIO_46"),
++	PINCTRL_PIN(47, "GPIO_47"),
++	PINCTRL_PIN(48, "GPIO_48"),
++	PINCTRL_PIN(49, "GPIO_49"),
++	PINCTRL_PIN(50, "GPIO_50"),
++	PINCTRL_PIN(51, "GPIO_51"),
++	PINCTRL_PIN(52, "GPIO_52"),
++	PINCTRL_PIN(53, "GPIO_53"),
++	PINCTRL_PIN(54, "GPIO_54"),
++	PINCTRL_PIN(55, "GPIO_55"),
++	PINCTRL_PIN(56, "GPIO_56"),
++	PINCTRL_PIN(57, "GPIO_57"),
++	PINCTRL_PIN(58, "GPIO_58"),
++	PINCTRL_PIN(59, "GPIO_59"),
++	PINCTRL_PIN(60, "GPIO_60"),
++	PINCTRL_PIN(61, "GPIO_61"),
++	PINCTRL_PIN(62, "GPIO_62"),
++	PINCTRL_PIN(63, "GPIO_63"),
++	PINCTRL_PIN(64, "GPIO_64"),
++};
++
++#define DECLARE_MSM_GPIO_PINS(pin) \
++	static const unsigned int gpio##pin##_pins[] = { pin }
++DECLARE_MSM_GPIO_PINS(0);
++DECLARE_MSM_GPIO_PINS(1);
++DECLARE_MSM_GPIO_PINS(2);
++DECLARE_MSM_GPIO_PINS(3);
++DECLARE_MSM_GPIO_PINS(4);
++DECLARE_MSM_GPIO_PINS(5);
++DECLARE_MSM_GPIO_PINS(6);
++DECLARE_MSM_GPIO_PINS(7);
++DECLARE_MSM_GPIO_PINS(8);
++DECLARE_MSM_GPIO_PINS(9);
++DECLARE_MSM_GPIO_PINS(10);
++DECLARE_MSM_GPIO_PINS(11);
++DECLARE_MSM_GPIO_PINS(12);
++DECLARE_MSM_GPIO_PINS(13);
++DECLARE_MSM_GPIO_PINS(14);
++DECLARE_MSM_GPIO_PINS(15);
++DECLARE_MSM_GPIO_PINS(16);
++DECLARE_MSM_GPIO_PINS(17);
++DECLARE_MSM_GPIO_PINS(18);
++DECLARE_MSM_GPIO_PINS(19);
++DECLARE_MSM_GPIO_PINS(20);
++DECLARE_MSM_GPIO_PINS(21);
++DECLARE_MSM_GPIO_PINS(22);
++DECLARE_MSM_GPIO_PINS(23);
++DECLARE_MSM_GPIO_PINS(24);
++DECLARE_MSM_GPIO_PINS(25);
++DECLARE_MSM_GPIO_PINS(26);
++DECLARE_MSM_GPIO_PINS(27);
++DECLARE_MSM_GPIO_PINS(28);
++DECLARE_MSM_GPIO_PINS(29);
++DECLARE_MSM_GPIO_PINS(30);
++DECLARE_MSM_GPIO_PINS(31);
++DECLARE_MSM_GPIO_PINS(32);
++DECLARE_MSM_GPIO_PINS(33);
++DECLARE_MSM_GPIO_PINS(34);
++DECLARE_MSM_GPIO_PINS(35);
++DECLARE_MSM_GPIO_PINS(36);
++DECLARE_MSM_GPIO_PINS(37);
++DECLARE_MSM_GPIO_PINS(38);
++DECLARE_MSM_GPIO_PINS(39);
++DECLARE_MSM_GPIO_PINS(40);
++DECLARE_MSM_GPIO_PINS(41);
++DECLARE_MSM_GPIO_PINS(42);
++DECLARE_MSM_GPIO_PINS(43);
++DECLARE_MSM_GPIO_PINS(44);
++DECLARE_MSM_GPIO_PINS(45);
++DECLARE_MSM_GPIO_PINS(46);
++DECLARE_MSM_GPIO_PINS(47);
++DECLARE_MSM_GPIO_PINS(48);
++DECLARE_MSM_GPIO_PINS(49);
++DECLARE_MSM_GPIO_PINS(50);
++DECLARE_MSM_GPIO_PINS(51);
++DECLARE_MSM_GPIO_PINS(52);
++DECLARE_MSM_GPIO_PINS(53);
++DECLARE_MSM_GPIO_PINS(54);
++DECLARE_MSM_GPIO_PINS(55);
++DECLARE_MSM_GPIO_PINS(56);
++DECLARE_MSM_GPIO_PINS(57);
++DECLARE_MSM_GPIO_PINS(58);
++DECLARE_MSM_GPIO_PINS(59);
++DECLARE_MSM_GPIO_PINS(60);
++DECLARE_MSM_GPIO_PINS(61);
++DECLARE_MSM_GPIO_PINS(62);
++DECLARE_MSM_GPIO_PINS(63);
++DECLARE_MSM_GPIO_PINS(64);
++
++enum ipq9574_functions {
++	msm_mux_atest_char,
++	msm_mux_atest_char0,
++	msm_mux_atest_char1,
++	msm_mux_atest_char2,
++	msm_mux_atest_char3,
++	msm_mux_audio_pdm0,
++	msm_mux_audio_pdm1,
++	msm_mux_audio_pri,
++	msm_mux_audio_sec,
++	msm_mux_blsp0_spi,
++	msm_mux_blsp0_uart,
++	msm_mux_blsp1_i2c,
++	msm_mux_blsp1_spi,
++	msm_mux_blsp1_uart,
++	msm_mux_blsp2_i2c,
++	msm_mux_blsp2_spi,
++	msm_mux_blsp2_uart,
++	msm_mux_blsp3_i2c,
++	msm_mux_blsp3_spi,
++	msm_mux_blsp3_uart,
++	msm_mux_blsp4_i2c,
++	msm_mux_blsp4_spi,
++	msm_mux_blsp4_uart,
++	msm_mux_blsp5_i2c,
++	msm_mux_blsp5_uart,
++	msm_mux_cri_trng0,
++	msm_mux_cri_trng1,
++	msm_mux_cri_trng2,
++	msm_mux_cri_trng3,
++	msm_mux_cxc0,
++	msm_mux_cxc1,
++	msm_mux_dbg_out,
++	msm_mux_dwc_ddrphy,
++	msm_mux_gcc_plltest,
++	msm_mux_gcc_tlmm,
++	msm_mux_gpio,
++	msm_mux_mac,
++	msm_mux_mdc,
++	msm_mux_mdio,
++	msm_mux_pcie0_clk,
++	msm_mux_pcie0_wake,
++	msm_mux_pcie1_clk,
++	msm_mux_pcie1_wake,
++	msm_mux_pcie2_clk,
++	msm_mux_pcie2_wake,
++	msm_mux_pcie3_clk,
++	msm_mux_pcie3_wake,
++	msm_mux_prng_rosc0,
++	msm_mux_prng_rosc1,
++	msm_mux_prng_rosc2,
++	msm_mux_prng_rosc3,
++	msm_mux_pta,
++	msm_mux_pwm,
++	msm_mux_qdss_cti_trig_in_a0,
++	msm_mux_qdss_cti_trig_in_a1,
++	msm_mux_qdss_cti_trig_in_b0,
++	msm_mux_qdss_cti_trig_in_b1,
++	msm_mux_qdss_cti_trig_out_a0,
++	msm_mux_qdss_cti_trig_out_a1,
++	msm_mux_qdss_cti_trig_out_b0,
++	msm_mux_qdss_cti_trig_out_b1,
++	msm_mux_qdss_traceclk_a,
++	msm_mux_qdss_traceclk_b,
++	msm_mux_qdss_tracectl_a,
++	msm_mux_qdss_tracectl_b,
++	msm_mux_qdss_tracedata_a,
++	msm_mux_qdss_tracedata_b,
++	msm_mux_qspi_data,
++	msm_mux_qspi_clk,
++	msm_mux_qspi_cs,
++	msm_mux_rx0,
++	msm_mux_rx1,
++	msm_mux_sdc_data,
++	msm_mux_sdc_clk,
++	msm_mux_sdc_cmd,
++	msm_mux_sdc_rclk,
++	msm_mux_tsens_max,
++	msm_mux_wci20,
++	msm_mux_wci21,
++	msm_mux_wsa_swrm,
++	msm_mux__,
++};
++
++static const char * const gpio_groups[] = {
++	"gpio0", "gpio1", "gpio2", "gpio3", "gpio4", "gpio5", "gpio6", "gpio7",
++	"gpio8", "gpio9", "gpio10", "gpio11", "gpio12", "gpio13", "gpio14",
++	"gpio15", "gpio16", "gpio17", "gpio18", "gpio19", "gpio20", "gpio21",
++	"gpio22", "gpio23", "gpio24", "gpio25", "gpio26", "gpio27", "gpio28",
++	"gpio29", "gpio30", "gpio31", "gpio32", "gpio33", "gpio34", "gpio35",
++	"gpio36", "gpio37", "gpio38", "gpio39", "gpio40", "gpio41", "gpio42",
++	"gpio43", "gpio44", "gpio45", "gpio46", "gpio47", "gpio48", "gpio49",
++	"gpio50", "gpio51", "gpio52", "gpio53", "gpio54", "gpio55", "gpio56",
++	"gpio57", "gpio58", "gpio59", "gpio60", "gpio61", "gpio62", "gpio63",
++	"gpio64",
++};
++
++static const char * const sdc_data_groups[] = {
++	"gpio0",
++	"gpio1",
++	"gpio2",
++	"gpio3",
++	"gpio6",
++	"gpio7",
++	"gpio8",
++	"gpio9",
++};
++
++static const char * const qspi_data_groups[] = {
++	"gpio0",
++	"gpio1",
++	"gpio2",
++	"gpio3",
++};
++
++static const char * const qdss_traceclk_b_groups[] = {
++	"gpio0",
++};
++
++static const char * const qdss_tracectl_b_groups[] = {
++	"gpio1",
++};
++
++static const char * const qdss_tracedata_b_groups[] = {
++	"gpio2", "gpio3", "gpio4", "gpio5", "gpio6", "gpio7", "gpio8", "gpio9",
++	"gpio10", "gpio11", "gpio12", "gpio13", "gpio14", "gpio15", "gpio16",
++	"gpio17",
++};
++
++static const char * const sdc_cmd_groups[] = {
++	"gpio4",
++};
++
++static const char * const qspi_cs_groups[] = {
++	"gpio4",
++};
++
++static const char * const sdc_clk_groups[] = {
++	"gpio5",
++};
++
++static const char * const qspi_clk_groups[] = {
++	"gpio5",
++};
++
++static const char * const sdc_rclk_groups[] = {
++	"gpio10",
++};
++
++static const char * const blsp0_spi_groups[] = {
++	"gpio11", "gpio12", "gpio13", "gpio14",
++};
++
++static const char * const blsp0_uart_groups[] = {
++	"gpio11", "gpio12", "gpio13", "gpio14",
++};
++
++static const char * const blsp3_spi_groups[] = {
++	"gpio15", "gpio16", "gpio17", "gpio18", "gpio19", "gpio20", "gpio21",
++};
++
++static const char * const blsp3_i2c_groups[] = {
++	"gpio15", "gpio16",
++};
++
++static const char * const blsp3_uart_groups[] = {
++	"gpio15", "gpio16", "gpio17", "gpio18",
++};
++
++static const char * const dbg_out_groups[] = {
++	"gpio17",
++};
++
++static const char * const cri_trng0_groups[] = {
++	"gpio20", "gpio38",
++};
++
++static const char * const cri_trng1_groups[] = {
++	"gpio21", "gpio34",
++};
++
++static const char * const pcie0_clk_groups[] = {
++	"gpio22",
++};
++
++static const char * const pta_groups[] = {
++	"gpio22", "gpio23", "gpio24", "gpio54", "gpio55", "gpio56", "gpio61",
++	"gpio62", "gpio63",
++};
++
++static const char * const wci21_groups[] = {
++	"gpio23", "gpio24",
++};
++
++static const char * const cxc0_groups[] = {
++	"gpio23", "gpio24",
++};
++
++static const char * const pcie0_wake_groups[] = {
++	"gpio24",
++};
++
++static const char * const qdss_cti_trig_out_b0_groups[] = {
++	"gpio24",
++};
++
++static const char * const pcie1_clk_groups[] = {
++	"gpio25",
++};
++
++static const char * const qdss_cti_trig_in_b0_groups[] = {
++	"gpio25",
++};
++
++static const char * const atest_char0_groups[] = {
++	"gpio26",
++};
++
++static const char * const qdss_cti_trig_out_b1_groups[] = {
++	"gpio26",
++};
++
++static const char * const pcie1_wake_groups[] = {
++	"gpio27",
++};
++
++static const char * const atest_char1_groups[] = {
++	"gpio27",
++};
++
++static const char * const qdss_cti_trig_in_b1_groups[] = {
++	"gpio27",
++};
++
++static const char * const pcie2_clk_groups[] = {
++	"gpio28",
++};
++
++static const char * const atest_char2_groups[] = {
++	"gpio28",
++};
++
++static const char * const atest_char3_groups[] = {
++	"gpio29",
++};
++
++static const char * const pcie2_wake_groups[] = {
++	"gpio30",
++};
++
++static const char * const pwm_groups[] = {
++	"gpio30", "gpio31", "gpio32", "gpio33", "gpio44", "gpio45", "gpio46",
++	"gpio47", "gpio50", "gpio51", "gpio52", "gpio53", "gpio54", "gpio55",
++	"gpio56", "gpio57", "gpio58", "gpio59", "gpio60",
++};
++
++static const char * const atest_char_groups[] = {
++	"gpio30",
++};
++
++static const char * const pcie3_clk_groups[] = {
++	"gpio31",
++};
++
++static const char * const qdss_cti_trig_in_a1_groups[] = {
++	"gpio31",
++};
++
++static const char * const qdss_cti_trig_out_a1_groups[] = {
++	"gpio32",
++};
++
++static const char * const pcie3_wake_groups[] = {
++	"gpio33",
++};
++
++static const char * const qdss_cti_trig_in_a0_groups[] = {
++	"gpio33",
++};
++
++static const char * const blsp2_uart_groups[] = {
++	"gpio34", "gpio35",
++};
++
++static const char * const blsp2_i2c_groups[] = {
++	"gpio34", "gpio35",
++};
++
++static const char * const blsp2_spi_groups[] = {
++	"gpio34", "gpio35", "gpio36", "gpio37",
++};
++
++static const char * const blsp1_uart_groups[] = {
++	"gpio34", "gpio35", "gpio36", "gpio37",
++};
++
++static const char * const qdss_cti_trig_out_a0_groups[] = {
++	"gpio34",
++};
++
++static const char * const cri_trng2_groups[] = {
++	"gpio35",
++};
++
++static const char * const blsp1_i2c_groups[] = {
++	"gpio36", "gpio37",
++};
++
++static const char * const cri_trng3_groups[] = {
++	"gpio36",
++};
++
++static const char * const dwc_ddrphy_groups[] = {
++	"gpio37",
++};
++
++static const char * const mdc_groups[] = {
++	"gpio38",
++};
++
++static const char * const mdio_groups[] = {
++	"gpio39",
++};
++
++static const char * const audio_pri_groups[] = {
++	"gpio40", "gpio41", "gpio42", "gpio43", "gpio61", "gpio61",
++};
++
++static const char * const audio_pdm0_groups[] = {
++	"gpio40", "gpio41", "gpio42", "gpio43",
++};
++
++static const char * const qdss_traceclk_a_groups[] = {
++	"gpio43",
++};
++
++static const char * const audio_sec_groups[] = {
++	"gpio44", "gpio45", "gpio46", "gpio47", "gpio62", "gpio62",
++};
++
++static const char * const wsa_swrm_groups[] = {
++	"gpio44", "gpio45",
++};
++
++static const char * const qdss_tracectl_a_groups[] = {
++	"gpio44",
++};
++
++static const char * const qdss_tracedata_a_groups[] = {
++	"gpio45", "gpio46", "gpio47", "gpio48", "gpio49", "gpio50", "gpio51",
++	"gpio52", "gpio53", "gpio54", "gpio55", "gpio56", "gpio57", "gpio58",
++	"gpio59", "gpio60",
++};
++
++static const char * const rx1_groups[] = {
++	"gpio46",
++};
++
++static const char * const mac_groups[] = {
++	"gpio46", "gpio47", "gpio57", "gpio58",
++};
++
++static const char * const blsp5_i2c_groups[] = {
++	"gpio48", "gpio49",
++};
++
++static const char * const blsp5_uart_groups[] = {
++	"gpio48", "gpio49",
++};
++
++static const char * const blsp4_uart_groups[] = {
++	"gpio50", "gpio51", "gpio52", "gpio53",
++};
++
++static const char * const blsp4_i2c_groups[] = {
++	"gpio50", "gpio51",
++};
++
++static const char * const blsp4_spi_groups[] = {
++	"gpio50", "gpio51", "gpio52", "gpio53",
++};
++
++static const char * const wci20_groups[] = {
++	"gpio57", "gpio58",
++};
++
++static const char * const cxc1_groups[] = {
++	"gpio57", "gpio58",
++};
++
++static const char * const rx0_groups[] = {
++	"gpio59",
++};
++
++static const char * const prng_rosc0_groups[] = {
++	"gpio60",
++};
++
++static const char * const gcc_plltest_groups[] = {
++	"gpio60", "gpio62",
++};
++
++static const char * const blsp1_spi_groups[] = {
++	"gpio61", "gpio62", "gpio63", "gpio64",
++};
++
++static const char * const audio_pdm1_groups[] = {
++	"gpio61", "gpio62", "gpio63", "gpio64",
++};
++
++static const char * const prng_rosc1_groups[] = {
++	"gpio61",
++};
++
++static const char * const gcc_tlmm_groups[] = {
++	"gpio61",
++};
++
++static const char * const prng_rosc2_groups[] = {
++	"gpio62",
++};
++
++static const char * const prng_rosc3_groups[] = {
++	"gpio63",
++};
++
++static const char * const tsens_max_groups[] = {
++	"gpio64",
++};
++
++static const struct msm_function ipq9574_functions[] = {
++	FUNCTION(atest_char),
++	FUNCTION(atest_char0),
++	FUNCTION(atest_char1),
++	FUNCTION(atest_char2),
++	FUNCTION(atest_char3),
++	FUNCTION(audio_pdm0),
++	FUNCTION(audio_pdm1),
++	FUNCTION(audio_pri),
++	FUNCTION(audio_sec),
++	FUNCTION(blsp0_spi),
++	FUNCTION(blsp0_uart),
++	FUNCTION(blsp1_i2c),
++	FUNCTION(blsp1_spi),
++	FUNCTION(blsp1_uart),
++	FUNCTION(blsp2_i2c),
++	FUNCTION(blsp2_spi),
++	FUNCTION(blsp2_uart),
++	FUNCTION(blsp3_i2c),
++	FUNCTION(blsp3_spi),
++	FUNCTION(blsp3_uart),
++	FUNCTION(blsp4_i2c),
++	FUNCTION(blsp4_spi),
++	FUNCTION(blsp4_uart),
++	FUNCTION(blsp5_i2c),
++	FUNCTION(blsp5_uart),
++	FUNCTION(cri_trng0),
++	FUNCTION(cri_trng1),
++	FUNCTION(cri_trng2),
++	FUNCTION(cri_trng3),
++	FUNCTION(cxc0),
++	FUNCTION(cxc1),
++	FUNCTION(dbg_out),
++	FUNCTION(dwc_ddrphy),
++	FUNCTION(gcc_plltest),
++	FUNCTION(gcc_tlmm),
++	FUNCTION(gpio),
++	FUNCTION(mac),
++	FUNCTION(mdc),
++	FUNCTION(mdio),
++	FUNCTION(pcie0_clk),
++	FUNCTION(pcie0_wake),
++	FUNCTION(pcie1_clk),
++	FUNCTION(pcie1_wake),
++	FUNCTION(pcie2_clk),
++	FUNCTION(pcie2_wake),
++	FUNCTION(pcie3_clk),
++	FUNCTION(pcie3_wake),
++	FUNCTION(prng_rosc0),
++	FUNCTION(prng_rosc1),
++	FUNCTION(prng_rosc2),
++	FUNCTION(prng_rosc3),
++	FUNCTION(pta),
++	FUNCTION(pwm),
++	FUNCTION(qdss_cti_trig_in_a0),
++	FUNCTION(qdss_cti_trig_in_a1),
++	FUNCTION(qdss_cti_trig_in_b0),
++	FUNCTION(qdss_cti_trig_in_b1),
++	FUNCTION(qdss_cti_trig_out_a0),
++	FUNCTION(qdss_cti_trig_out_a1),
++	FUNCTION(qdss_cti_trig_out_b0),
++	FUNCTION(qdss_cti_trig_out_b1),
++	FUNCTION(qdss_traceclk_a),
++	FUNCTION(qdss_traceclk_b),
++	FUNCTION(qdss_tracectl_a),
++	FUNCTION(qdss_tracectl_b),
++	FUNCTION(qdss_tracedata_a),
++	FUNCTION(qdss_tracedata_b),
++	FUNCTION(qspi_data),
++	FUNCTION(qspi_clk),
++	FUNCTION(qspi_cs),
++	FUNCTION(rx0),
++	FUNCTION(rx1),
++	FUNCTION(sdc_data),
++	FUNCTION(sdc_clk),
++	FUNCTION(sdc_cmd),
++	FUNCTION(sdc_rclk),
++	FUNCTION(tsens_max),
++	FUNCTION(wci20),
++	FUNCTION(wci21),
++	FUNCTION(wsa_swrm),
++};
++
++static const struct msm_pingroup ipq9574_groups[] = {
++	PINGROUP(0, sdc_data, qspi_data, qdss_traceclk_b, _, _, _, _, _, _),
++	PINGROUP(1, sdc_data, qspi_data, qdss_tracectl_b, _, _, _, _, _, _),
++	PINGROUP(2, sdc_data, qspi_data, qdss_tracedata_b, _, _, _, _, _, _),
++	PINGROUP(3, sdc_data, qspi_data, qdss_tracedata_b, _, _, _, _, _, _),
++	PINGROUP(4, sdc_cmd, qspi_cs, qdss_tracedata_b, _, _, _, _, _, _),
++	PINGROUP(5, sdc_clk, qspi_clk, qdss_tracedata_b, _, _, _, _, _, _),
++	PINGROUP(6, sdc_data, qdss_tracedata_b, _, _, _, _, _, _, _),
++	PINGROUP(7, sdc_data, qdss_tracedata_b, _, _, _, _, _, _, _),
++	PINGROUP(8, sdc_data, qdss_tracedata_b, _, _, _, _, _, _, _),
++	PINGROUP(9, sdc_data, qdss_tracedata_b, _, _, _, _, _, _, _),
++	PINGROUP(10, sdc_rclk, qdss_tracedata_b, _, _, _, _, _, _, _),
++	PINGROUP(11, blsp0_spi, blsp0_uart, qdss_tracedata_b, _, _, _, _, _, _),
++	PINGROUP(12, blsp0_spi, blsp0_uart, qdss_tracedata_b, _, _, _, _, _, _),
++	PINGROUP(13, blsp0_spi, blsp0_uart, qdss_tracedata_b, _, _, _, _, _, _),
++	PINGROUP(14, blsp0_spi, blsp0_uart, qdss_tracedata_b, _, _, _, _, _, _),
++	PINGROUP(15, blsp3_spi, blsp3_i2c, blsp3_uart, qdss_tracedata_b, _, _, _, _, _),
++	PINGROUP(16, blsp3_spi, blsp3_i2c, blsp3_uart, qdss_tracedata_b, _, _, _, _, _),
++	PINGROUP(17, blsp3_spi, blsp3_uart, dbg_out, qdss_tracedata_b, _, _, _, _, _),
++	PINGROUP(18, blsp3_spi, blsp3_uart, _, _, _, _, _, _, _),
++	PINGROUP(19, blsp3_spi, _, _, _, _, _, _, _, _),
++	PINGROUP(20, blsp3_spi, _, cri_trng0, _, _, _, _, _, _),
++	PINGROUP(21, blsp3_spi, _, cri_trng1, _, _, _, _, _, _),
++	PINGROUP(22, pcie0_clk, _, pta, _, _, _, _, _, _),
++	PINGROUP(23, _, pta, wci21, cxc0, _, _, _, _, _),
++	PINGROUP(24, pcie0_wake, _, pta, wci21, cxc0, _, qdss_cti_trig_out_b0, _, _),
++	PINGROUP(25, pcie1_clk, _, _, qdss_cti_trig_in_b0, _, _, _, _, _),
++	PINGROUP(26, _, atest_char0, _, qdss_cti_trig_out_b1, _, _, _, _, _),
++	PINGROUP(27, pcie1_wake, _, atest_char1, qdss_cti_trig_in_b1, _, _, _, _, _),
++	PINGROUP(28, pcie2_clk, atest_char2, _, _, _, _, _, _, _),
++	PINGROUP(29, atest_char3, _, _, _, _, _, _, _, _),
++	PINGROUP(30, pcie2_wake, pwm, atest_char, _, _, _, _, _, _),
++	PINGROUP(31, pcie3_clk, pwm, _, qdss_cti_trig_in_a1, _, _, _, _, _),
++	PINGROUP(32, pwm, _, qdss_cti_trig_out_a1, _, _, _, _, _, _),
++	PINGROUP(33, pcie3_wake, pwm, _, qdss_cti_trig_in_a0, _, _, _, _, _),
++	PINGROUP(34, blsp2_uart, blsp2_i2c, blsp2_spi, blsp1_uart, _, cri_trng1, qdss_cti_trig_out_a0, _, _),
++	PINGROUP(35, blsp2_uart, blsp2_i2c, blsp2_spi, blsp1_uart, _, cri_trng2, _, _, _),
++	PINGROUP(36, blsp1_uart, blsp1_i2c, blsp2_spi, _, cri_trng3, _, _, _, _),
++	PINGROUP(37, blsp1_uart, blsp1_i2c, blsp2_spi, _, dwc_ddrphy, _, _, _, _),
++	PINGROUP(38, mdc, _, cri_trng0, _, _, _, _, _, _),
++	PINGROUP(39, mdio, _, _, _, _, _, _, _, _),
++	PINGROUP(40, audio_pri, audio_pdm0, _, _, _, _, _, _, _),
++	PINGROUP(41, audio_pri, audio_pdm0, _, _, _, _, _, _, _),
++	PINGROUP(42, audio_pri, audio_pdm0, _, _, _, _, _, _, _),
++	PINGROUP(43, audio_pri, audio_pdm0, _, qdss_traceclk_a, _, _, _, _, _),
++	PINGROUP(44, pwm, audio_sec, wsa_swrm, _, qdss_tracectl_a, _, _, _, _),
++	PINGROUP(45, pwm, audio_sec, wsa_swrm, _, qdss_tracedata_a, _, _, _, _),
++	PINGROUP(46, pwm, audio_sec, rx1, mac, _, qdss_tracedata_a, _, _, _),
++	PINGROUP(47, pwm, audio_sec, mac, _, qdss_tracedata_a, _, _, _, _),
++	PINGROUP(48, blsp5_i2c, blsp5_uart, _, qdss_tracedata_a, _, _, _, _, _),
++	PINGROUP(49, blsp5_i2c, blsp5_uart, _, qdss_tracedata_a, _, _, _, _, _),
++	PINGROUP(50, blsp4_uart, blsp4_i2c, blsp4_spi, pwm, qdss_tracedata_a, _, _, _, _),
++	PINGROUP(51, blsp4_uart, blsp4_i2c, blsp4_spi, pwm, qdss_tracedata_a, _, _, _, _),
++	PINGROUP(52, blsp4_uart, blsp4_spi, pwm, qdss_tracedata_a, _, _, _, _, _),
++	PINGROUP(53, blsp4_uart, blsp4_spi, pwm, qdss_tracedata_a, _, _, _, _, _),
++	PINGROUP(54, pta, pwm, qdss_tracedata_a, _, _, _, _, _, _),
++	PINGROUP(55, pta, pwm, qdss_tracedata_a, _, _, _, _, _, _),
++	PINGROUP(56, pta, pwm, qdss_tracedata_a, _, _, _, _, _, _),
++	PINGROUP(57, wci20, cxc1, mac, pwm, qdss_tracedata_a, _, _, _, _),
++	PINGROUP(58, wci20, cxc1, mac, pwm, qdss_tracedata_a, _, _, _, _),
++	PINGROUP(59, rx0, pwm, qdss_tracedata_a, _, _, _, _, _, _),
++	PINGROUP(60, pwm, prng_rosc0, qdss_tracedata_a, _, gcc_plltest, _, _, _, _),
++	PINGROUP(61, blsp1_spi, audio_pri, audio_pdm1, audio_pri, pta, prng_rosc1, gcc_tlmm, _, _),
++	PINGROUP(62, blsp1_spi, audio_sec, audio_pdm1, audio_sec, pta, prng_rosc2, gcc_plltest, _, _),
++	PINGROUP(63, blsp1_spi, audio_pdm1, pta, prng_rosc3, _, _, _, _, _),
++	PINGROUP(64, blsp1_spi, audio_pdm1, tsens_max, _, _, _, _, _, _),
++};
++
++/* Reserving GPIO59 for controlling the QFPROM LDO regulator */
++static const int ipq9574_reserved_gpios[] = {
++	59, -1
++};
++
++static const struct msm_pinctrl_soc_data ipq9574_pinctrl = {
++	.pins = ipq9574_pins,
++	.npins = ARRAY_SIZE(ipq9574_pins),
++	.functions = ipq9574_functions,
++	.nfunctions = ARRAY_SIZE(ipq9574_functions),
++	.groups = ipq9574_groups,
++	.ngroups = ARRAY_SIZE(ipq9574_groups),
++	.reserved_gpios = ipq9574_reserved_gpios,
++	.ngpios = 65,
++};
++
++static int ipq9574_pinctrl_probe(struct platform_device *pdev)
++{
++	return msm_pinctrl_probe(pdev, &ipq9574_pinctrl);
++}
++
++static const struct of_device_id ipq9574_pinctrl_of_match[] = {
++	{ .compatible = "qcom,ipq9574-tlmm", },
++	{ }
++};
++MODULE_DEVICE_TABLE(of, ipq9574_pinctrl_of_match);
++
++static struct platform_driver ipq9574_pinctrl_driver = {
++	.driver = {
++		.name = "ipq9574-tlmm",
++		.of_match_table = ipq9574_pinctrl_of_match,
++	},
++	.probe = ipq9574_pinctrl_probe,
++	.remove = msm_pinctrl_remove,
++};
++
++static int __init ipq9574_pinctrl_init(void)
++{
++	return platform_driver_register(&ipq9574_pinctrl_driver);
++}
++arch_initcall(ipq9574_pinctrl_init);
++
++static void __exit ipq9574_pinctrl_exit(void)
++{
++	platform_driver_unregister(&ipq9574_pinctrl_driver);
++}
++module_exit(ipq9574_pinctrl_exit);
++
++MODULE_DESCRIPTION("QTI IPQ9574 TLMM driver");
++MODULE_LICENSE("GPL");
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0010-arm64-dts-qcom-ipq9574-Add-support-for-APSS-clock-co.patch b/target/linux/ipq95xx/patches-6.1/0010-arm64-dts-qcom-ipq9574-Add-support-for-APSS-clock-co.patch
new file mode 100644
index 0000000000..fb65338b03
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0010-arm64-dts-qcom-ipq9574-Add-support-for-APSS-clock-co.patch
@@ -0,0 +1,48 @@
+From 7fd33c757ae079f5fcba4ab1de145392247462d0 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 6 Apr 2023 11:43:13 +0530
+Subject: [PATCH 10/41] arm64: dts: qcom: ipq9574: Add support for APSS clock
+ controller
+
+Add the APCS & A73 PLL nodes to support CPU frequency scaling.
+
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230406061314.10916-5-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 18 ++++++++++++++++++
+ 1 file changed, 18 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 3bb7435f5e7f..00aeb994ee60 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -201,6 +201,24 @@ v2m2: v2m@2000 {
+ 			};
+ 		};
+ 
++		apcs_glb: mailbox@b111000 {
++			compatible = "qcom,ipq9574-apcs-apps-global",
++				     "qcom,ipq6018-apcs-apps-global";
++			reg = <0x0b111000 0x1000>;
++			#clock-cells = <1>;
++			clocks = <&a73pll>, <&xo_board_clk>;
++			clock-names = "pll", "xo";
++			#mbox-cells = <1>;
++		};
++
++		a73pll: clock@b116000 {
++			compatible = "qcom,ipq9574-a73pll";
++			reg = <0x0b116000 0x40>;
++			#clock-cells = <0>;
++			clocks = <&xo_board_clk>;
++			clock-names = "xo";
++		};
++
+ 		timer@b120000 {
+ 			compatible = "arm,armv7-timer-mem";
+ 			reg = <0x0b120000 0x1000>;
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0011-clk-qcom-apss-ipq-pll-Add-support-for-IPQ9574.patch b/target/linux/ipq95xx/patches-6.1/0011-clk-qcom-apss-ipq-pll-Add-support-for-IPQ9574.patch
new file mode 100644
index 0000000000..3dcab1e25d
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0011-clk-qcom-apss-ipq-pll-Add-support-for-IPQ9574.patch
@@ -0,0 +1,66 @@
+From f2e33970f45a9ce5c94da83980d1e95e21a565fe Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 6 Apr 2023 11:43:11 +0530
+Subject: [PATCH 11/41] clk: qcom: apss-ipq-pll: Add support for IPQ9574
+
+Add the compatible and configuration values for A73 Huayra PLL found
+on IPQ9574.
+
+Co-developed-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Acked-by: Stephen Boyd <sboyd@kernel.org>
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230406061314.10916-3-quic_devipriy@quicinc.com
+---
+ drivers/clk/qcom/apss-ipq-pll.c | 19 +++++++++++++++++++
+ 1 file changed, 19 insertions(+)
+
+diff --git a/drivers/clk/qcom/apss-ipq-pll.c b/drivers/clk/qcom/apss-ipq-pll.c
+index 4f2a147e9fb2..56f33af11311 100644
+--- a/drivers/clk/qcom/apss-ipq-pll.c
++++ b/drivers/clk/qcom/apss-ipq-pll.c
+@@ -68,6 +68,18 @@ static const struct alpha_pll_config ipq8074_pll_config = {
+ 	.test_ctl_hi_val = 0x4000,
+ };
+ 
++static const struct alpha_pll_config ipq9574_pll_config = {
++	.l = 0x3b,
++	.config_ctl_val = 0x200d4828,
++	.config_ctl_hi_val = 0x6,
++	.early_output_mask = BIT(3),
++	.aux2_output_mask = BIT(2),
++	.aux_output_mask = BIT(1),
++	.main_output_mask = BIT(0),
++	.test_ctl_val = 0x0,
++	.test_ctl_hi_val = 0x4000,
++};
++
+ struct apss_pll_data {
+ 	struct clk_alpha_pll *pll;
+ 	const struct alpha_pll_config *pll_config;
+@@ -83,6 +95,12 @@ static struct apss_pll_data ipq6018_pll_data = {
+ 	.pll_config = &ipq6018_pll_config,
+ };
+ 
++static struct apss_pll_data ipq9574_pll_data = {
++	.pll_type = CLK_ALPHA_PLL_TYPE_HUAYRA,
++	.pll = &ipq_pll_huayra,
++	.pll_config = &ipq9574_pll_config,
++};
++
+ static const struct regmap_config ipq_pll_regmap_config = {
+ 	.reg_bits		= 32,
+ 	.reg_stride		= 4,
+@@ -124,6 +142,7 @@ static int apss_ipq_pll_probe(struct platform_device *pdev)
+ static const struct of_device_id apss_ipq_pll_match_table[] = {
+ 	{ .compatible = "qcom,ipq6018-a53pll", .data = &ipq6018_pll_data },
+ 	{ .compatible = "qcom,ipq8074-a53pll", .data = &ipq8074_pll_data },
++	{ .compatible = "qcom,ipq9574-a73pll", .data = &ipq9574_pll_data },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, apss_ipq_pll_match_table);
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0012-regulator-qcom_smd-Add-MP5496-S1-regulator.patch b/target/linux/ipq95xx/patches-6.1/0012-regulator-qcom_smd-Add-MP5496-S1-regulator.patch
new file mode 100644
index 0000000000..043a60a05b
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0012-regulator-qcom_smd-Add-MP5496-S1-regulator.patch
@@ -0,0 +1,43 @@
+From 10b07ee264b5cc807939be4cbc60a3abad3ddf03 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Fri, 7 Apr 2023 21:27:24 +0530
+Subject: [PATCH 12/41] regulator: qcom_smd: Add MP5496 S1 regulator
+
+Adding support for MP5496 S1 regulator on IPQ9574 SoC.
+
+Co-developed-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Link: https://lore.kernel.org/r/20230407155727.20615-3-quic_devipriy@quicinc.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/regulator/qcom_smd-regulator.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/regulator/qcom_smd-regulator.c b/drivers/regulator/qcom_smd-regulator.c
+index f98168d58dce..88ef56a60b2a 100644
+--- a/drivers/regulator/qcom_smd-regulator.c
++++ b/drivers/regulator/qcom_smd-regulator.c
+@@ -731,7 +731,7 @@ static const struct regulator_desc pms405_pldo600 = {
+ 	.ops = &rpm_smps_ldo_ops,
+ };
+ 
+-static const struct regulator_desc mp5496_smpa2 = {
++static const struct regulator_desc mp5496_smps = {
+ 	.linear_ranges = (struct linear_range[]) {
+ 		REGULATOR_LINEAR_RANGE(600000, 0, 127, 12500),
+ 	},
+@@ -776,7 +776,8 @@ struct rpm_regulator_data {
+ };
+ 
+ static const struct rpm_regulator_data rpm_mp5496_regulators[] = {
+-	{ "s2", QCOM_SMD_RPM_SMPA, 2, &mp5496_smpa2, "s2" },
++	{ "s1", QCOM_SMD_RPM_SMPA, 1, &mp5496_smps, "s1" },
++	{ "s2", QCOM_SMD_RPM_SMPA, 2, &mp5496_smps, "s2" },
+ 	{ "l2", QCOM_SMD_RPM_LDOA, 2, &mp5496_ldoa2, "l2" },
+ 	{}
+ };
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0013-arm64-dts-qcom-ipq9574-rename-al02-c7-dts-to-rdp433.patch b/target/linux/ipq95xx/patches-6.1/0013-arm64-dts-qcom-ipq9574-rename-al02-c7-dts-to-rdp433.patch
new file mode 100644
index 0000000000..64523c9e3d
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0013-arm64-dts-qcom-ipq9574-rename-al02-c7-dts-to-rdp433.patch
@@ -0,0 +1,49 @@
+From 89978464908147356b67ee57dd07482dc7ffe332 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Tue, 25 Apr 2023 14:10:10 +0530
+Subject: [PATCH 13/41] arm64: dts: qcom: ipq9574: rename al02-c7 dts to rdp433
+
+Rename the dts after Reference Design Platform(RDP) to adopt
+standard naming convention.
+
+Acked-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230425084010.15581-7-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/Makefile                               | 2 +-
+ .../boot/dts/qcom/{ipq9574-al02-c7.dts => ipq9574-rdp433.dts}   | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+ rename arch/arm64/boot/dts/qcom/{ipq9574-al02-c7.dts => ipq9574-rdp433.dts} (97%)
+
+diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
+index 8e04f0f663da..3754d83ed2cb 100644
+--- a/arch/arm64/boot/dts/qcom/Makefile
++++ b/arch/arm64/boot/dts/qcom/Makefile
+@@ -7,7 +7,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= ipq6018-cp01-c1.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk01.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c1.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c2.dtb
+-dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-al02-c7.dtb
++dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp433.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-idol347.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z00l.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-g7.dtb
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-al02-c7.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
+similarity index 97%
+rename from arch/arm64/boot/dts/qcom/ipq9574-al02-c7.dts
+rename to arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
+index 2c8430197ec0..2ce8e09e7565 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574-al02-c7.dts
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
+@@ -1,6 +1,6 @@
+ // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+ /*
+- * IPQ9574 AL02-C7 board device tree source
++ * IPQ9574 RDP433 board device tree source
+  *
+  * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
+  * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0014-arm64-dts-qcom-ipq9574-Drop-bias_pll_ubi_nc_clk-inpu.patch b/target/linux/ipq95xx/patches-6.1/0014-arm64-dts-qcom-ipq9574-Drop-bias_pll_ubi_nc_clk-inpu.patch
new file mode 100644
index 0000000000..2f37a145ae
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0014-arm64-dts-qcom-ipq9574-Drop-bias_pll_ubi_nc_clk-inpu.patch
@@ -0,0 +1,44 @@
+From 20576d5e55831df510ed60f53d83c6e0618c2343 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Tue, 25 Apr 2023 14:10:09 +0530
+Subject: [PATCH 14/41] arm64: dts: qcom: ipq9574: Drop bias_pll_ubi_nc_clk
+ input
+
+Drop unused bias_pll_ubi_nc_clk input to the clock controller.
+
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230425084010.15581-6-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 8 +-------
+ 1 file changed, 1 insertion(+), 7 deletions(-)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 00aeb994ee60..0b8cd6ca0abe 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -16,12 +16,6 @@ / {
+ 	#size-cells = <2>;
+ 
+ 	clocks {
+-		bias_pll_ubi_nc_clk: bias-pll-ubi-nc-clk {
+-			compatible = "fixed-clock";
+-			clock-frequency = <353000000>;
+-			#clock-cells = <0>;
+-		};
+-
+ 		sleep_clk: sleep-clk {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <0>;
+@@ -131,7 +125,7 @@ gcc: clock-controller@1800000 {
+ 			reg = <0x01800000 0x80000>;
+ 			clocks = <&xo_board_clk>,
+ 				 <&sleep_clk>,
+-				 <&bias_pll_ubi_nc_clk>,
++				 <0>,
+ 				 <0>,
+ 				 <0>,
+ 				 <0>,
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0015-arm64-dts-qcom-ipq9574-Update-the-size-of-GICC-GICV-.patch b/target/linux/ipq95xx/patches-6.1/0015-arm64-dts-qcom-ipq9574-Update-the-size-of-GICC-GICV-.patch
new file mode 100644
index 0000000000..7f7bd63031
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0015-arm64-dts-qcom-ipq9574-Update-the-size-of-GICC-GICV-.patch
@@ -0,0 +1,42 @@
+From d7a20702b072333cc36cc78eb715295d65159196 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Tue, 25 Apr 2023 14:10:05 +0530
+Subject: [PATCH 15/41] arm64: dts: qcom: ipq9574: Update the size of GICC &
+ GICV regions
+
+Update the size of GICC and GICV regions to 8kB as the GICC_DIR & GICV_DIR
+registers lie in the second 4kB region. Also, add target CPU encoding.
+
+Fixes: 97cb36ff52a1 ("arm64: dts: qcom: Add ipq9574 SoC and AL02 board support")
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230425084010.15581-2-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 0b8cd6ca0abe..77fd9b02df69 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -166,14 +166,14 @@ blsp1_uart2: serial@78b1000 {
+ 		intc: interrupt-controller@b000000 {
+ 			compatible = "qcom,msm-qgic2";
+ 			reg = <0x0b000000 0x1000>,  /* GICD */
+-			      <0x0b002000 0x1000>,  /* GICC */
++			      <0x0b002000 0x2000>,  /* GICC */
+ 			      <0x0b001000 0x1000>,  /* GICH */
+-			      <0x0b004000 0x1000>;  /* GICV */
++			      <0x0b004000 0x2000>;  /* GICV */
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
+ 			interrupt-controller;
+ 			#interrupt-cells = <3>;
+-			interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
++			interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+ 			ranges = <0 0x0b00c000 0x3000>;
+ 
+ 			v2m0: v2m@0 {
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0016-arm64-dts-qcom-ipq9574-add-support-for-RDP418-varian.patch b/target/linux/ipq95xx/patches-6.1/0016-arm64-dts-qcom-ipq9574-add-support-for-RDP418-varian.patch
new file mode 100644
index 0000000000..118aeb807a
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0016-arm64-dts-qcom-ipq9574-add-support-for-RDP418-varian.patch
@@ -0,0 +1,166 @@
+From e218ade7d728582bce795f6cce6fff39c4107dd5 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Wed, 10 May 2023 16:13:59 +0530
+Subject: [PATCH 16/41] arm64: dts: qcom: ipq9574: add support for RDP418
+ variant
+
+Add the initial device tree support for the Reference Design Platform (RDP)
+418 based on IPQ9574 family of SoCs. This patch adds support for Console
+UART, SPI NOR, eMMC and SMPA1 regulator node.
+
+Co-developed-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230510104359.16678-3-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/Makefile           |   1 +
+ arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts | 124 ++++++++++++++++++++
+ 2 files changed, 125 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts
+
+diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
+index 3754d83ed2cb..c3aaa9e91dce 100644
+--- a/arch/arm64/boot/dts/qcom/Makefile
++++ b/arch/arm64/boot/dts/qcom/Makefile
+@@ -7,6 +7,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= ipq6018-cp01-c1.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk01.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c1.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c2.dtb
++dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp418.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp433.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-idol347.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z00l.dtb
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts
+new file mode 100644
+index 000000000000..2b093e02637b
+--- /dev/null
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts
+@@ -0,0 +1,124 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
++/*
++ * IPQ9574 RDP418 board device tree source
++ *
++ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
++ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++/dts-v1/;
++
++#include "ipq9574.dtsi"
++
++/ {
++	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C2";
++	compatible = "qcom,ipq9574-ap-al02-c2", "qcom,ipq9574";
++
++	aliases {
++		serial0 = &blsp1_uart2;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++};
++
++&blsp1_spi0 {
++	pinctrl-0 = <&spi_0_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++
++	flash@0 {
++		compatible = "micron,n25q128a11", "jedec,spi-nor";
++		reg = <0>;
++		#address-cells = <1>;
++		#size-cells = <1>;
++		spi-max-frequency = <50000000>;
++	};
++};
++
++&blsp1_uart2 {
++	pinctrl-0 = <&uart2_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++};
++
++&rpm_requests {
++	regulators {
++		compatible = "qcom,rpm-mp5496-regulators";
++
++		ipq9574_s1: s1 {
++		/*
++		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
++		 * During regulator registration, kernel not knowing the initial voltage,
++		 * considers it as zero and brings up the regulators with minimum supported voltage.
++		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
++		 * the regulators are brought up with 725mV which is sufficient for all the
++		 * corner parts to operate at 800MHz
++		 */
++			regulator-min-microvolt = <725000>;
++			regulator-max-microvolt = <1075000>;
++		};
++	};
++};
++
++&sdhc_1 {
++	pinctrl-0 = <&sdc_default_state>;
++	pinctrl-names = "default";
++	mmc-ddr-1_8v;
++	mmc-hs200-1_8v;
++	mmc-hs400-1_8v;
++	mmc-hs400-enhanced-strobe;
++	max-frequency = <384000000>;
++	bus-width = <8>;
++	status = "okay";
++};
++
++&sleep_clk {
++	clock-frequency = <32000>;
++};
++
++&tlmm {
++	sdc_default_state: sdc-default-state {
++		clk-pins {
++			pins = "gpio5";
++			function = "sdc_clk";
++			drive-strength = <8>;
++			bias-disable;
++		};
++
++		cmd-pins {
++			pins = "gpio4";
++			function = "sdc_cmd";
++			drive-strength = <8>;
++			bias-pull-up;
++		};
++
++		data-pins {
++			pins = "gpio0", "gpio1", "gpio2",
++			       "gpio3", "gpio6", "gpio7",
++			       "gpio8", "gpio9";
++			function = "sdc_data";
++			drive-strength = <8>;
++			bias-pull-up;
++		};
++
++		rclk-pins {
++			pins = "gpio10";
++			function = "sdc_rclk";
++			drive-strength = <8>;
++			bias-pull-down;
++		};
++	};
++
++	spi_0_pins: spi-0-state {
++		pins = "gpio11", "gpio12", "gpio13", "gpio14";
++		function = "blsp0_spi";
++		drive-strength = <8>;
++		bias-disable;
++	};
++};
++
++&xo_board_clk {
++	clock-frequency = <24000000>;
++};
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0017-arm64-dts-qcom-ipq9574-Add-SMEM-support.patch b/target/linux/ipq95xx/patches-6.1/0017-arm64-dts-qcom-ipq9574-Add-SMEM-support.patch
new file mode 100644
index 0000000000..d6b1156c67
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0017-arm64-dts-qcom-ipq9574-Add-SMEM-support.patch
@@ -0,0 +1,48 @@
+From dcd3cd850131c36cc52ccee74e509d6cf194af2b Mon Sep 17 00:00:00 2001
+From: Poovendhan Selvaraj <quic_poovendh@quicinc.com>
+Date: Thu, 11 May 2023 13:28:14 +0530
+Subject: [PATCH 17/41] arm64: dts: qcom: ipq9574: Add SMEM support
+
+Add the required nodes to support SMEM
+
+Signed-off-by: Poovendhan Selvaraj <quic_poovendh@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230511075814.2370-3-quic_poovendh@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 77fd9b02df69..a8ce148e52e4 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -94,6 +94,13 @@ tz_region: tz@4a600000 {
+ 			reg = <0x0 0x4a600000 0x0 0x400000>;
+ 			no-map;
+ 		};
++
++		smem@4aa00000 {
++			compatible = "qcom,smem";
++			reg = <0x0 0x4aa00000 0x0 0x00100000>;
++			hwlocks = <&tcsr_mutex 0>;
++			no-map;
++		};
+ 	};
+ 
+ 	soc: soc@0 {
+@@ -136,6 +143,12 @@ gcc: clock-controller@1800000 {
+ 			#power-domain-cells = <1>;
+ 		};
+ 
++		tcsr_mutex: hwlock@1905000 {
++			compatible = "qcom,tcsr-mutex";
++			reg = <0x01905000 0x20000>;
++			#hwlock-cells = <1>;
++		};
++
+ 		sdhc_1: mmc@7804000 {
+ 			compatible = "qcom,ipq9574-sdhci", "qcom,sdhci-msm-v5";
+ 			reg = <0x07804000 0x1000>, <0x07805000 0x1000>;
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0018-arm64-dts-qcom-ipq9574-add-support-for-RDP449-varian.patch b/target/linux/ipq95xx/patches-6.1/0018-arm64-dts-qcom-ipq9574-add-support-for-RDP449-varian.patch
new file mode 100644
index 0000000000..4d2d3fdf50
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0018-arm64-dts-qcom-ipq9574-add-support-for-RDP449-varian.patch
@@ -0,0 +1,121 @@
+From 013dab443b763648d450931df3f73a6c783c8197 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Tue, 16 May 2023 19:20:13 +0530
+Subject: [PATCH 18/41] arm64: dts: qcom: ipq9574: add support for RDP449
+ variant
+
+Add the initial device tree support for the Reference Design Platform (RDP)
+449 based on IPQ9574 family of SoCs. This patch adds support for Console
+UART, SPI NOR and SMPA1 regulator node.
+
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230516135013.3547-3-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/Makefile           |  1 +
+ arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts | 80 +++++++++++++++++++++
+ 2 files changed, 81 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts
+
+diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
+index c3aaa9e91dce..f237a3683ca4 100644
+--- a/arch/arm64/boot/dts/qcom/Makefile
++++ b/arch/arm64/boot/dts/qcom/Makefile
+@@ -9,6 +9,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c1.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c2.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp418.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp433.dtb
++dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp449.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-idol347.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z00l.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-g7.dtb
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts
+new file mode 100644
+index 000000000000..c8fa54e1a62c
+--- /dev/null
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts
+@@ -0,0 +1,80 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
++/*
++ * IPQ9574 RDP449 board device tree source
++ *
++ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
++ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++/dts-v1/;
++
++#include "ipq9574.dtsi"
++
++/ {
++	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C6";
++	compatible = "qcom,ipq9574-ap-al02-c6", "qcom,ipq9574";
++
++	aliases {
++		serial0 = &blsp1_uart2;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++};
++
++&blsp1_spi0 {
++	pinctrl-0 = <&spi_0_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++
++	flash@0 {
++		compatible = "micron,n25q128a11", "jedec,spi-nor";
++		reg = <0>;
++		#address-cells = <1>;
++		#size-cells = <1>;
++		spi-max-frequency = <50000000>;
++	};
++};
++
++&blsp1_uart2 {
++	pinctrl-0 = <&uart2_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++};
++
++&rpm_requests {
++	regulators {
++		compatible = "qcom,rpm-mp5496-regulators";
++
++		ipq9574_s1: s1 {
++		/*
++		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
++		 * During regulator registration, kernel not knowing the initial voltage,
++		 * considers it as zero and brings up the regulators with minimum supported voltage.
++		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
++		 * the regulators are brought up with 725mV which is sufficient for all the
++		 * corner parts to operate at 800MHz
++		 */
++			regulator-min-microvolt = <725000>;
++			regulator-max-microvolt = <1075000>;
++		};
++	};
++};
++
++&sleep_clk {
++	clock-frequency = <32000>;
++};
++
++&tlmm {
++	spi_0_pins: spi-0-state {
++		pins = "gpio11", "gpio12", "gpio13", "gpio14";
++		function = "blsp0_spi";
++		drive-strength = <8>;
++		bias-disable;
++	};
++};
++
++&xo_board_clk {
++	clock-frequency = <24000000>;
++};
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0019-arm64-dts-qcom-ipq9574-Add-cpufreq-support.patch b/target/linux/ipq95xx/patches-6.1/0019-arm64-dts-qcom-ipq9574-Add-cpufreq-support.patch
new file mode 100644
index 0000000000..938dee32dc
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0019-arm64-dts-qcom-ipq9574-Add-cpufreq-support.patch
@@ -0,0 +1,127 @@
+From 13ad51cfa78defdafd717ed89785c7bab8330a7b Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Wed, 17 May 2023 22:55:27 +0530
+Subject: [PATCH 19/41] arm64: dts: qcom: ipq9574: Add cpufreq support
+
+Add cpu freq nodes in the device tree to bump cpu frequency above 800MHz.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Co-developed-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230517172527.1968-4-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 60 ++++++++++++++++++++++++++-
+ 1 file changed, 59 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index a8ce148e52e4..2d0a10f6c302 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -6,8 +6,9 @@
+  * Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
+  */
+ 
+-#include <dt-bindings/interrupt-controller/arm-gic.h>
++#include <dt-bindings/clock/qcom,apss-ipq.h>
+ #include <dt-bindings/clock/qcom,ipq9574-gcc.h>
++#include <dt-bindings/interrupt-controller/arm-gic.h>
+ #include <dt-bindings/reset/qcom,ipq9574-gcc.h>
+ 
+ / {
+@@ -37,6 +38,10 @@ CPU0: cpu@0 {
+ 			reg = <0x0>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&L2_0>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			clock-names = "cpu";
++			operating-points-v2 = <&cpu_opp_table>;
++			cpu-supply = <&ipq9574_s1>;
+ 		};
+ 
+ 		CPU1: cpu@1 {
+@@ -45,6 +50,10 @@ CPU1: cpu@1 {
+ 			reg = <0x1>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&L2_0>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			clock-names = "cpu";
++			operating-points-v2 = <&cpu_opp_table>;
++			cpu-supply = <&ipq9574_s1>;
+ 		};
+ 
+ 		CPU2: cpu@2 {
+@@ -53,6 +62,10 @@ CPU2: cpu@2 {
+ 			reg = <0x2>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&L2_0>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			clock-names = "cpu";
++			operating-points-v2 = <&cpu_opp_table>;
++			cpu-supply = <&ipq9574_s1>;
+ 		};
+ 
+ 		CPU3: cpu@3 {
+@@ -61,6 +74,10 @@ CPU3: cpu@3 {
+ 			reg = <0x3>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&L2_0>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			clock-names = "cpu";
++			operating-points-v2 = <&cpu_opp_table>;
++			cpu-supply = <&ipq9574_s1>;
+ 		};
+ 
+ 		L2_0: l2-cache {
+@@ -75,6 +92,47 @@ memory@40000000 {
+ 		reg = <0x0 0x40000000 0x0 0x0>;
+ 	};
+ 
++	cpu_opp_table: opp-table-cpu {
++		compatible = "operating-points-v2";
++		opp-shared;
++
++		opp-936000000 {
++			opp-hz = /bits/ 64 <936000000>;
++			opp-microvolt = <725000>;
++			clock-latency-ns = <200000>;
++		};
++
++		opp-1104000000 {
++			opp-hz = /bits/ 64 <1104000000>;
++			opp-microvolt = <787500>;
++			clock-latency-ns = <200000>;
++		};
++
++		opp-1416000000 {
++			opp-hz = /bits/ 64 <1416000000>;
++			opp-microvolt = <862500>;
++			clock-latency-ns = <200000>;
++		};
++
++		opp-1488000000 {
++			opp-hz = /bits/ 64 <1488000000>;
++			opp-microvolt = <925000>;
++			clock-latency-ns = <200000>;
++		};
++
++		opp-1800000000 {
++			opp-hz = /bits/ 64 <1800000000>;
++			opp-microvolt = <987500>;
++			clock-latency-ns = <200000>;
++		};
++
++		opp-2208000000 {
++			opp-hz = /bits/ 64 <2208000000>;
++			opp-microvolt = <1062500>;
++			clock-latency-ns = <200000>;
++		};
++	};
++
+ 	pmu {
+ 		compatible = "arm,cortex-a73-pmu";
+ 		interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0020-arm64-dts-qcom-ipq9574-Add-SMPA1-regulator-node.patch b/target/linux/ipq95xx/patches-6.1/0020-arm64-dts-qcom-ipq9574-Add-SMPA1-regulator-node.patch
new file mode 100644
index 0000000000..f4a471b75a
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0020-arm64-dts-qcom-ipq9574-Add-SMPA1-regulator-node.patch
@@ -0,0 +1,50 @@
+From d02b30b6e397d2ab09a703bb873fe722406ab06a Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Wed, 17 May 2023 22:55:26 +0530
+Subject: [PATCH 20/41] arm64: dts: qcom: ipq9574: Add SMPA1 regulator node
+
+Add support for SMPA1 regulator node in IPQ9574.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Co-developed-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230517172527.1968-3-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts | 19 +++++++++++++++++++
+ 1 file changed, 19 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
+index 2ce8e09e7565..2b3ed8d351f7 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
+@@ -29,6 +29,25 @@ &blsp1_uart2 {
+ 	status = "okay";
+ };
+ 
++&rpm_requests {
++	regulators {
++		compatible = "qcom,rpm-mp5496-regulators";
++
++		ipq9574_s1: s1 {
++		/*
++		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
++		 * During regulator registration, kernel not knowing the initial voltage,
++		 * considers it as zero and brings up the regulators with minimum supported voltage.
++		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
++		 * the regulators are brought up with 725mV which is sufficient for all the
++		 * corner parts to operate at 800MHz
++		 */
++			regulator-min-microvolt = <725000>;
++			regulator-max-microvolt = <1075000>;
++		};
++	};
++};
++
+ &sdhc_1 {
+ 	pinctrl-0 = <&sdc_default_state>;
+ 	pinctrl-names = "default";
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0021-arm64-dts-qcom-ipq9574-Add-RPM-related-nodes.patch b/target/linux/ipq95xx/patches-6.1/0021-arm64-dts-qcom-ipq9574-Add-RPM-related-nodes.patch
new file mode 100644
index 0000000000..c1fc3b23c5
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0021-arm64-dts-qcom-ipq9574-Add-RPM-related-nodes.patch
@@ -0,0 +1,55 @@
+From 3ef03d409e8cb97d6659fa7b130b14f1726ea8bb Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Wed, 17 May 2023 22:55:25 +0530
+Subject: [PATCH 21/41] arm64: dts: qcom: ipq9574: Add RPM related nodes
+
+Add RPM Glink & RPM message RAM nodes to support frequency scaling
+on IPQ9574.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Co-developed-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Praveenkumar I <quic_ipkumar@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230517172527.1968-2-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 17 +++++++++++++++++
+ 1 file changed, 17 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 2d0a10f6c302..5d99b9660e33 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -161,12 +161,29 @@ smem@4aa00000 {
+ 		};
+ 	};
+ 
++	rpm-glink {
++		compatible = "qcom,glink-rpm";
++		interrupts = <GIC_SPI 168 IRQ_TYPE_EDGE_RISING>;
++		qcom,rpm-msg-ram = <&rpm_msg_ram>;
++		mboxes = <&apcs_glb 0>;
++
++		rpm_requests: rpm-requests {
++			compatible = "qcom,rpm-ipq9574";
++			qcom,glink-channels = "rpm_requests";
++		};
++	};
++
+ 	soc: soc@0 {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		ranges = <0 0 0 0xffffffff>;
+ 
++		rpm_msg_ram: sram@60000 {
++			compatible = "qcom,rpm-msg-ram";
++			reg = <0x00060000 0x6000>;
++		};
++
+ 		tlmm: pinctrl@1000000 {
+ 			compatible = "qcom,ipq9574-tlmm";
+ 			reg = <0x01000000 0x300000>;
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0022-arm64-dts-qcom-ipq9574-add-few-device-nodes.patch b/target/linux/ipq95xx/patches-6.1/0022-arm64-dts-qcom-ipq9574-add-few-device-nodes.patch
new file mode 100644
index 0000000000..7c91c4a563
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0022-arm64-dts-qcom-ipq9574-add-few-device-nodes.patch
@@ -0,0 +1,252 @@
+From 0a8b1ac041c37115b7d09afeb203ed8900225cd1 Mon Sep 17 00:00:00 2001
+From: Kathiravan T <quic_kathirav@quicinc.com>
+Date: Wed, 17 May 2023 12:58:06 +0530
+Subject: [PATCH 22/41] arm64: dts: qcom: ipq9574: add few device nodes
+
+Add QUP(SPI / I2C) peripheral, PRNG, WDOG and the remaining UART nodes.
+While at it, enable the SPI NOR in RDP433 board.
+
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230517072806.13170-1-quic_kathirav@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 202 ++++++++++++++++++++++++++
+ 1 file changed, 202 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 5d99b9660e33..3bef06ea1c19 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -184,6 +184,13 @@ rpm_msg_ram: sram@60000 {
+ 			reg = <0x00060000 0x6000>;
+ 		};
+ 
++		rng: rng@e3000 {
++			compatible = "qcom,prng-ee";
++			reg = <0x000e3000 0x1000>;
++			clocks = <&gcc GCC_PRNG_AHB_CLK>;
++			clock-names = "core";
++		};
++
+ 		tlmm: pinctrl@1000000 {
+ 			compatible = "qcom,ipq9574-tlmm";
+ 			reg = <0x01000000 0x300000>;
+@@ -241,6 +248,36 @@ sdhc_1: mmc@7804000 {
+ 			status = "disabled";
+ 		};
+ 
++		blsp_dma: dma-controller@7884000 {
++			compatible = "qcom,bam-v1.7.0";
++			reg = <0x07884000 0x2b000>;
++			interrupts = <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "bam_clk";
++			#dma-cells = <1>;
++			qcom,ee = <0>;
++		};
++
++		blsp1_uart0: serial@78af000 {
++			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
++			reg = <0x078af000 0x200>;
++			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_UART1_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			status = "disabled";
++		};
++
++		blsp1_uart1: serial@78b0000 {
++			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
++			reg = <0x078b0000 0x200>;
++			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_UART2_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			status = "disabled";
++		};
++
+ 		blsp1_uart2: serial@78b1000 {
+ 			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
+ 			reg = <0x078b1000 0x200>;
+@@ -251,6 +288,163 @@ blsp1_uart2: serial@78b1000 {
+ 			status = "disabled";
+ 		};
+ 
++		blsp1_uart3: serial@78b2000 {
++			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
++			reg = <0x078b2000 0x200>;
++			interrupts = <GIC_SPI 307 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_UART4_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			status = "disabled";
++		};
++
++		blsp1_uart4: serial@78b3000 {
++			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
++			reg = <0x078b3000 0x200>;
++			interrupts = <GIC_SPI 308 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_UART5_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			status = "disabled";
++		};
++
++		blsp1_uart5: serial@78b4000 {
++			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
++			reg = <0x078b4000 0x200>;
++			interrupts = <GIC_SPI 309 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_UART6_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			status = "disabled";
++		};
++
++		blsp1_spi0: spi@78b5000 {
++			compatible = "qcom,spi-qup-v2.2.1";
++			reg = <0x078b5000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP1_SPI_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 12>, <&blsp_dma 13>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		blsp1_i2c1: i2c@78b6000 {
++			compatible = "qcom,i2c-qup-v2.2.1";
++			reg = <0x078b6000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP2_I2C_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 14>, <&blsp_dma 15>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		blsp1_spi1: spi@78b6000 {
++			compatible = "qcom,spi-qup-v2.2.1";
++			reg = <0x078b6000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP2_SPI_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 14>, <&blsp_dma 15>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		blsp1_i2c2: i2c@78b7000 {
++			compatible = "qcom,i2c-qup-v2.2.1";
++			reg = <0x078b7000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP3_I2C_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 16>, <&blsp_dma 17>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		blsp1_spi2: spi@78b7000 {
++			compatible = "qcom,spi-qup-v2.2.1";
++			reg = <0x078b7000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP3_SPI_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 16>, <&blsp_dma 17>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		blsp1_i2c3: i2c@78b8000 {
++			compatible = "qcom,i2c-qup-v2.2.1";
++			reg = <0x078b8000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP4_I2C_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 18>, <&blsp_dma 19>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		blsp1_spi3: spi@78b8000 {
++			compatible = "qcom,spi-qup-v2.2.1";
++			reg = <0x078b8000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
++			spi-max-frequency = <50000000>;
++			clocks = <&gcc GCC_BLSP1_QUP4_SPI_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 18>, <&blsp_dma 19>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		blsp1_i2c4: i2c@78b9000 {
++			compatible = "qcom,i2c-qup-v2.2.1";
++			reg = <0x078b9000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 299 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP5_I2C_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 20>, <&blsp_dma 21>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		blsp1_spi4: spi@78b9000 {
++			compatible = "qcom,spi-qup-v2.2.1";
++			reg = <0x078b9000 0x600>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <GIC_SPI 299 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP5_SPI_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 20>, <&blsp_dma 21>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
+ 		intc: interrupt-controller@b000000 {
+ 			compatible = "qcom,msm-qgic2";
+ 			reg = <0x0b000000 0x1000>,  /* GICD */
+@@ -301,6 +495,14 @@ a73pll: clock@b116000 {
+ 			clock-names = "xo";
+ 		};
+ 
++		watchdog: watchdog@b017000 {
++			compatible = "qcom,apss-wdt-ipq9574", "qcom,kpss-wdt";
++			reg = <0x0b017000 0x1000>;
++			interrupts = <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>;
++			clocks = <&sleep_clk>;
++			timeout-sec = <30>;
++		};
++
+ 		timer@b120000 {
+ 			compatible = "arm,armv7-timer-mem";
+ 			reg = <0x0b120000 0x1000>;
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0023-arm64-dts-qcom-add-few-more-reserved-memory-region.patch b/target/linux/ipq95xx/patches-6.1/0023-arm64-dts-qcom-add-few-more-reserved-memory-region.patch
new file mode 100644
index 0000000000..7d5cb0fa55
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0023-arm64-dts-qcom-add-few-more-reserved-memory-region.patch
@@ -0,0 +1,99 @@
+From d8dc9c70bb55769ebcf17ed9b1ff085c7fb09bff Mon Sep 17 00:00:00 2001
+From: Vignesh Viswanathan <quic_viswanat@quicinc.com>
+Date: Fri, 26 May 2023 16:36:53 +0530
+Subject: [PATCH 23/41] arm64: dts: qcom: add few more reserved memory region
+
+In IPQ SoCs, bootloader will collect the system RAM contents upon crash
+for the post morterm analysis. If we don't reserve the memory region used
+by bootloader, obviously linux will consume it and upon next boot on
+crash, bootloader will be loaded in the same region, which will lead to
+loose some of the data, sometimes we may miss out critical information.
+So lets reserve the region used by the bootloader.
+
+Similarly SBL copies some data into the reserved region and it will be
+used in the crash scenario. So reserve 1MB for SBL as well.
+
+While at it, drop the size padding in the reserved memory region,
+wherever applicable.
+
+Signed-off-by: Vignesh Viswanathan <quic_viswanat@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230526110653.27777-4-quic_viswanat@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq6018.dtsi | 16 +++++++++++++---
+ arch/arm64/boot/dts/qcom/ipq8074.dtsi | 14 ++++++++++++--
+ 2 files changed, 25 insertions(+), 5 deletions(-)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq6018.dtsi b/arch/arm64/boot/dts/qcom/ipq6018.dtsi
+index c3492a383155..25cc02d30356 100644
+--- a/arch/arm64/boot/dts/qcom/ipq6018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq6018.dtsi
+@@ -150,18 +150,28 @@ rpm_msg_ram: memory@60000 {
+ 			no-map;
+ 		};
+ 
++		bootloader@4a100000 {
++			reg = <0x0 0x4a100000 0x0 0x400000>;
++			no-map;
++		};
++
++		sbl@4a500000 {
++			reg = <0x0 0x4a500000 0x0 0x100000>;
++			no-map;
++		};
++
+ 		tz: memory@4a600000 {
+-			reg = <0x0 0x4a600000 0x0 0x00400000>;
++			reg = <0x0 0x4a600000 0x0 0x400000>;
+ 			no-map;
+ 		};
+ 
+ 		smem_region: memory@4aa00000 {
+-			reg = <0x0 0x4aa00000 0x0 0x00100000>;
++			reg = <0x0 0x4aa00000 0x0 0x100000>;
+ 			no-map;
+ 		};
+ 
+ 		q6_region: memory@4ab00000 {
+-			reg = <0x0 0x4ab00000 0x0 0x05500000>;
++			reg = <0x0 0x4ab00000 0x0 0x5500000>;
+ 			no-map;
+ 		};
+ 	};
+diff --git a/arch/arm64/boot/dts/qcom/ipq8074.dtsi b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+index 3f7cf3fdd319..18e2cbe5687b 100644
+--- a/arch/arm64/boot/dts/qcom/ipq8074.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq8074.dtsi
+@@ -85,17 +85,27 @@ reserved-memory {
+ 		#size-cells = <2>;
+ 		ranges;
+ 
++		bootloader@4a600000 {
++			reg = <0x0 0x4a600000 0x0 0x400000>;
++			no-map;
++		};
++
++		sbl@4aa00000 {
++			reg = <0x0 0x4aa00000 0x0 0x100000>;
++			no-map;
++		};
++
+ 		smem@4ab00000 {
+ 			compatible = "qcom,smem";
+-			reg = <0x0 0x4ab00000 0x0 0x00100000>;
++			reg = <0x0 0x4ab00000 0x0 0x100000>;
+ 			no-map;
+ 
+ 			hwlocks = <&tcsr_mutex 0>;
+ 		};
+ 
+ 		memory@4ac00000 {
++			reg = <0x0 0x4ac00000 0x0 0x400000>;
+ 			no-map;
+-			reg = <0x0 0x4ac00000 0x0 0x00400000>;
+ 		};
+ 	};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0024-arm64-dts-qcom-ipq9574-add-QFPROM-node.patch b/target/linux/ipq95xx/patches-6.1/0024-arm64-dts-qcom-ipq9574-add-QFPROM-node.patch
new file mode 100644
index 0000000000..4c49a6cb95
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0024-arm64-dts-qcom-ipq9574-add-QFPROM-node.patch
@@ -0,0 +1,38 @@
+From 040e839870bb864a62a1e769fdfbbc5de64a724d Mon Sep 17 00:00:00 2001
+From: Kathiravan T <quic_kathirav@quicinc.com>
+Date: Fri, 26 May 2023 18:23:05 +0530
+Subject: [PATCH 24/41] arm64: dts: qcom: ipq9574: add QFPROM node
+
+IPQ9574 has efuse region to determine the various HW quirks. Lets
+add the initial support and the individual fuses will be added as they
+are required.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230526125305.19626-5-quic_kathirav@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 3bef06ea1c19..b6e4a8a73354 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -191,6 +191,13 @@ rng: rng@e3000 {
+ 			clock-names = "core";
+ 		};
+ 
++		qfprom: efuse@a4000 {
++			compatible = "qcom,ipq9574-qfprom", "qcom,qfprom";
++			reg = <0x000a4000 0x5a1>;
++			#address-cells = <1>;
++			#size-cells = <1>;
++		};
++
+ 		tlmm: pinctrl@1000000 {
+ 			compatible = "qcom,ipq9574-tlmm";
+ 			reg = <0x01000000 0x300000>;
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0025-arm64-dts-qcom-ipq9574-add-support-for-RDP453-varian.patch b/target/linux/ipq95xx/patches-6.1/0025-arm64-dts-qcom-ipq9574-add-support-for-RDP453-varian.patch
new file mode 100644
index 0000000000..f50db9dc94
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0025-arm64-dts-qcom-ipq9574-add-support-for-RDP453-varian.patch
@@ -0,0 +1,120 @@
+From cc88e897a8fe19d2a611a51321577c11a7997e68 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Fri, 26 May 2023 21:01:52 +0530
+Subject: [PATCH 25/41] arm64: dts: qcom: ipq9574: add support for RDP453
+ variant
+
+Add the initial device tree support for the Reference Design Platform (RDP)
+453 based on IPQ9574 family of SoCs. This patch adds support for Console
+UART, SPI NOR and SMPA1 regulator node.
+
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230526153152.777-3-quic_devipriy@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/Makefile           |  1 +
+ arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts | 80 +++++++++++++++++++++
+ 2 files changed, 81 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts
+
+diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
+index f237a3683ca4..082a5c975288 100644
+--- a/arch/arm64/boot/dts/qcom/Makefile
++++ b/arch/arm64/boot/dts/qcom/Makefile
+@@ -10,6 +10,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= ipq8074-hk10-c2.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp418.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp433.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp449.dtb
++dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp453.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-idol347.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z00l.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-g7.dtb
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts
+new file mode 100644
+index 000000000000..f01de6628c3b
+--- /dev/null
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts
+@@ -0,0 +1,80 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
++/*
++ * IPQ9574 RDP453 board device tree source
++ *
++ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
++ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++/dts-v1/;
++
++#include "ipq9574.dtsi"
++
++/ {
++	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C8";
++	compatible = "qcom,ipq9574-ap-al02-c8", "qcom,ipq9574";
++
++	aliases {
++		serial0 = &blsp1_uart2;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++};
++
++&blsp1_spi0 {
++	pinctrl-0 = <&spi_0_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++
++	flash@0 {
++		compatible = "micron,n25q128a11", "jedec,spi-nor";
++		reg = <0>;
++		#address-cells = <1>;
++		#size-cells = <1>;
++		spi-max-frequency = <50000000>;
++	};
++};
++
++&blsp1_uart2 {
++	pinctrl-0 = <&uart2_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++};
++
++&rpm_requests {
++	regulators {
++		compatible = "qcom,rpm-mp5496-regulators";
++
++		ipq9574_s1: s1 {
++		/*
++		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
++		 * During regulator registration, kernel not knowing the initial voltage,
++		 * considers it as zero and brings up the regulators with minimum supported voltage.
++		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
++		 * the regulators are brought up with 725mV which is sufficient for all the
++		 * corner parts to operate at 800MHz
++		 */
++			regulator-min-microvolt = <725000>;
++			regulator-max-microvolt = <1075000>;
++		};
++	};
++};
++
++&sleep_clk {
++	clock-frequency = <32000>;
++};
++
++&tlmm {
++	spi_0_pins: spi-0-state {
++		pins = "gpio11", "gpio12", "gpio13", "gpio14";
++		function = "blsp0_spi";
++		drive-strength = <8>;
++		bias-disable;
++	};
++};
++
++&xo_board_clk {
++	clock-frequency = <24000000>;
++};
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0026-arm64-dts-qcom-ipq9574-add-support-for-RDP454-varian.patch b/target/linux/ipq95xx/patches-6.1/0026-arm64-dts-qcom-ipq9574-add-support-for-RDP454-varian.patch
new file mode 100644
index 0000000000..0403ae55ff
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0026-arm64-dts-qcom-ipq9574-add-support-for-RDP454-varian.patch
@@ -0,0 +1,120 @@
+From acd0e1607b9d113fe2240a571358d8bbdb6f2504 Mon Sep 17 00:00:00 2001
+From: Poovendhan Selvaraj <quic_poovendh@quicinc.com>
+Date: Wed, 31 May 2023 08:56:48 +0530
+Subject: [PATCH 26/41] arm64: dts: qcom: ipq9574: add support for RDP454
+ variant
+
+Add the initial device tree support for the Reference Design Platform (RDP)
+454 based on IPQ9574 family of SoCs. This patch adds support for Console
+UART, SPI NOR and SMPA1 regulator node.
+
+Signed-off-by: Poovendhan Selvaraj <quic_poovendh@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230531032648.23816-3-quic_poovendh@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/Makefile           |  1 +
+ arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts | 80 +++++++++++++++++++++
+ 2 files changed, 81 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts
+
+diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
+index 082a5c975288..a3816c25181e 100644
+--- a/arch/arm64/boot/dts/qcom/Makefile
++++ b/arch/arm64/boot/dts/qcom/Makefile
+@@ -11,6 +11,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp418.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp433.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp449.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp453.dtb
++dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp454.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-idol347.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z00l.dtb
+ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-g7.dtb
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts
+new file mode 100644
+index 000000000000..6efae3426cb8
+--- /dev/null
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts
+@@ -0,0 +1,80 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
++/*
++ * IPQ9574 RDP454 board device tree source
++ *
++ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
++ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++/dts-v1/;
++
++#include "ipq9574.dtsi"
++
++/ {
++	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C9";
++	compatible = "qcom,ipq9574-ap-al02-c9", "qcom,ipq9574";
++
++	aliases {
++		serial0 = &blsp1_uart2;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++};
++
++&blsp1_spi0 {
++	pinctrl-0 = <&spi_0_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++
++	flash@0 {
++		compatible = "micron,n25q128a11", "jedec,spi-nor";
++		reg = <0>;
++		#address-cells = <1>;
++		#size-cells = <1>;
++		spi-max-frequency = <50000000>;
++	};
++};
++
++&blsp1_uart2 {
++	pinctrl-0 = <&uart2_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++};
++
++&rpm_requests {
++	regulators {
++		compatible = "qcom,rpm-mp5496-regulators";
++
++		ipq9574_s1: s1 {
++		/*
++		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
++		 * During regulator registration, kernel not knowing the initial voltage,
++		 * considers it as zero and brings up the regulators with minimum supported voltage.
++		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
++		 * the regulators are brought up with 725mV which is sufficient for all the
++		 * corner parts to operate at 800MHz
++		 */
++			regulator-min-microvolt = <725000>;
++			regulator-max-microvolt = <1075000>;
++		};
++	};
++};
++
++&sleep_clk {
++	clock-frequency = <32000>;
++};
++
++&tlmm {
++	spi_0_pins: spi-0-state {
++		pins = "gpio11", "gpio12", "gpio13", "gpio14";
++		function = "blsp0_spi";
++		drive-strength = <8>;
++		bias-disable;
++	};
++};
++
++&xo_board_clk {
++	clock-frequency = <24000000>;
++};
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0027-arm64-dts-qcom-ipq9574-add-few-more-reserved-memory-.patch b/target/linux/ipq95xx/patches-6.1/0027-arm64-dts-qcom-ipq9574-add-few-more-reserved-memory-.patch
new file mode 100644
index 0000000000..e1b7d0da56
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0027-arm64-dts-qcom-ipq9574-add-few-more-reserved-memory-.patch
@@ -0,0 +1,60 @@
+From cf53f8937fa9241f6d873a469c04d509e3062539 Mon Sep 17 00:00:00 2001
+From: Anusha Rao <quic_anusha@quicinc.com>
+Date: Fri, 2 Jun 2023 14:14:31 +0530
+Subject: [PATCH 27/41] arm64: dts: qcom: ipq9574: add few more reserved memory
+ region
+
+In IPQ SoCs, bootloader will collect the system RAM contents upon crash
+for post-morterm analysis. If we don't reserve the memory region used
+by bootloader, obviously linux will consume it and upon next boot on
+crash, bootloader will be loaded in the same region, which will lead to
+loss of some data, sometimes we may miss out critical information.
+So lets reserve the region used by the bootloader.
+
+Similarly SBL copies some data into the reserved region and it will be
+used in the crash scenario. So reserve 1MB for SBL as well.
+
+While at it, drop the size padding in the reserved memory region,
+wherever applicable
+
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Reviewed-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230602084431.19134-1-quic_anusha@quicinc.com
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 12 +++++++++++-
+ 1 file changed, 11 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index b6e4a8a73354..30430133e39a 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -148,6 +148,16 @@ reserved-memory {
+ 		#size-cells = <2>;
+ 		ranges;
+ 
++		bootloader@4a100000 {
++			reg = <0x0 0x4a100000 0x0 0x400000>;
++			no-map;
++		};
++
++		sbl@4a500000 {
++			reg = <0x0 0x4a500000 0x0 0x100000>;
++			no-map;
++		};
++
+ 		tz_region: tz@4a600000 {
+ 			reg = <0x0 0x4a600000 0x0 0x400000>;
+ 			no-map;
+@@ -155,7 +165,7 @@ tz_region: tz@4a600000 {
+ 
+ 		smem@4aa00000 {
+ 			compatible = "qcom,smem";
+-			reg = <0x0 0x4aa00000 0x0 0x00100000>;
++			reg = <0x0 0x4aa00000 0x0 0x100000>;
+ 			hwlocks = <&tcsr_mutex 0>;
+ 			no-map;
+ 		};
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0028-arm64-dts-qcom-ipq9574-Use-assigned-clock-rates-for-.patch b/target/linux/ipq95xx/patches-6.1/0028-arm64-dts-qcom-ipq9574-Use-assigned-clock-rates-for-.patch
new file mode 100644
index 0000000000..2575f6903d
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0028-arm64-dts-qcom-ipq9574-Use-assigned-clock-rates-for-.patch
@@ -0,0 +1,59 @@
+From 366d78e84d2a737d75d72b2fb201aacac3a86696 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 15 Jun 2023 14:18:41 +0530
+Subject: [PATCH 28/41] arm64: dts: qcom: ipq9574: Use assigned-clock-rates for
+ QUP I2C core clks
+
+Use assigned-clock-rates property for configuring the QUP I2C core clocks
+to operate at nominal frequency.
+
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Link: https://lore.kernel.org/r/20230615084841.12375-1-quic_devipriy@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 30430133e39a..ced7779f87ac 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -358,6 +358,8 @@ blsp1_i2c1: i2c@78b6000 {
+ 			clocks = <&gcc GCC_BLSP1_QUP2_I2C_APPS_CLK>,
+ 				 <&gcc GCC_BLSP1_AHB_CLK>;
+ 			clock-names = "core", "iface";
++			assigned-clocks = <&gcc GCC_BLSP1_QUP2_I2C_APPS_CLK>;
++			assigned-clock-rates = <50000000>;
+ 			dmas = <&blsp_dma 14>, <&blsp_dma 15>;
+ 			dma-names = "tx", "rx";
+ 			status = "disabled";
+@@ -386,6 +388,8 @@ blsp1_i2c2: i2c@78b7000 {
+ 			clocks = <&gcc GCC_BLSP1_QUP3_I2C_APPS_CLK>,
+ 				 <&gcc GCC_BLSP1_AHB_CLK>;
+ 			clock-names = "core", "iface";
++			assigned-clocks = <&gcc GCC_BLSP1_QUP3_I2C_APPS_CLK>;
++			assigned-clock-rates = <50000000>;
+ 			dmas = <&blsp_dma 16>, <&blsp_dma 17>;
+ 			dma-names = "tx", "rx";
+ 			status = "disabled";
+@@ -414,6 +418,8 @@ blsp1_i2c3: i2c@78b8000 {
+ 			clocks = <&gcc GCC_BLSP1_QUP4_I2C_APPS_CLK>,
+ 				 <&gcc GCC_BLSP1_AHB_CLK>;
+ 			clock-names = "core", "iface";
++			assigned-clocks = <&gcc GCC_BLSP1_QUP4_I2C_APPS_CLK>;
++			assigned-clock-rates = <50000000>;
+ 			dmas = <&blsp_dma 18>, <&blsp_dma 19>;
+ 			dma-names = "tx", "rx";
+ 			status = "disabled";
+@@ -443,6 +449,8 @@ blsp1_i2c4: i2c@78b9000 {
+ 			clocks = <&gcc GCC_BLSP1_QUP5_I2C_APPS_CLK>,
+ 				 <&gcc GCC_BLSP1_AHB_CLK>;
+ 			clock-names = "core", "iface";
++			assigned-clocks = <&gcc GCC_BLSP1_QUP5_I2C_APPS_CLK>;
++			assigned-clock-rates = <50000000>;
+ 			dmas = <&blsp_dma 20>, <&blsp_dma 21>;
+ 			dma-names = "tx", "rx";
+ 			status = "disabled";
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0029-arm64-dts-qcom-ipq9574-Fix-hwlock-index-for-SMEM.patch b/target/linux/ipq95xx/patches-6.1/0029-arm64-dts-qcom-ipq9574-Fix-hwlock-index-for-SMEM.patch
new file mode 100644
index 0000000000..46eb3c9ce2
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0029-arm64-dts-qcom-ipq9574-Fix-hwlock-index-for-SMEM.patch
@@ -0,0 +1,36 @@
+From 4de55890566a8ca941af940c1ada4826c069969e Mon Sep 17 00:00:00 2001
+From: Vignesh Viswanathan <quic_viswanat@quicinc.com>
+Date: Mon, 4 Sep 2023 22:55:15 +0530
+Subject: [PATCH 29/41] arm64: dts: qcom: ipq9574: Fix hwlock index for SMEM
+
+SMEM uses lock index 3 of the TCSR Mutex hwlock for allocations
+in SMEM region shared by the Host and FW.
+
+Fix the SMEM hwlock index to 3 for IPQ9574.
+
+Cc: stable@vger.kernel.org
+Fixes: 46384ac7a618 ("arm64: dts: qcom: ipq9574: Add SMEM support")
+Signed-off-by: Vignesh Viswanathan <quic_viswanat@quicinc.com>
+Acked-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Link: https://lore.kernel.org/r/20230904172516.479866-5-quic_viswanat@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index ced7779f87ac..3b4ebf165380 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -166,7 +166,7 @@ tz_region: tz@4a600000 {
+ 		smem@4aa00000 {
+ 			compatible = "qcom,smem";
+ 			reg = <0x0 0x4aa00000 0x0 0x100000>;
+-			hwlocks = <&tcsr_mutex 0>;
++			hwlocks = <&tcsr_mutex 3>;
+ 			no-map;
+ 		};
+ 	};
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0030-arm64-dts-qcom-ipq9574-include-the-GPLL0-as-clock-pr.patch b/target/linux/ipq95xx/patches-6.1/0030-arm64-dts-qcom-ipq9574-include-the-GPLL0-as-clock-pr.patch
new file mode 100644
index 0000000000..74e5b6d636
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0030-arm64-dts-qcom-ipq9574-include-the-GPLL0-as-clock-pr.patch
@@ -0,0 +1,40 @@
+From ceeec9e4dbd9561b9483b3ad8648e66eba3c8016 Mon Sep 17 00:00:00 2001
+From: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Date: Thu, 14 Sep 2023 12:30:00 +0530
+Subject: [PATCH 30/41] arm64: dts: qcom: ipq9574: include the GPLL0 as clock
+ provider for mailbox
+
+While the kernel is booting up, APSS clock / CPU clock will be running
+at 800MHz with GPLL0 as source. Once the cpufreq driver is available,
+APSS PLL will be configured to the rate based on the opp table and the
+source also will be changed to APSS_PLL_EARLY. So allow the mailbox to
+consume the GPLL0, with this inclusion, CPU Freq correctly reports that
+CPU is running at 800MHz rather than 24MHz.
+
+Signed-off-by: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Link: https://lore.kernel.org/r/20230913-gpll_cleanup-v2-10-c8ceb1a37680@quicinc.com
+[bjorn: Updated commit message, as requested by Kathiravan]
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 3b4ebf165380..452ac4deed0b 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -507,8 +507,8 @@ apcs_glb: mailbox@b111000 {
+ 				     "qcom,ipq6018-apcs-apps-global";
+ 			reg = <0x0b111000 0x1000>;
+ 			#clock-cells = <1>;
+-			clocks = <&a73pll>, <&xo_board_clk>;
+-			clock-names = "pll", "xo";
++			clocks = <&a73pll>, <&xo_board_clk>, <&gcc GPLL0>;
++			clock-names = "pll", "xo", "gpll0";
+ 			#mbox-cells = <1>;
+ 		};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0031-clk-qcom-apss-ipq6018-add-the-GPLL0-clock-also-as-cl.patch b/target/linux/ipq95xx/patches-6.1/0031-clk-qcom-apss-ipq6018-add-the-GPLL0-clock-also-as-cl.patch
new file mode 100644
index 0000000000..c9a341af11
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0031-clk-qcom-apss-ipq6018-add-the-GPLL0-clock-also-as-cl.patch
@@ -0,0 +1,50 @@
+From 618e80e9a977954c06fd6fa5d65b6f712562bdaf Mon Sep 17 00:00:00 2001
+From: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Date: Thu, 14 Sep 2023 12:29:57 +0530
+Subject: [PATCH 31/41] clk: qcom: apss-ipq6018: add the GPLL0 clock also as
+ clock provider
+
+While the kernel is booting up, APSS PLL will be running at 800MHz with
+GPLL0 as source. Once the cpufreq driver is available, APSS PLL will be
+configured and select the rate based on the opp table and the source will
+be changed to APSS_PLL_EARLY.
+
+Without this patch, CPU Freq driver reports that CPU is running at 24MHz
+instead of the 800MHz.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Tested-by: Robert Marko <robimarko@gmail.com>
+Signed-off-by: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Link: https://lore.kernel.org/r/20230913-gpll_cleanup-v2-7-c8ceb1a37680@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ drivers/clk/qcom/apss-ipq6018.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/drivers/clk/qcom/apss-ipq6018.c b/drivers/clk/qcom/apss-ipq6018.c
+index f2f502e2d5a4..4e13a085a857 100644
+--- a/drivers/clk/qcom/apss-ipq6018.c
++++ b/drivers/clk/qcom/apss-ipq6018.c
+@@ -20,16 +20,19 @@
+ 
+ enum {
+ 	P_XO,
++	P_GPLL0,
+ 	P_APSS_PLL_EARLY,
+ };
+ 
+ static const struct clk_parent_data parents_apcs_alias0_clk_src[] = {
+ 	{ .fw_name = "xo" },
++	{ .fw_name = "gpll0" },
+ 	{ .fw_name = "pll" },
+ };
+ 
+ static const struct parent_map parents_apcs_alias0_clk_src_map[] = {
+ 	{ P_XO, 0 },
++	{ P_GPLL0, 4 },
+ 	{ P_APSS_PLL_EARLY, 5 },
+ };
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0032-clk-qcom-ipq9574-drop-the-CLK_SET_RATE_PARENT-flag-f.patch b/target/linux/ipq95xx/patches-6.1/0032-clk-qcom-ipq9574-drop-the-CLK_SET_RATE_PARENT-flag-f.patch
new file mode 100644
index 0000000000..38bd8a5b51
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0032-clk-qcom-ipq9574-drop-the-CLK_SET_RATE_PARENT-flag-f.patch
@@ -0,0 +1,62 @@
+From f0869d5304a548b18bd0402ed2ebe6e6fa66ec04 Mon Sep 17 00:00:00 2001
+From: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Date: Thu, 14 Sep 2023 12:29:54 +0530
+Subject: [PATCH 32/41] clk: qcom: ipq9574: drop the CLK_SET_RATE_PARENT flag
+ from GPLL clocks
+
+GPLL clock rates are fixed and shouldn't be scaled based on the request
+from dependent clocks. Doing so will result in the unexpected behaviour.
+So drop the CLK_SET_RATE_PARENT flag from the GPLL clocks.
+
+----
+Changes in V2:
+	- No changes
+
+Fixes: d75b82cff488 ("clk: qcom: Add Global Clock Controller driver for IPQ9574")
+Signed-off-by: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Link: https://lore.kernel.org/r/20230913-gpll_cleanup-v2-4-c8ceb1a37680@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ drivers/clk/qcom/gcc-ipq9574.c | 4 ----
+ 1 file changed, 4 deletions(-)
+
+diff --git a/drivers/clk/qcom/gcc-ipq9574.c b/drivers/clk/qcom/gcc-ipq9574.c
+index b2a2d618a5ec..806b8ba9633c 100644
+--- a/drivers/clk/qcom/gcc-ipq9574.c
++++ b/drivers/clk/qcom/gcc-ipq9574.c
+@@ -87,7 +87,6 @@ static struct clk_fixed_factor gpll0_out_main_div2 = {
+ 			&gpll0_main.clkr.hw
+ 		},
+ 		.num_parents = 1,
+-		.flags = CLK_SET_RATE_PARENT,
+ 		.ops = &clk_fixed_factor_ops,
+ 	},
+ };
+@@ -102,7 +101,6 @@ static struct clk_alpha_pll_postdiv gpll0 = {
+ 			&gpll0_main.clkr.hw
+ 		},
+ 		.num_parents = 1,
+-		.flags = CLK_SET_RATE_PARENT,
+ 		.ops = &clk_alpha_pll_postdiv_ro_ops,
+ 	},
+ };
+@@ -132,7 +130,6 @@ static struct clk_alpha_pll_postdiv gpll4 = {
+ 			&gpll4_main.clkr.hw
+ 		},
+ 		.num_parents = 1,
+-		.flags = CLK_SET_RATE_PARENT,
+ 		.ops = &clk_alpha_pll_postdiv_ro_ops,
+ 	},
+ };
+@@ -162,7 +159,6 @@ static struct clk_alpha_pll_postdiv gpll2 = {
+ 			&gpll2_main.clkr.hw
+ 		},
+ 		.num_parents = 1,
+-		.flags = CLK_SET_RATE_PARENT,
+ 		.ops = &clk_alpha_pll_postdiv_ro_ops,
+ 	},
+ };
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0033-firmware-qcom_scm-use-64-bit-calling-convention-only.patch b/target/linux/ipq95xx/patches-6.1/0033-firmware-qcom_scm-use-64-bit-calling-convention-only.patch
new file mode 100644
index 0000000000..b103ec6728
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0033-firmware-qcom_scm-use-64-bit-calling-convention-only.patch
@@ -0,0 +1,53 @@
+From e9449be0c59beb0de16b7719ae5d9555a1a1ada7 Mon Sep 17 00:00:00 2001
+From: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Date: Mon, 25 Sep 2023 13:59:22 +0530
+Subject: [PATCH 33/41] firmware: qcom_scm: use 64-bit calling convention only
+ when client is 64-bit
+
+Per the "SMC calling convention specification", the 64-bit calling
+convention can only be used when the client is 64-bit. Whereas the
+32-bit calling convention can be used by either a 32-bit or a 64-bit
+client.
+
+Currently during SCM probe, irrespective of the client, 64-bit calling
+convention is made, which is incorrect and may lead to the undefined
+behaviour when the client is 32-bit. Let's fix it.
+
+Cc: stable@vger.kernel.org
+Fixes: 9a434cee773a ("firmware: qcom_scm: Dynamically support SMCCC and legacy conventions")
+Reviewed-By: Elliot Berman <quic_eberman@quicinc.com>
+Signed-off-by: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Link: https://lore.kernel.org/r/20230925-scm-v3-1-8790dff6a749@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ drivers/firmware/qcom_scm.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/drivers/firmware/qcom_scm.c b/drivers/firmware/qcom_scm.c
+index 51eb85354c05..58f1a86065dc 100644
+--- a/drivers/firmware/qcom_scm.c
++++ b/drivers/firmware/qcom_scm.c
+@@ -164,6 +164,12 @@ static enum qcom_scm_convention __get_convention(void)
+ 	if (likely(qcom_scm_convention != SMC_CONVENTION_UNKNOWN))
+ 		return qcom_scm_convention;
+ 
++	/*
++	 * Per the "SMC calling convention specification", the 64-bit calling
++	 * convention can only be used when the client is 64-bit, otherwise
++	 * system will encounter the undefined behaviour.
++	 */
++#if IS_ENABLED(CONFIG_ARM64)
+ 	/*
+ 	 * Device isn't required as there is only one argument - no device
+ 	 * needed to dma_map_single to secure world
+@@ -184,6 +190,7 @@ static enum qcom_scm_convention __get_convention(void)
+ 		forced = true;
+ 		goto found;
+ 	}
++#endif
+ 
+ 	probed_convention = SMC_CONVENTION_ARM_32;
+ 	ret = __scm_smc_call(NULL, &desc, probed_convention, &res, true);
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0034-arm64-dts-qcom-ipq9574-Add-common-RDP-dtsi-file.patch b/target/linux/ipq95xx/patches-6.1/0034-arm64-dts-qcom-ipq9574-Add-common-RDP-dtsi-file.patch
new file mode 100644
index 0000000000..f1b55835fc
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0034-arm64-dts-qcom-ipq9574-Add-common-RDP-dtsi-file.patch
@@ -0,0 +1,519 @@
+From 0f868f286529001ee37334815f4962b8a2f283dd Mon Sep 17 00:00:00 2001
+From: Anusha Rao <quic_anusha@quicinc.com>
+Date: Wed, 27 Sep 2023 12:13:18 +0530
+Subject: [PATCH 34/41] arm64: dts: qcom: ipq9574: Add common RDP dtsi file
+
+Add a dtsi file to include interfaces that are common
+across RDPs.
+
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Link: https://lore.kernel.org/r/20230927-common-rdp-v3-1-3d07b3ff6d42@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ .../boot/dts/qcom/ipq9574-rdp-common.dtsi     | 102 ++++++++++++++++++
+ arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts   |  63 +----------
+ arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts   |  38 +------
+ arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts   |  65 +----------
+ arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts   |  65 +----------
+ arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts   |  66 +-----------
+ 6 files changed, 107 insertions(+), 292 deletions(-)
+ create mode 100644 arch/arm64/boot/dts/qcom/ipq9574-rdp-common.dtsi
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp-common.dtsi b/arch/arm64/boot/dts/qcom/ipq9574-rdp-common.dtsi
+new file mode 100644
+index 000000000000..c935ac53efe6
+--- /dev/null
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp-common.dtsi
+@@ -0,0 +1,102 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
++/*
++ * IPQ9574 RDP board common device tree source
++ *
++ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
++ * Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++/dts-v1/;
++
++#include "ipq9574.dtsi"
++
++/ {
++	aliases {
++		serial0 = &blsp1_uart2;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++
++	regulator_fixed_3p3: s3300 {
++		compatible = "regulator-fixed";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++		regulator-always-on;
++		regulator-name = "fixed_3p3";
++	};
++
++	regulator_fixed_0p925: s0925 {
++		compatible = "regulator-fixed";
++		regulator-min-microvolt = <925000>;
++		regulator-max-microvolt = <925000>;
++		regulator-boot-on;
++		regulator-always-on;
++		regulator-name = "fixed_0p925";
++	};
++};
++
++&blsp1_spi0 {
++	pinctrl-0 = <&spi_0_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++
++	flash@0 {
++		compatible = "micron,n25q128a11", "jedec,spi-nor";
++		reg = <0>;
++		#address-cells = <1>;
++		#size-cells = <1>;
++		spi-max-frequency = <50000000>;
++	};
++};
++
++&blsp1_uart2 {
++	pinctrl-0 = <&uart2_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++};
++
++&rpm_requests {
++	regulators {
++		compatible = "qcom,rpm-mp5496-regulators";
++
++		ipq9574_s1: s1 {
++		/*
++		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
++		 * During regulator registration, kernel not knowing the initial voltage,
++		 * considers it as zero and brings up the regulators with minimum supported voltage.
++		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
++		 * the regulators are brought up with 725mV which is sufficient for all the
++		 * corner parts to operate at 800MHz
++		 */
++			regulator-min-microvolt = <725000>;
++			regulator-max-microvolt = <1075000>;
++		};
++
++		mp5496_l2: l2 {
++			regulator-min-microvolt = <1800000>;
++			regulator-max-microvolt = <1800000>;
++			regulator-always-on;
++			regulator-boot-on;
++		};
++	};
++};
++
++&sleep_clk {
++	clock-frequency = <32000>;
++};
++
++&tlmm {
++	spi_0_pins: spi-0-state {
++		pins = "gpio11", "gpio12", "gpio13", "gpio14";
++		function = "blsp0_spi";
++		drive-strength = <8>;
++		bias-disable;
++	};
++};
++
++&xo_board_clk {
++	clock-frequency = <24000000>;
++};
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts
+index 2b093e02637b..f4f9199d4ab1 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp418.dts
+@@ -8,58 +8,12 @@
+ 
+ /dts-v1/;
+ 
+-#include "ipq9574.dtsi"
++#include "ipq9574-rdp-common.dtsi"
+ 
+ / {
+ 	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C2";
+ 	compatible = "qcom,ipq9574-ap-al02-c2", "qcom,ipq9574";
+ 
+-	aliases {
+-		serial0 = &blsp1_uart2;
+-	};
+-
+-	chosen {
+-		stdout-path = "serial0:115200n8";
+-	};
+-};
+-
+-&blsp1_spi0 {
+-	pinctrl-0 = <&spi_0_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-
+-	flash@0 {
+-		compatible = "micron,n25q128a11", "jedec,spi-nor";
+-		reg = <0>;
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		spi-max-frequency = <50000000>;
+-	};
+-};
+-
+-&blsp1_uart2 {
+-	pinctrl-0 = <&uart2_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-};
+-
+-&rpm_requests {
+-	regulators {
+-		compatible = "qcom,rpm-mp5496-regulators";
+-
+-		ipq9574_s1: s1 {
+-		/*
+-		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
+-		 * During regulator registration, kernel not knowing the initial voltage,
+-		 * considers it as zero and brings up the regulators with minimum supported voltage.
+-		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
+-		 * the regulators are brought up with 725mV which is sufficient for all the
+-		 * corner parts to operate at 800MHz
+-		 */
+-			regulator-min-microvolt = <725000>;
+-			regulator-max-microvolt = <1075000>;
+-		};
+-	};
+ };
+ 
+ &sdhc_1 {
+@@ -74,10 +28,6 @@ &sdhc_1 {
+ 	status = "okay";
+ };
+ 
+-&sleep_clk {
+-	clock-frequency = <32000>;
+-};
+-
+ &tlmm {
+ 	sdc_default_state: sdc-default-state {
+ 		clk-pins {
+@@ -110,15 +60,4 @@ rclk-pins {
+ 			bias-pull-down;
+ 		};
+ 	};
+-
+-	spi_0_pins: spi-0-state {
+-		pins = "gpio11", "gpio12", "gpio13", "gpio14";
+-		function = "blsp0_spi";
+-		drive-strength = <8>;
+-		bias-disable;
+-	};
+-};
+-
+-&xo_board_clk {
+-	clock-frequency = <24000000>;
+ };
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
+index 2b3ed8d351f7..16217471893d 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp433.dts
+@@ -8,44 +8,12 @@
+ 
+ /dts-v1/;
+ 
+-#include "ipq9574.dtsi"
++#include "ipq9574-rdp-common.dtsi"
+ 
+ / {
+ 	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C7";
+ 	compatible = "qcom,ipq9574-ap-al02-c7", "qcom,ipq9574";
+ 
+-	aliases {
+-		serial0 = &blsp1_uart2;
+-	};
+-
+-	chosen {
+-		stdout-path = "serial0:115200n8";
+-	};
+-};
+-
+-&blsp1_uart2 {
+-	pinctrl-0 = <&uart2_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-};
+-
+-&rpm_requests {
+-	regulators {
+-		compatible = "qcom,rpm-mp5496-regulators";
+-
+-		ipq9574_s1: s1 {
+-		/*
+-		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
+-		 * During regulator registration, kernel not knowing the initial voltage,
+-		 * considers it as zero and brings up the regulators with minimum supported voltage.
+-		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
+-		 * the regulators are brought up with 725mV which is sufficient for all the
+-		 * corner parts to operate at 800MHz
+-		 */
+-			regulator-min-microvolt = <725000>;
+-			regulator-max-microvolt = <1075000>;
+-		};
+-	};
+ };
+ 
+ &sdhc_1 {
+@@ -97,7 +65,3 @@ rclk-pins {
+ 		};
+ 	};
+ };
+-
+-&xo_board_clk {
+-	clock-frequency = <24000000>;
+-};
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts
+index c8fa54e1a62c..d36d1078763e 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp449.dts
+@@ -8,73 +8,10 @@
+ 
+ /dts-v1/;
+ 
+-#include "ipq9574.dtsi"
++#include "ipq9574-rdp-common.dtsi"
+ 
+ / {
+ 	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C6";
+ 	compatible = "qcom,ipq9574-ap-al02-c6", "qcom,ipq9574";
+ 
+-	aliases {
+-		serial0 = &blsp1_uart2;
+-	};
+-
+-	chosen {
+-		stdout-path = "serial0:115200n8";
+-	};
+-};
+-
+-&blsp1_spi0 {
+-	pinctrl-0 = <&spi_0_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-
+-	flash@0 {
+-		compatible = "micron,n25q128a11", "jedec,spi-nor";
+-		reg = <0>;
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		spi-max-frequency = <50000000>;
+-	};
+-};
+-
+-&blsp1_uart2 {
+-	pinctrl-0 = <&uart2_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-};
+-
+-&rpm_requests {
+-	regulators {
+-		compatible = "qcom,rpm-mp5496-regulators";
+-
+-		ipq9574_s1: s1 {
+-		/*
+-		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
+-		 * During regulator registration, kernel not knowing the initial voltage,
+-		 * considers it as zero and brings up the regulators with minimum supported voltage.
+-		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
+-		 * the regulators are brought up with 725mV which is sufficient for all the
+-		 * corner parts to operate at 800MHz
+-		 */
+-			regulator-min-microvolt = <725000>;
+-			regulator-max-microvolt = <1075000>;
+-		};
+-	};
+-};
+-
+-&sleep_clk {
+-	clock-frequency = <32000>;
+-};
+-
+-&tlmm {
+-	spi_0_pins: spi-0-state {
+-		pins = "gpio11", "gpio12", "gpio13", "gpio14";
+-		function = "blsp0_spi";
+-		drive-strength = <8>;
+-		bias-disable;
+-	};
+-};
+-
+-&xo_board_clk {
+-	clock-frequency = <24000000>;
+ };
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts
+index f01de6628c3b..c30c9fbedf26 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp453.dts
+@@ -8,73 +8,10 @@
+ 
+ /dts-v1/;
+ 
+-#include "ipq9574.dtsi"
++#include "ipq9574-rdp-common.dtsi"
+ 
+ / {
+ 	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C8";
+ 	compatible = "qcom,ipq9574-ap-al02-c8", "qcom,ipq9574";
+ 
+-	aliases {
+-		serial0 = &blsp1_uart2;
+-	};
+-
+-	chosen {
+-		stdout-path = "serial0:115200n8";
+-	};
+-};
+-
+-&blsp1_spi0 {
+-	pinctrl-0 = <&spi_0_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-
+-	flash@0 {
+-		compatible = "micron,n25q128a11", "jedec,spi-nor";
+-		reg = <0>;
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		spi-max-frequency = <50000000>;
+-	};
+-};
+-
+-&blsp1_uart2 {
+-	pinctrl-0 = <&uart2_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-};
+-
+-&rpm_requests {
+-	regulators {
+-		compatible = "qcom,rpm-mp5496-regulators";
+-
+-		ipq9574_s1: s1 {
+-		/*
+-		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
+-		 * During regulator registration, kernel not knowing the initial voltage,
+-		 * considers it as zero and brings up the regulators with minimum supported voltage.
+-		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
+-		 * the regulators are brought up with 725mV which is sufficient for all the
+-		 * corner parts to operate at 800MHz
+-		 */
+-			regulator-min-microvolt = <725000>;
+-			regulator-max-microvolt = <1075000>;
+-		};
+-	};
+-};
+-
+-&sleep_clk {
+-	clock-frequency = <32000>;
+-};
+-
+-&tlmm {
+-	spi_0_pins: spi-0-state {
+-		pins = "gpio11", "gpio12", "gpio13", "gpio14";
+-		function = "blsp0_spi";
+-		drive-strength = <8>;
+-		bias-disable;
+-	};
+-};
+-
+-&xo_board_clk {
+-	clock-frequency = <24000000>;
+ };
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts b/arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts
+index 6efae3426cb8..0dc382f5d5ec 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp454.dts
+@@ -8,73 +8,9 @@
+ 
+ /dts-v1/;
+ 
+-#include "ipq9574.dtsi"
++#include "ipq9574-rdp-common.dtsi"
+ 
+ / {
+ 	model = "Qualcomm Technologies, Inc. IPQ9574/AP-AL02-C9";
+ 	compatible = "qcom,ipq9574-ap-al02-c9", "qcom,ipq9574";
+-
+-	aliases {
+-		serial0 = &blsp1_uart2;
+-	};
+-
+-	chosen {
+-		stdout-path = "serial0:115200n8";
+-	};
+-};
+-
+-&blsp1_spi0 {
+-	pinctrl-0 = <&spi_0_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-
+-	flash@0 {
+-		compatible = "micron,n25q128a11", "jedec,spi-nor";
+-		reg = <0>;
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		spi-max-frequency = <50000000>;
+-	};
+-};
+-
+-&blsp1_uart2 {
+-	pinctrl-0 = <&uart2_pins>;
+-	pinctrl-names = "default";
+-	status = "okay";
+-};
+-
+-&rpm_requests {
+-	regulators {
+-		compatible = "qcom,rpm-mp5496-regulators";
+-
+-		ipq9574_s1: s1 {
+-		/*
+-		 * During kernel bootup, the SoC runs at 800MHz with 875mV set by the bootloaders.
+-		 * During regulator registration, kernel not knowing the initial voltage,
+-		 * considers it as zero and brings up the regulators with minimum supported voltage.
+-		 * Update the regulator-min-microvolt with SVS voltage of 725mV so that
+-		 * the regulators are brought up with 725mV which is sufficient for all the
+-		 * corner parts to operate at 800MHz
+-		 */
+-			regulator-min-microvolt = <725000>;
+-			regulator-max-microvolt = <1075000>;
+-		};
+-	};
+-};
+-
+-&sleep_clk {
+-	clock-frequency = <32000>;
+-};
+-
+-&tlmm {
+-	spi_0_pins: spi-0-state {
+-		pins = "gpio11", "gpio12", "gpio13", "gpio14";
+-		function = "blsp0_spi";
+-		drive-strength = <8>;
+-		bias-disable;
+-	};
+-};
+-
+-&xo_board_clk {
+-	clock-frequency = <24000000>;
+ };
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0035-arm64-dts-qcom-ipq9574-populate-the-opp-table-based-.patch b/target/linux/ipq95xx/patches-6.1/0035-arm64-dts-qcom-ipq9574-populate-the-opp-table-based-.patch
new file mode 100644
index 0000000000..c4eb599500
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0035-arm64-dts-qcom-ipq9574-populate-the-opp-table-based-.patch
@@ -0,0 +1,110 @@
+From f1001470268206073905a37fdba06355eb43d32c Mon Sep 17 00:00:00 2001
+From: Varadarajan Narayanan <quic_varada@quicinc.com>
+Date: Fri, 20 Oct 2023 11:49:39 +0530
+Subject: [PATCH 35/41] arm64: dts: qcom: ipq9574: populate the opp table based
+ on the eFuse
+
+IPQ95xx SoCs have different OPPs available for the CPU based on
+SoC variant. This can be determined from an eFuse register
+present in the silicon.
+
+Add support to read the eFuse and populate the OPPs based on it.
+
+Frequency	1.2GHz	1.8GHz	1.5GHz	No	opp-supported-hw
+					Limit
+------------------------------------------------------------
+936000000	1	1	1	1	0xf
+1104000000	1	1	1	1	0xf
+1200000000	1	1	1	1	0xf
+1416000000	0	1	1	1	0x7
+1488000000	0	1	1	1	0x7
+1800000000	0	1	0	1	0x5
+2208000000	0	0	0	1	0x1
+-----------------------------------------------------------
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Link: https://lore.kernel.org/r/14ab08b7cfd904433ca6065fac798d4f221c9d95.1697781921.git.quic_varada@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq9574.dtsi | 21 ++++++++++++++++++++-
+ 1 file changed, 20 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574.dtsi b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+index 452ac4deed0b..a4123453f5e8 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574.dtsi
+@@ -93,42 +93,56 @@ memory@40000000 {
+ 	};
+ 
+ 	cpu_opp_table: opp-table-cpu {
+-		compatible = "operating-points-v2";
++		compatible = "operating-points-v2-kryo-cpu";
+ 		opp-shared;
++		nvmem-cells = <&cpu_speed_bin>;
+ 
+ 		opp-936000000 {
+ 			opp-hz = /bits/ 64 <936000000>;
+ 			opp-microvolt = <725000>;
++			opp-supported-hw = <0xf>;
+ 			clock-latency-ns = <200000>;
+ 		};
+ 
+ 		opp-1104000000 {
+ 			opp-hz = /bits/ 64 <1104000000>;
+ 			opp-microvolt = <787500>;
++			opp-supported-hw = <0xf>;
++			clock-latency-ns = <200000>;
++		};
++
++		opp-1200000000 {
++			opp-hz = /bits/ 64 <1200000000>;
++			opp-microvolt = <862500>;
++			opp-supported-hw = <0xf>;
+ 			clock-latency-ns = <200000>;
+ 		};
+ 
+ 		opp-1416000000 {
+ 			opp-hz = /bits/ 64 <1416000000>;
+ 			opp-microvolt = <862500>;
++			opp-supported-hw = <0x7>;
+ 			clock-latency-ns = <200000>;
+ 		};
+ 
+ 		opp-1488000000 {
+ 			opp-hz = /bits/ 64 <1488000000>;
+ 			opp-microvolt = <925000>;
++			opp-supported-hw = <0x7>;
+ 			clock-latency-ns = <200000>;
+ 		};
+ 
+ 		opp-1800000000 {
+ 			opp-hz = /bits/ 64 <1800000000>;
+ 			opp-microvolt = <987500>;
++			opp-supported-hw = <0x5>;
+ 			clock-latency-ns = <200000>;
+ 		};
+ 
+ 		opp-2208000000 {
+ 			opp-hz = /bits/ 64 <2208000000>;
+ 			opp-microvolt = <1062500>;
++			opp-supported-hw = <0x1>;
+ 			clock-latency-ns = <200000>;
+ 		};
+ 	};
+@@ -206,6 +220,11 @@ qfprom: efuse@a4000 {
+ 			reg = <0x000a4000 0x5a1>;
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
++
++			cpu_speed_bin: cpu-speed-bin@15 {
++				reg = <0x15 0x2>;
++				bits = <7 2>;
++			};
+ 		};
+ 
+ 		tlmm: pinctrl@1000000 {
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0036-clk-qcom-clk-alpha-pll-introduce-stromer-plus-ops.patch b/target/linux/ipq95xx/patches-6.1/0036-clk-qcom-clk-alpha-pll-introduce-stromer-plus-ops.patch
new file mode 100644
index 0000000000..d4f8544978
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0036-clk-qcom-clk-alpha-pll-introduce-stromer-plus-ops.patch
@@ -0,0 +1,106 @@
+From 539a79c58042c7902bfff6453a589d5dc2e0230c Mon Sep 17 00:00:00 2001
+From: Varadarajan Narayanan <quic_varada@quicinc.com>
+Date: Fri, 20 Oct 2023 11:49:32 +0530
+Subject: [PATCH 36/41] clk: qcom: clk-alpha-pll: introduce stromer plus ops
+
+Stromer plus APSS PLL does not support dynamic frequency scaling.
+To switch between frequencies, we have to shut down the PLL,
+configure the L and ALPHA values and turn on again. So introduce the
+separate set of ops for Stromer Plus PLL.
+
+Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Link: https://lore.kernel.org/r/2affa6c63ff0c4342230623a7d4eef02ec7c02d4.1697781921.git.quic_varada@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ drivers/clk/qcom/clk-alpha-pll.c | 63 ++++++++++++++++++++++++++++++++
+ drivers/clk/qcom/clk-alpha-pll.h |  1 +
+ 2 files changed, 64 insertions(+)
+
+diff --git a/drivers/clk/qcom/clk-alpha-pll.c b/drivers/clk/qcom/clk-alpha-pll.c
+index 8e5e7a26bcc4..56f1795847cd 100644
+--- a/drivers/clk/qcom/clk-alpha-pll.c
++++ b/drivers/clk/qcom/clk-alpha-pll.c
+@@ -2434,3 +2434,66 @@ const struct clk_ops clk_alpha_pll_stromer_ops = {
+ 	.set_rate = clk_alpha_pll_stromer_set_rate,
+ };
+ EXPORT_SYMBOL_GPL(clk_alpha_pll_stromer_ops);
++
++static int clk_alpha_pll_stromer_plus_set_rate(struct clk_hw *hw,
++					       unsigned long rate,
++					       unsigned long prate)
++{
++	struct clk_alpha_pll *pll = to_clk_alpha_pll(hw);
++	u32 l, alpha_width = pll_alpha_width(pll);
++	int ret, pll_mode;
++	u64 a;
++
++	rate = alpha_pll_round_rate(rate, prate, &l, &a, alpha_width);
++
++	ret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &pll_mode);
++	if (ret)
++		return ret;
++
++	regmap_write(pll->clkr.regmap, PLL_MODE(pll), 0);
++
++	/* Delay of 2 output clock ticks required until output is disabled */
++	udelay(1);
++
++	regmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);
++
++	if (alpha_width > ALPHA_BITWIDTH)
++		a <<= alpha_width - ALPHA_BITWIDTH;
++
++	regmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);
++	regmap_write(pll->clkr.regmap, PLL_ALPHA_VAL_U(pll),
++					a >> ALPHA_BITWIDTH);
++
++	regmap_write(pll->clkr.regmap, PLL_MODE(pll), PLL_BYPASSNL);
++
++	/* Wait five micro seconds or more */
++	udelay(5);
++	regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_RESET_N,
++			   PLL_RESET_N);
++
++	/* The lock time should be less than 50 micro seconds worst case */
++	usleep_range(50, 60);
++
++	ret = wait_for_pll_enable_lock(pll);
++	if (ret) {
++		pr_err("Wait for PLL enable lock failed [%s] %d\n",
++		       clk_hw_get_name(hw), ret);
++		return ret;
++	}
++
++	if (pll_mode & PLL_OUTCTRL)
++		regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_OUTCTRL,
++				   PLL_OUTCTRL);
++
++	return 0;
++}
++
++const struct clk_ops clk_alpha_pll_stromer_plus_ops = {
++	.prepare = clk_alpha_pll_enable,
++	.unprepare = clk_alpha_pll_disable,
++	.is_enabled = clk_alpha_pll_is_enabled,
++	.recalc_rate = clk_alpha_pll_recalc_rate,
++	.determine_rate = clk_alpha_pll_stromer_determine_rate,
++	.set_rate = clk_alpha_pll_stromer_plus_set_rate,
++};
++EXPORT_SYMBOL_GPL(clk_alpha_pll_stromer_plus_ops);
+diff --git a/drivers/clk/qcom/clk-alpha-pll.h b/drivers/clk/qcom/clk-alpha-pll.h
+index 51d4043c7e4f..eb072ae7861c 100644
+--- a/drivers/clk/qcom/clk-alpha-pll.h
++++ b/drivers/clk/qcom/clk-alpha-pll.h
+@@ -145,6 +145,7 @@ extern const struct clk_ops clk_alpha_pll_postdiv_ops;
+ extern const struct clk_ops clk_alpha_pll_huayra_ops;
+ extern const struct clk_ops clk_alpha_pll_postdiv_ro_ops;
+ extern const struct clk_ops clk_alpha_pll_stromer_ops;
++extern const struct clk_ops clk_alpha_pll_stromer_plus_ops;
+ 
+ extern const struct clk_ops clk_alpha_pll_fabia_ops;
+ extern const struct clk_ops clk_alpha_pll_fixed_fabia_ops;
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0037-cpufreq-qcom-nvmem-Introduce-cpufreq-for-ipq95xx.patch b/target/linux/ipq95xx/patches-6.1/0037-cpufreq-qcom-nvmem-Introduce-cpufreq-for-ipq95xx.patch
new file mode 100644
index 0000000000..a178ef4d8a
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0037-cpufreq-qcom-nvmem-Introduce-cpufreq-for-ipq95xx.patch
@@ -0,0 +1,74 @@
+From 80838ab7ebd416cbac38c1cd30a76d61641f7ee1 Mon Sep 17 00:00:00 2001
+From: Varadarajan Narayanan <quic_varada@quicinc.com>
+Date: Tue, 31 Oct 2023 12:41:39 +0530
+Subject: [PATCH 37/41] cpufreq: qcom-nvmem: Introduce cpufreq for ipq95xx
+
+IPQ95xx SoCs have different OPPs available for the CPU based on
+the SoC variant. This can be determined from an eFuse register
+present in the silicon.
+
+Added support for ipq95xx on nvmem driver which helps to
+determine OPPs at runtime based on the eFuse register which
+has the CPU frequency limits. opp-supported-hw dt binding
+can be used to indicate the available OPPs for each limit.
+
+Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
+Signed-off-by: Praveenkumar I <ipkumar@codeaurora.org>
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+[ Viresh: Fixed subject ]
+Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
+---
+ drivers/cpufreq/cpufreq-dt-platdev.c | 1 +
+ drivers/cpufreq/qcom-cpufreq-nvmem.c | 5 +++++
+ include/dt-bindings/arm/qcom,ids.h   | 6 ++++++
+ 3 files changed, 12 insertions(+)
+
+diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
+index 69a8742c0a7a..3df1d5747ab7 100644
+--- a/drivers/cpufreq/cpufreq-dt-platdev.c
++++ b/drivers/cpufreq/cpufreq-dt-platdev.c
+@@ -164,6 +164,7 @@ static const struct of_device_id blocklist[] __initconst = {
+ 	{ .compatible = "ti,omap3", },
+ 
+ 	{ .compatible = "qcom,ipq8064", },
++	{ .compatible = "qcom,ipq9574", },
+ 	{ .compatible = "qcom,apq8064", },
+ 	{ .compatible = "qcom,msm8974", },
+ 	{ .compatible = "qcom,msm8960", },
+diff --git a/drivers/cpufreq/qcom-cpufreq-nvmem.c b/drivers/cpufreq/qcom-cpufreq-nvmem.c
+index a88b6fe5db50..902a0557d832 100644
+--- a/drivers/cpufreq/qcom-cpufreq-nvmem.c
++++ b/drivers/cpufreq/qcom-cpufreq-nvmem.c
+@@ -149,6 +149,11 @@ static int qcom_cpufreq_kryo_name_version(struct device *cpu_dev,
+ 	switch (msm_id) {
+ 	case QCOM_ID_MSM8996:
+ 	case QCOM_ID_APQ8096:
++	case QCOM_ID_IPQ9514:
++	case QCOM_ID_IPQ9550:
++	case QCOM_ID_IPQ9554:
++	case QCOM_ID_IPQ9570:
++	case QCOM_ID_IPQ9574:
+ 		drv->versions = 1 << (unsigned int)(*speedbin);
+ 		break;
+ 	case QCOM_ID_MSM8996SG:
+diff --git a/include/dt-bindings/arm/qcom,ids.h b/include/dt-bindings/arm/qcom,ids.h
+index 755e08d494c5..7e77a7d84e2a 100644
+--- a/include/dt-bindings/arm/qcom,ids.h
++++ b/include/dt-bindings/arm/qcom,ids.h
+@@ -140,6 +140,12 @@
+ #define QCOM_ID_SC7280			487
+ #define QCOM_ID_SC7180P			495
+ #define QCOM_ID_SM6375			507
++#define QCOM_ID_IPQ9514			510
++#define QCOM_ID_IPQ9550			511
++#define QCOM_ID_IPQ9554			512
++#define QCOM_ID_IPQ9570			513
++#define QCOM_ID_IPQ9574			514
++#define QCOM_ID_IPQ9510			521
+ 
+ /*
+  * The board type and revision information, used by Qualcomm bootloaders and
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0038-arm64-dts-qcom-ipq9574-Enable-WPS-buttons.patch b/target/linux/ipq95xx/patches-6.1/0038-arm64-dts-qcom-ipq9574-Enable-WPS-buttons.patch
new file mode 100644
index 0000000000..6e3c85529c
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0038-arm64-dts-qcom-ipq9574-Enable-WPS-buttons.patch
@@ -0,0 +1,66 @@
+From ff1925f7070d4cc3c5772565672632854444317e Mon Sep 17 00:00:00 2001
+From: Anusha Rao <quic_anusha@quicinc.com>
+Date: Wed, 27 Sep 2023 12:13:19 +0530
+Subject: [PATCH 38/41] arm64: dts: qcom: ipq9574: Enable WPS buttons
+
+Add support for wps buttons on GPIO 37.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Link: https://lore.kernel.org/r/20230927-common-rdp-v3-2-3d07b3ff6d42@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ .../boot/dts/qcom/ipq9574-rdp-common.dtsi     | 22 +++++++++++++++++++
+ 1 file changed, 22 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/qcom/ipq9574-rdp-common.dtsi b/arch/arm64/boot/dts/qcom/ipq9574-rdp-common.dtsi
+index c935ac53efe6..526f0dbbdbe9 100644
+--- a/arch/arm64/boot/dts/qcom/ipq9574-rdp-common.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq9574-rdp-common.dtsi
+@@ -8,6 +8,8 @@
+ 
+ /dts-v1/;
+ 
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/input.h>
+ #include "ipq9574.dtsi"
+ 
+ / {
+@@ -36,6 +38,19 @@ regulator_fixed_0p925: s0925 {
+ 		regulator-always-on;
+ 		regulator-name = "fixed_0p925";
+ 	};
++
++	gpio-keys {
++		compatible = "gpio-keys";
++		pinctrl-0 = <&gpio_keys_default>;
++		pinctrl-names = "default";
++
++		button-wps {
++			label = "wps";
++			linux,code = <KEY_WPS_BUTTON>;
++			gpios = <&tlmm 37 GPIO_ACTIVE_LOW>;
++			debounce-interval = <60>;
++		};
++	};
+ };
+ 
+ &blsp1_spi0 {
+@@ -95,6 +110,13 @@ spi_0_pins: spi-0-state {
+ 		drive-strength = <8>;
+ 		bias-disable;
+ 	};
++
++	gpio_keys_default: gpio-keys-default-state {
++		pins = "gpio37";
++		function = "gpio";
++		drive-strength = <8>;
++		bias-pull-up;
++	};
+ };
+ 
+ &xo_board_clk {
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0039-clk-qcom-apss-ipq-pll-add-support-for-IPQ5332.patch b/target/linux/ipq95xx/patches-6.1/0039-clk-qcom-apss-ipq-pll-add-support-for-IPQ5332.patch
new file mode 100644
index 0000000000..57c572dea3
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0039-clk-qcom-apss-ipq-pll-add-support-for-IPQ5332.patch
@@ -0,0 +1,131 @@
+From 7b20271bc8c2982ab1e7bcfcf896ca5320b16a6f Mon Sep 17 00:00:00 2001
+From: Kathiravan T <quic_kathirav@quicinc.com>
+Date: Fri, 17 Feb 2023 14:03:06 +0530
+Subject: [PATCH 39/41] clk: qcom: apss-ipq-pll: add support for IPQ5332
+
+IPQ5332 APSS PLL is of type Stromer Plus. Add support for the same.
+
+To configure the stromer plus PLL separate API
+(clock_stromer_pll_configure) to be used. To achieve this, introduce the
+new member pll_type in device data structure and call the appropriate
+function based on this.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230217083308.12017-4-quic_kathirav@quicinc.com
+---
+ drivers/clk/qcom/apss-ipq-pll.c | 59 ++++++++++++++++++++++++++++++++-
+ 1 file changed, 58 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/clk/qcom/apss-ipq-pll.c b/drivers/clk/qcom/apss-ipq-pll.c
+index 56f33af11311..4ec347f0e8b1 100644
+--- a/drivers/clk/qcom/apss-ipq-pll.c
++++ b/drivers/clk/qcom/apss-ipq-pll.c
+@@ -24,6 +24,18 @@ static const u8 ipq_pll_offsets[][PLL_OFF_MAX_REGS] = {
+ 		[PLL_OFF_TEST_CTL] = 0x30,
+ 		[PLL_OFF_TEST_CTL_U] = 0x34,
+ 	},
++
++	[CLK_ALPHA_PLL_TYPE_STROMER_PLUS] = {
++		[PLL_OFF_L_VAL] = 0x08,
++		[PLL_OFF_ALPHA_VAL] = 0x10,
++		[PLL_OFF_ALPHA_VAL_U] = 0x14,
++		[PLL_OFF_USER_CTL] = 0x18,
++		[PLL_OFF_USER_CTL_U] = 0x1c,
++		[PLL_OFF_CONFIG_CTL] = 0x20,
++		[PLL_OFF_STATUS] = 0x28,
++		[PLL_OFF_TEST_CTL] = 0x30,
++		[PLL_OFF_TEST_CTL_U] = 0x34,
++	},
+ };
+ 
+ static struct clk_alpha_pll ipq_pll_huayra = {
+@@ -44,6 +56,38 @@ static struct clk_alpha_pll ipq_pll_huayra = {
+ 	},
+ };
+ 
++static struct clk_alpha_pll ipq_pll_stromer_plus = {
++	.offset = 0x0,
++	.regs = ipq_pll_offsets[CLK_ALPHA_PLL_TYPE_STROMER_PLUS],
++	.flags = SUPPORTS_DYNAMIC_UPDATE,
++	.clkr = {
++		.enable_reg = 0x0,
++		.enable_mask = BIT(0),
++		.hw.init = &(struct clk_init_data){
++			.name = "a53pll",
++			.parent_data = &(const struct clk_parent_data) {
++				.fw_name = "xo",
++			},
++			.num_parents = 1,
++			.ops = &clk_alpha_pll_stromer_ops,
++		},
++	},
++};
++
++static const struct alpha_pll_config ipq5332_pll_config = {
++	.l = 0x3e,
++	.config_ctl_val = 0x4001075b,
++	.config_ctl_hi_val = 0x304,
++	.main_output_mask = BIT(0),
++	.aux_output_mask = BIT(1),
++	.early_output_mask = BIT(3),
++	.alpha_en_mask = BIT(24),
++	.status_val = 0x3,
++	.status_mask = GENMASK(10, 8),
++	.lock_det = BIT(2),
++	.test_ctl_hi_val = 0x00400003,
++};
++
+ static const struct alpha_pll_config ipq6018_pll_config = {
+ 	.l = 0x37,
+ 	.config_ctl_val = 0x240d4828,
+@@ -81,16 +125,25 @@ static const struct alpha_pll_config ipq9574_pll_config = {
+ };
+ 
+ struct apss_pll_data {
++	int pll_type;
+ 	struct clk_alpha_pll *pll;
+ 	const struct alpha_pll_config *pll_config;
+ };
+ 
++static struct apss_pll_data ipq5332_pll_data = {
++	.pll_type = CLK_ALPHA_PLL_TYPE_STROMER_PLUS,
++	.pll = &ipq_pll_stromer_plus,
++	.pll_config = &ipq5332_pll_config,
++};
++
+ static struct apss_pll_data ipq8074_pll_data = {
++	.pll_type = CLK_ALPHA_PLL_TYPE_HUAYRA,
+ 	.pll = &ipq_pll_huayra,
+ 	.pll_config = &ipq8074_pll_config,
+ };
+ 
+ static struct apss_pll_data ipq6018_pll_data = {
++	.pll_type = CLK_ALPHA_PLL_TYPE_HUAYRA,
+ 	.pll = &ipq_pll_huayra,
+ 	.pll_config = &ipq6018_pll_config,
+ };
+@@ -129,7 +182,10 @@ static int apss_ipq_pll_probe(struct platform_device *pdev)
+ 	if (!data)
+ 		return -ENODEV;
+ 
+-	clk_alpha_pll_configure(data->pll, regmap, data->pll_config);
++	if (data->pll_type == CLK_ALPHA_PLL_TYPE_HUAYRA)
++		clk_alpha_pll_configure(data->pll, regmap, data->pll_config);
++	else if (data->pll_type == CLK_ALPHA_PLL_TYPE_STROMER_PLUS)
++		clk_stromer_pll_configure(data->pll, regmap, data->pll_config);
+ 
+ 	ret = devm_clk_register_regmap(dev, &data->pll->clkr);
+ 	if (ret)
+@@ -140,6 +196,7 @@ static int apss_ipq_pll_probe(struct platform_device *pdev)
+ }
+ 
+ static const struct of_device_id apss_ipq_pll_match_table[] = {
++	{ .compatible = "qcom,ipq5332-a53pll", .data = &ipq5332_pll_data },
+ 	{ .compatible = "qcom,ipq6018-a53pll", .data = &ipq6018_pll_data },
+ 	{ .compatible = "qcom,ipq8074-a53pll", .data = &ipq8074_pll_data },
+ 	{ .compatible = "qcom,ipq9574-a73pll", .data = &ipq9574_pll_data },
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0040-clk-qcom-apss-ipq-pll-Use-stromer-plus-ops-for-strom.patch b/target/linux/ipq95xx/patches-6.1/0040-clk-qcom-apss-ipq-pll-Use-stromer-plus-ops-for-strom.patch
new file mode 100644
index 0000000000..7efaad2da4
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0040-clk-qcom-apss-ipq-pll-Use-stromer-plus-ops-for-strom.patch
@@ -0,0 +1,39 @@
+From 998d251c67072059c80a5747d19e8c34a154a213 Mon Sep 17 00:00:00 2001
+From: Varadarajan Narayanan <quic_varada@quicinc.com>
+Date: Fri, 20 Oct 2023 11:49:33 +0530
+Subject: [PATCH 40/41] clk: qcom: apss-ipq-pll: Use stromer plus ops for
+ stromer plus pll
+
+The set rate and determine rate operations are different between
+Stromer and Stromer Plus PLLs. Since the programming sequence is
+different, the PLLs dont get configured properly and random,
+inexplicable crash/freeze is seen. Hence, use stromer plus ops
+for ipq_pll_stromer_plus.
+
+Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
+Acked-by: Stephen Boyd <sboyd@kernel.org>
+Fixes: c7ef7fbb1ccf ("clk: qcom: apss-ipq-pll: add support for IPQ5332")
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Link: https://lore.kernel.org/r/c86ecaa23dc4f39650bcf4a3bd54a617a932e4fd.1697781921.git.quic_varada@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ drivers/clk/qcom/apss-ipq-pll.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/clk/qcom/apss-ipq-pll.c b/drivers/clk/qcom/apss-ipq-pll.c
+index 4ec347f0e8b1..87547db3bfb3 100644
+--- a/drivers/clk/qcom/apss-ipq-pll.c
++++ b/drivers/clk/qcom/apss-ipq-pll.c
+@@ -69,7 +69,7 @@ static struct clk_alpha_pll ipq_pll_stromer_plus = {
+ 				.fw_name = "xo",
+ 			},
+ 			.num_parents = 1,
+-			.ops = &clk_alpha_pll_stromer_ops,
++			.ops = &clk_alpha_pll_stromer_plus_ops,
+ 		},
+ 	},
+ };
+-- 
+2.34.1
+
diff --git a/target/linux/ipq95xx/patches-6.1/0041-clk-qcom-Add-STROMER-PLUS-PLL-type-for-IPQ5332.patch b/target/linux/ipq95xx/patches-6.1/0041-clk-qcom-Add-STROMER-PLUS-PLL-type-for-IPQ5332.patch
new file mode 100644
index 0000000000..65b2de6195
--- /dev/null
+++ b/target/linux/ipq95xx/patches-6.1/0041-clk-qcom-Add-STROMER-PLUS-PLL-type-for-IPQ5332.patch
@@ -0,0 +1,55 @@
+From d10112948b0ff58b749f6f89a963185a190ce885 Mon Sep 17 00:00:00 2001
+From: Kathiravan T <quic_kathirav@quicinc.com>
+Date: Tue, 7 Mar 2023 11:52:25 +0530
+Subject: [PATCH 41/41] clk: qcom: Add STROMER PLUS PLL type for IPQ5332
+
+Add the support for stromer plus pll, which is found on the IPQ5332
+SoCs. Programming sequence is same as the stromer pll, so we can re-use
+the same.
+
+Reviewed-by: Stephen Boyd <sboyd@kernel.org>
+Signed-off-by: Kathiravan T <quic_kathirav@quicinc.com>
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+Link: https://lore.kernel.org/r/20230307062232.4889-3-quic_kathirav@quicinc.com
+---
+ drivers/clk/qcom/clk-alpha-pll.c | 11 +++++++++++
+ drivers/clk/qcom/clk-alpha-pll.h |  1 +
+ 2 files changed, 12 insertions(+)
+
+diff --git a/drivers/clk/qcom/clk-alpha-pll.c b/drivers/clk/qcom/clk-alpha-pll.c
+index 56f1795847cd..b3d1a39c835b 100644
+--- a/drivers/clk/qcom/clk-alpha-pll.c
++++ b/drivers/clk/qcom/clk-alpha-pll.c
+@@ -200,6 +200,17 @@ const u8 clk_alpha_pll_regs[][PLL_OFF_MAX_REGS] = {
+ 		[PLL_OFF_TEST_CTL_U] = 0x34,
+ 		[PLL_OFF_STATUS] = 0x28,
+ 	},
++	[CLK_ALPHA_PLL_TYPE_STROMER_PLUS] =  {
++		[PLL_OFF_L_VAL] = 0x04,
++		[PLL_OFF_USER_CTL] = 0x08,
++		[PLL_OFF_USER_CTL_U] = 0x0c,
++		[PLL_OFF_CONFIG_CTL] = 0x10,
++		[PLL_OFF_TEST_CTL] = 0x14,
++		[PLL_OFF_TEST_CTL_U] = 0x18,
++		[PLL_OFF_STATUS] = 0x1c,
++		[PLL_OFF_ALPHA_VAL] = 0x24,
++		[PLL_OFF_ALPHA_VAL_U] = 0x28,
++	},
+ };
+ EXPORT_SYMBOL_GPL(clk_alpha_pll_regs);
+ 
+diff --git a/drivers/clk/qcom/clk-alpha-pll.h b/drivers/clk/qcom/clk-alpha-pll.h
+index eb072ae7861c..42d2a93a28ba 100644
+--- a/drivers/clk/qcom/clk-alpha-pll.h
++++ b/drivers/clk/qcom/clk-alpha-pll.h
+@@ -26,6 +26,7 @@ enum {
+ 	CLK_ALPHA_PLL_TYPE_DEFAULT_EVO,
+ 	CLK_ALPHA_PLL_TYPE_BRAMMO_EVO,
+ 	CLK_ALPHA_PLL_TYPE_STROMER,
++	CLK_ALPHA_PLL_TYPE_STROMER_PLUS,
+ 	CLK_ALPHA_PLL_TYPE_MAX,
+ };
+ 
+-- 
+2.34.1
+
